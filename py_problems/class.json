[
  {
    "topic": "Classes and Objects",
    "level": "Easy",
    "title": "Define a Simple Class and Create Objects",
    "description": "This problem introduces the fundamental concepts of Object-Oriented Programming (OOP) in Python: defining a class and creating instances (objects) of that class. Your task is to: \n1. Define a class named `Dog`. \n2. Inside the `Dog` class, define an `__init__` method that takes two parameters: `name` (string) and `breed` (string). Store these as instance attributes. \n3. Create two `Dog` objects: one named 'Buddy' of 'Golden Retriever' breed, and another named 'Lucy' of 'Labrador' breed. \n4. Print the `name` and `breed` of each `Dog` object.",
    "constraints": "Define a class `Dog`. Implement `__init__` with `name` and `breed` attributes. Create at least two instances of `Dog`. Access and print the `name` and `breed` of each instance. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Dog 1: Buddy, Breed: Golden Retriever\nDog 2: Lucy, Breed: Labrador\n",
    "explanation": "The `Dog` class is defined. The `__init__` method is the constructor; `self.name = name` and `self.breed = breed` assign the passed arguments to instance attributes. Two `Dog` objects (`dog1`, `dog2`) are created by calling the class name like a function. Then, `dog1.name`, `dog1.breed`, etc., are used to access and print the attributes of each object."
  },
  {
    "topic": "Classes and Objects",
    "level": "Easy",
    "title": "Add Methods to a Class",
    "description": "This problem extends the previous one by adding **methods** (functions defined within a class) to an object, enabling it to perform actions. Your task is to: \n1. Reuse the `Dog` class from the previous problem (with `name` and `breed`). \n2. Add a new method named `bark(self)` to the `Dog` class. This method should print '[Dog Name] says Woof!'. \n3. Add another method named `get_info(self)` that returns a string like 'Name: [Name], Breed: [Breed]'. \n4. Create two `Dog` objects. \n5. Call the `bark()` method for both dogs. \n6. Call the `get_info()` method for both dogs and print the returned information.",
    "constraints": "Use the `Dog` class with `name` and `breed`. Add `bark(self)` method that prints. Add `get_info(self)` method that returns a string. Create two `Dog` instances. Call `bark()` on both. Call `get_info()` on both and print its return. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Buddy says Woof!\nLucy says Woof!\n\nDog 1 Info: Name: Buddy, Breed: Golden Retriever\nDog 2 Info: Name: Lucy, Breed: Labrador\n",
    "explanation": "The `Dog` class now includes `bark` and `get_info` methods. Inside `bark`, `self.name` is used to access the object's name attribute. `get_info` also accesses `self.name` and `self.breed` to construct a descriptive string. When `dog1.bark()` is called, Python automatically passes `dog1` as `self` to the method, allowing it to access `dog1`'s specific attributes."
  },
  {
    "topic": "Classes and Objects",
    "level": "Easy",
    "title": "Class Attributes vs. Instance Attributes",
    "description": "This problem differentiates between **class attributes** (shared by all instances) and **instance attributes** (unique to each instance). Your task is to: \n1. Define a class named `Car`. \n2. Add a **class attribute** `wheels = 4`. \n3. Implement an `__init__` method that takes `model` (string) and `color` (string) as parameters and stores them as **instance attributes**. \n4. Create two `Car` objects with different models and colors. \n5. Print the `model`, `color`, and `wheels` for each `Car` object. \n6. Change the `wheels` class attribute (e.g., to 6 for a theoretical future car). \n7. Print the `wheels` attribute again for both objects to show that the change affects all instances.",
    "constraints": "Define class `Car`. Add a class attribute `wheels`. Implement `__init__` with `model` and `color` as instance attributes. Create two `Car` instances. Print all attributes for both. Change the class attribute `wheels`. Print `wheels` for both again to demonstrate its shared nature. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Car 1: Model: Tesla, Color: Red, Wheels: 4\nCar 2: Model: BMW, Color: Blue, Wheels: 4\n\nChanging number of wheels for ALL cars...\n\nCar 1: Model: Tesla, Color: Red, Wheels: 6\nCar 2: Model: BMW, Color: Blue, Wheels: 6\n",
    "explanation": "The `Car.wheels = 4` line defines a class attribute, which is common to all instances. The `__init__` method defines instance attributes (`self.model`, `self.color`). When `Car.wheels = 6` is executed, it modifies the class attribute, which is then reflected when accessed through any instance (`car1.wheels`, `car2.wheels`), as instances look up attributes in their class if not found directly on the instance."
  },
  {
    "topic": "Classes and Objects",
    "level": "Medium",
    "title": "Inheritance: Base and Derived Classes",
    "description": "This problem demonstrates **inheritance**, a core OOP concept where a new class (child/derived) can inherit properties and methods from an existing class (parent/base). Your task is to: \n1. Define a base class named `Animal` with an `__init__` method that takes `name` and sets a `species` attribute (e.g., 'Generic Animal'). Add a method `speak()` that prints a generic message like '[Name] makes a sound.'. \n2. Define a derived class named `Cat` that inherits from `Animal`. \n3. The `Cat` class's `__init__` method should call the parent's `__init__` using `super().__init__(name, species='Cat')`. \n4. Override the `speak()` method in the `Cat` class to print '[Name] says Meow!'. \n5. Create an `Animal` object and a `Cat` object. \n6. Call the `speak()` method for both objects and print their `species`.",
    "constraints": "Define `Animal` class with `name` and `species` (default). Add `speak()` method to `Animal`. Define `Cat` class inheriting from `Animal`. `Cat`'s `__init__` must call `super().__init__` and set specific `species`. `Cat` must override `speak()`. Create one `Animal` and one `Cat` object. Call `speak()` and print `species` for both. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Generic Animal:\nLeo makes a sound.\nSpecies: Generic Animal\n\nCat:\nWhiskers says Meow!\nSpecies: Cat\n",
    "explanation": "The `Animal` class is defined with `__init__` and `speak()`. The `Cat` class `(Animal)` inherits from `Animal`. In `Cat`'s `__init__`, `super().__init__(name, species='Cat')` explicitly calls the parent's constructor, setting its `name` and overriding the `species` to 'Cat'. `Cat` also overrides `speak()` with its specific behavior. When `whiskers.speak()` is called, Python's Method Resolution Order (MRO) finds `speak` in `Cat` first. `whiskers.species` correctly shows 'Cat'."
  },
  {
    "topic": "Classes and Objects",
    "level": "Medium",
    "title": "Encapsulation: Private-like Attributes and Getters/Setters",
    "description": "This problem demonstrates **encapsulation** by showing how to manage attribute access using conventions for 'private' attributes and implementing getter/setter methods. While Python doesn't have true private attributes, using `_` prefix is a convention. Your task is to: \n1. Define a class named `BankAccount`. \n2. In its `__init__` method, store the `_balance` (float) as a 'private-like' attribute (using `_` prefix). \n3. Implement a **getter method** `get_balance(self)` that returns the `_balance`. \n4. Implement a **setter method** `set_balance(self, amount)` that: \n    * Takes an `amount` parameter. \n    * If `amount` is negative, print an error and do not update `_balance`. \n    * Otherwise, update `_balance` to `amount`. \n5. Create a `BankAccount` object with an initial balance. \n6. Use the getter to print the initial balance. \n7. Use the setter to attempt to set a new (positive) balance and print the updated balance. \n8. Use the setter to attempt to set a negative balance and demonstrate the error handling, then print the balance again (should be unchanged).",
    "constraints": "Define `BankAccount` class. Store `_balance` using `_` prefix. Implement `get_balance()` getter. Implement `set_balance()` setter with validation (no negative amounts). Create a `BankAccount` object. Test getter, successful setter, and unsuccessful (negative) setter. Print messages for each step. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Initial balance: $1000.00\nSetting balance to $1500.00...\nUpdated balance: $1500.00\nAttempting to set negative balance...\nError: Balance cannot be negative.\nBalance remains: $1500.00\n",
    "explanation": "The `BankAccount` class uses `_balance` to indicate it's intended for internal use. `get_balance` provides controlled read access. `set_balance` provides controlled write access: it validates `amount` before updating `_balance`, preventing invalid states. This demonstrates encapsulation by separating the internal data representation from the external interface, allowing for validation and controlled behavior."
  },
  {
    "topic": "Classes and Objects",
    "level": "Hard",
    "title": "Polymorphism with Abstract Base Class (ABC)",
    "description": "This problem introduces **polymorphism** (objects of different classes responding to the same method call in their own way) and using **Abstract Base Classes (ABCs)** to enforce method implementation in derived classes. Your task is to: \n1. Import `ABC` and `abstractmethod` from the `abc` module. \n2. Define an abstract base class `Shape` that inherits from `ABC`. \n3. In `Shape`, declare two abstract methods: `area(self)` and `perimeter(self)`. These methods should have no implementation. \n4. Define a concrete class `Rectangle` that inherits from `Shape`. \n5. `Rectangle`'s `__init__` should take `width` and `height`. \n6. `Rectangle` must implement both `area()` and `perimeter()` methods according to geometric formulas. \n7. Define another concrete class `Circle` that inherits from `Shape`. \n8. `Circle`'s `__init__` should take `radius`. \n9. `Circle` must implement both `area()` and `perimeter()` methods (using `math.pi`). \n10. Create a `Rectangle` object and a `Circle` object. \n11. Create a list containing these two objects. \n12. Iterate through the list. For each shape, call its `area()` and `perimeter()` methods and print the results. \n\n**Hint:** Abstract methods force derived classes to implement them, ensuring all shapes have `area` and `perimeter` behavior. Use `math.pi` for Circle calculations.",
    "constraints": "Import `ABC` and `abstractmethod`. Define `Shape` as an ABC with abstract methods `area()` and `perimeter()`. Define `Rectangle` inheriting `Shape`, implementing `__init__`, `area()`, `perimeter()`. Define `Circle` inheriting `Shape`, implementing `__init__`, `area()`, `perimeter()`. Create instances of both `Rectangle` and `Circle`. Store them in a list. Iterate and call `area()` and `perimeter()` on each, printing results. Use `math.pi`. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Rectangle:\nArea: 20.0\nPerimeter: 18.0\n\nCircle:\nArea: 28.27\nPerimeter: 18.85\n",
    "explanation": "The `Shape` class is defined as an ABC with `@abstractmethod` decorators for `area` and `perimeter`. This means any concrete class inheriting from `Shape` *must* implement these methods. `Rectangle` and `Circle` are concrete classes that provide their specific implementations for `area()` and `perimeter()`. When iterating through `shapes_list`, even though `s` is a generic `Shape` type, calling `s.area()` or `s.perimeter()` correctly invokes the method specific to the actual object's type (`Rectangle` or `Circle`), demonstrating polymorphism."
  },
  {
    "topic": "Classes and Objects",
    "level": "Tricky",
    "title": "Static Methods and Class Methods",
    "description": "This problem differentiates between **instance methods** (which operate on object instances), **class methods** (which operate on the class itself and its attributes), and **static methods** (which are utility functions within a class, not needing instance or class access). Your task is to: \n1. Define a class `MathOperations`. \n2. Add a **class attribute** `_operation_count = 0` to track how many operations have been performed. \n3. Implement a **static method** `add(x, y)` that returns `x + y`. This method should not access instance or class attributes. \n4. Implement a **class method** `get_operation_count(cls)` that returns the current value of `cls._operation_count`. \n5. Implement an **instance method** `perform_addition(self, x, y)`: \n    * It should use the `add` static method to calculate `x + y`. \n    * It should increment the `_operation_count` (the class attribute) using `MathOperations._operation_count += 1` or `cls._operation_count += 1`. \n    * Print the result of the addition. \n6. Create an instance of `MathOperations`. \n7. Call `perform_addition()` several times. \n8. Print the total operation count using `get_operation_count()` via both the class and an instance. \n\n**Hint:** Use `@staticmethod` and `@classmethod` decorators.",
    "constraints": "Define `MathOperations` class. Add class attribute `_operation_count`. Implement `@staticmethod add(x, y)`. Implement `@classmethod get_operation_count(cls)`. Implement instance method `perform_addition(self, x, y)` that calls `add` and increments `_operation_count`. Create an instance. Call `perform_addition` multiple times. Print operation count using both class and instance methods. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Result of 5 + 3: 8\nResult of 10 + 20: 30\nResult of 7 + 4: 11\n\nTotal operations performed (via class): 3\nTotal operations performed (via instance): 3\n",
    "explanation": "The `MathOperations` class demonstrates the three method types: \n* `add`: A `staticmethod` because it doesn't need `self` or `cls`; it's a utility function related to the class. \n* `get_operation_count`: A `classmethod` (receives `cls` as first argument). It operates on the class itself to access the `_operation_count` class attribute. \n* `perform_addition`: An instance method (receives `self`). It calls the `add` static method and directly increments the `MathOperations._operation_count` class attribute. \nThis setup clearly shows how each method type is used and how class attributes are shared and modified across instances."
  },
  {
    "topic": "Classes and Objects",
    "level": "Real World Problem",
    "title": "Book Management System",
    "description": "You are building a simple command-line book management system. This system should allow adding new books, listing all books, and checking out/returning books (updating their status). This integrates multiple OOP concepts into a practical application. Your task is to: \n1. Define a class `Book`: \n    * `__init__(self, title, author, isbn)`: Stores title, author, ISBN, and initializes `is_available = True`. \n    * `display_info(self)`: Prints all book details including availability. \n    * `checkout(self)`: If `is_available` is True, set to False and print 'Book checked out.'. Else, print 'Book is already checked out.'. \n    * `return_book(self)`: If `is_available` is False, set to True and print 'Book returned.'. Else, print 'Book is already available.'. \n2. Define a class `Library`: \n    * `__init__(self)`: Initializes `self.books = []` (a list to store `Book` objects). \n    * `add_book(self, book)`: Adds a `Book` object to `self.books`. \n    * `list_all_books(self)`: Iterates through `self.books` and calls `display_info()` for each. If no books, prints 'No books in library.'. \n    * `find_book_by_isbn(self, isbn)`: Iterates through `self.books`, returns the `Book` object if `isbn` matches, else returns `None`. \n3. Implement a menu-driven program (`while` loop) for user interaction: \n    * '1. Add Book', '2. List All Books', '3. Checkout Book', '4. Return Book', '5. Exit'. \n    * For 'Checkout'/'Return', ask for ISBN, use `find_book_by_isbn`, then call the appropriate method on the found book. \n\nThis problem integrates classes, objects, methods, instance attributes, and interactive menu logic.",
    "constraints": "Define `Book` class with specified attributes and methods. Define `Library` class with specified attributes and methods. Implement a menu-driven program loop. Handle user choices for adding, listing, checking out, and returning books. Use `find_book_by_isbn` for checkout/return. Print relevant messages for all operations. Assume unique ISBNs. Handle `ValueError` for ISBN input if you convert it.",
    "sampleInput": "1\nThe Great Gatsby\nF. Scott Fitzgerald\n978-0743273565\n2\n3\n978-0743273565\n2\n4\n978-0743273565\n5",
    "sampleOutput": "1. Add Book\n2. List All Books\n3. Checkout Book\n4. Return Book\n5. Exit\nEnter your choice: 1\nEnter title: The Great Gatsby\nEnter author: F. Scott Fitzgerald\nEnter ISBN: 978-0743273565\nBook 'The Great Gatsby' added.\n\n1. Add Book\n2. List All Books\n3. Checkout Book\n4. Return Book\n5. Exit\nEnter your choice: 2\n--- All Books in Library ---\nTitle: The Great Gatsby, Author: F. Scott Fitzgerald, ISBN: 978-0743273565, Available: True\n\n1. Add Book\n2. List All Books\n3. Checkout Book\n4. Return Book\n5. Exit\nEnter your choice: 3\nEnter ISBN of book to checkout: 978-0743273565\nBook checked out.\n\n1. Add Book\n2. List All Books\n3. Checkout Book\n4. Return Book\n5. Exit\nEnter your choice: 2\n--- All Books in Library ---\nTitle: The Great Gatsby, Author: F. Scott Fitzgerald, ISBN: 978-0743273565, Available: False\n\n1. Add Book\n2. List All Books\n3. Checkout Book\n4. Return Book\n5. Exit\nEnter your choice: 4\nEnter ISBN of book to return: 978-0743273565\nBook returned.\n\n1. Add Book\n2. List All Books\n3. Checkout Book\n4. Return Book\n5. Exit\nEnter your choice: 5\nExiting Library System.\n",
    "explanation": "This is a comprehensive OOP problem. \n* The `Book` class encapsulates `title`, `author`, `isbn`, and `is_available` state, with methods to display info, checkout, and return. \n* The `Library` class manages a collection of `Book` objects (`self.books`). It provides methods to add, list, and find books. \n* The main program uses a `while` loop to present a menu. It creates a `Library` object. User choices trigger calls to `Library` methods, which in turn might call `Book` methods. This structure clearly separates concerns and models a real-world scenario effectively using OOP principles."
  }
]