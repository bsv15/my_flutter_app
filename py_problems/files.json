[
  {
    "topic": "File Handling",
    "level": "Easy",
    "title": "Write and Read a Text File",
    "description": "This problem covers the fundamental operations of writing data to a text file and then reading it back. Your task is to: \n1. Prompt the user for a filename (e.g., `my_data.txt`). \n2. Prompt the user to enter a short sentence or phrase. \n3. Open the specified file in **write mode (`'w'`)** and write the user's sentence to it. Make sure to close the file. \n4. Open the same file in **read mode (`'r'`)** and read its entire content. \n5. Print the content read from the file. \n\n**Hint:** Use `with open(...) as f:` for safe file handling.",
    "constraints": "Prompt for filename and sentence. Write the sentence to the file using write mode (`'w'`). Close the file. Read the entire content of the same file using read mode (`'r'`). Print the content. Use `with` statement. Handle `IOError` or `FileNotFoundError` if applicable (though less likely for 'w' mode creating file).",
    "sampleInput": "Enter filename: my_file.txt\nEnter a sentence: This is a test sentence for file handling.",
    "sampleOutput": "Enter filename: my_file.txt\nEnter a sentence: This is a test sentence for file handling.\nFile 'my_file.txt' written successfully.\nContent read from 'my_file.txt':\nThis is a test sentence for file handling.\n",
    "explanation": "The program prompts for filename and content. It uses `with open(filename, 'w') as f:` to open the file in write mode, ensuring it's automatically closed. `f.write(content + '\\n')` writes the user's sentence (plus a newline for neatness). Then, it opens the same file in read mode with `with open(filename, 'r') as f:` and `f.read()` reads the entire content. The content is then printed."
  },
  {
    "topic": "File Handling",
    "level": "Easy",
    "title": "Append to an Existing File",
    "description": "This problem focuses on adding new data to the end of an existing file without overwriting its previous content. Your task is to: \n1. Create a simple text file named `log.txt` with initial content like 'Initial log entry.\\n'. \n2. Prompt the user to enter a new log message. \n3. Open `log.txt` in **append mode (`'a'`)** and write the user's log message to it, ensuring it's on a new line. \n4. Read and print the *entire* content of `log.txt` after appending to show both old and new entries. \n\n**Hint:** Remember to add a newline character `\\n` to the end of your written string if you want each new entry on a separate line.",
    "constraints": "Create an initial `log.txt` file. Prompt for a new log message. Open `log.txt` in append mode (`'a'`). Write the new message to the file with a newline. Close the file. Read the entire content of `log.txt` (including original and appended). Print the full content. Use `with` statement. Handle `FileNotFoundError` if `log.txt` doesn't initially exist (though for this problem, assume it does or create it first).",
    "sampleInput": "Enter new log message: Another event occurred at 12:30.",
    "sampleOutput": "Initial content of log.txt created.\n\nEnter new log message: Another event occurred at 12:30.\nNew log message appended successfully.\n\nFull content of log.txt:\nInitial log entry.\nAnother event occurred at 12:30.\n",
    "explanation": "The program first creates `log.txt` with initial content. It then prompts for a `new_log_message`. `with open('log.txt', 'a') as f:` opens the file in append mode. `f.write(new_log_message + '\\n')` writes the new message to the end of the file. Finally, the file is reopened in read mode to display its full content, demonstrating that the old content was preserved."
  },
  {
    "topic": "File Handling",
    "level": "Easy",
    "title": "Read File Line by Line",
    "description": "This problem focuses on reading a file line by line, which is efficient for large files and common for processing structured data. Your task is to: \n1. Create a text file named `poem.txt` with at least 3-4 lines of text. \n2. Open `poem.txt` in read mode. \n3. Read the file **line by line** and print each line, prepending a line number (e.g., '1: First line', '2: Second line'). \n\n**Hint:** A `for` loop directly over a file object iterates line by line. Remember that `readlines()` also returns a list of lines.",
    "constraints": "Create `poem.txt` with at least 3 lines. Open in read mode. Iterate line by line. Print each line with a line number prefix. Use `enumerate` for line numbers. Handle `FileNotFoundError`.",
    "sampleInput": "None (reads 'poem.txt')",
    "sampleOutput": "Content of poem.txt (line by line):\n1: Roses are red\n2: Violets are blue\n3: Python is cool\n4: And so are you!\n",
    "explanation": "The program first creates `poem.txt`. It then attempts to open the file. `for i, line in enumerate(f):` is the Pythonic way to iterate through a file object line by line while getting a line number. `enumerate` starts from 0, so `i + 1` is used for 1-based numbering. `line.strip()` removes leading/trailing whitespace, including the newline character, for cleaner output. `FileNotFoundError` is caught if the file doesn't exist."
  },
  {
    "topic": "File Handling",
    "level": "Medium",
    "title": "Count Words in a File",
    "description": "This problem combines file reading with string manipulation to perform a simple text analysis task. Your task is to: \n1. Create a text file named `article.txt` with several sentences. \n2. Prompt the user for the filename. \n3. Read the entire content of the file. \n4. Convert the content to lowercase. \n5. Split the content into words (you might need to handle punctuation). \n6. Count the total number of words. \n7. Print the total word count. \n\n**Hint:** After reading, you can replace punctuation with spaces, then use `split()` to get words. Consider edge cases like empty strings after splitting.",
    "constraints": "Create an `article.txt`. Prompt for filename. Read file content. Convert to lowercase. Clean punctuation (replace with spaces is fine). Split into words. Count total words. Print the count. Handle `FileNotFoundError`.",
    "sampleInput": "Enter filename: article.txt",
    "sampleOutput": "Enter filename: article.txt\nFile 'article.txt' read successfully.\nTotal words in 'article.txt': 25\n",
    "explanation": "The program creates `article.txt`. It prompts for the filename and handles `FileNotFoundError`. Inside, it reads the `text`. It then converts `text` to lowercase. A loop replaces common punctuation with spaces. `cleaned_text.split()` creates a list of words. `[word for word in words if word]` is a list comprehension that filters out any empty strings that might result from multiple spaces or punctuation at the beginning/end of the string after splitting. Finally, `len()` gives the word count, which is printed."
  },
  {
    "topic": "File Handling",
    "level": "Medium",
    "title": "Simple CSV Reader (Comma-Separated Values)",
    "description": "This problem involves reading a basic CSV (Comma-Separated Values) file and processing its data. It's a common format for tabular data. Your task is to: \n1. Create a `products.csv` file with header and data rows. Example: \n   `id,name,price` \n   `1,Laptop,1200.00` \n   `2,Mouse,25.50` \n   `3,Keyboard,75.00` \n2. Prompt the user for the filename. \n3. Read the file line by line. \n4. Skip the header row. \n5. For each data row, split the line by commas. \n6. Print each product's name and price, formatted (e.g., 'Product: Laptop, Price: $1200.00'). \n\n**Hint:** Use `strip()` to remove newlines, `split(',')` to separate values. You might need to convert price to float for formatting.",
    "constraints": "Create `products.csv` with a header and at least 3 data rows. Prompt for filename. Read file line by line. Skip the first line (header). Split each subsequent line by comma. Print product name and price, with price formatted to two decimal places. Handle `FileNotFoundError`. Assume clean CSV data (no commas within fields).",
    "sampleInput": "Enter CSV filename: products.csv",
    "sampleOutput": "Enter CSV filename: products.csv\nFile 'products.csv' opened successfully.\n--- Product List ---\nProduct: Laptop, Price: $1200.00\nProduct: Mouse, Price: $25.50\nProduct: Keyboard, Price: $75.00\n",
    "explanation": "The program creates `products.csv`. It prompts for the filename and handles `FileNotFoundError`. It then opens the file. `f.readline()` reads and discards the header. The `for line in f:` loop processes the remaining lines. `line.strip().split(',')` removes newlines and splits the line by commas. `name = parts[1]` and `price = float(parts[2])` extract the relevant data, with price converted to `float` for formatting. Each product's details are then printed using an f-string with `:.2f` formatting for the price."
  },
  {
    "topic": "File Handling",
    "level": "Hard",
    "title": "Encrypt/Decrypt a File (Simple XOR Cipher)",
    "description": "This problem involves reading binary data from a file, performing a simple encryption/decryption (like XOR cipher with a key), and writing the modified binary data to a new file. This requires understanding binary file modes (`'rb'`, `'wb'`) and byte operations. Your task is to: \n1. Create a small binary file (e.g., a `.txt` file, or just create it with some bytes) named `secret.txt` with some simple text content. \n2. Prompt the user for the input filename (`secret.txt`), the output filename (e.g., `encrypted.bin`), and a single character `key` (e.g., 'X') for the XOR cipher. \n3. Implement an encryption function: Read the input file in binary mode. For each byte, XOR it with the ASCII value of the `key` character. Write the resulting bytes to the output file in binary mode. \n4. Implement a decryption function: Read the encrypted file in binary mode. For each byte, XOR it *again* with the same `key`. Write the resulting bytes to a new decrypted file (e.g., `decrypted.txt`). \n5. Print confirmation messages for each operation. \n\n**Hint:** `ord(key_char)` gives the ASCII value of the key. `bytes([byte_value])` creates a single-byte bytes object for writing.",
    "constraints": "Create `secret.txt` with content. Prompt for input file, output file, and single-character key. Implement encryption and decryption functions. Read/write files in binary mode (`'rb'`, `'wb'`). Use XOR operation (`^`) with the key's ASCII value. Print confirmation. Handle `FileNotFoundError` and `IOError`. No user input for original file creation.",
    "sampleInput": "Enter input filename: secret.txt\nEnter encrypted output filename: encrypted.bin\nEnter decryption output filename: decrypted.txt\nEnter single character key: X",
    "sampleOutput": "Original file 'secret.txt' created.\n\nEnter input filename: secret.txt\nEnter encrypted output filename: encrypted.bin\nEnter decryption output filename: decrypted.txt\nEnter single character key: X\n\nEncrypting 'secret.txt' to 'encrypted.bin' with key 'X'...\nEncryption complete.\n\nDecrypting 'encrypted.bin' to 'decrypted.txt' with key 'X'...\nDecryption complete.\n\nContent of decrypted.txt: Hello, world! This is a secret message.\n",
    "explanation": "The `encrypt_decrypt_file` function handles both. It takes `in_filename`, `out_filename`, and `key_char`. It opens `in_filename` in `'rb'` and `out_filename` in `'wb'`. The `key_byte = ord(key_char)` gets the integer ASCII value of the key. It reads the input file byte by byte (`f_in.read(1)`). Each `byte[0]` (since `read(1)` returns a bytes object) is XORed with `key_byte`. `bytes([xor_byte])` converts the integer back to a single byte for writing. `try-except` blocks handle `FileNotFoundError` and `IOError`. The main program creates `secret.txt`, then calls the function for encryption and decryption, finally printing the decrypted content to verify."
  },
  {
    "topic": "File Handling",
    "level": "Tricky",
    "title": "Process Large File in Chunks (Memory Efficient)",
    "description": "This problem addresses memory-efficient processing of potentially very large files that cannot be loaded entirely into memory. Instead, you read and process them in smaller chunks. Your task is to: \n1. Create a large text file named `large_data.txt` (e.g., by writing 10,000 lines of random text or numbers). \n2. Prompt the user for the filename and `chunk_size` (e.g., 1024 bytes). \n3. Read the file in binary mode (`'rb'`) in chunks of the specified `chunk_size`. \n4. For each chunk, print its size in bytes. \n5. As a demonstration, count the total number of times a specific `target_byte` (e.g., `ord('e')`) appears in the entire file. \n6. Print the total count of the target byte. \n\n**Hint:** `f.read(chunk_size)` reads bytes. You'll need to iterate through the bytes in the chunk to count a specific byte value.",
    "constraints": "Create a `large_data.txt` file (at least 10KB). Prompt for filename and `chunk_size` (integer). Read file in binary mode (`'rb'`). Read in chunks of `chunk_size`. Print size of each chunk. Count occurrences of a `target_byte` throughout the file. Print total count. Handle `FileNotFoundError` and `IOError`. Use `ord()` for target byte.",
    "sampleInput": "Enter filename: large_data.txt\nEnter chunk size (bytes): 1024",
    "sampleOutput": "Original 'large_data.txt' created with 10000 lines.\n\nEnter filename: large_data.txt\nEnter chunk size (bytes): 1024\n\nReading 'large_data.txt' in chunks of 1024 bytes...\nChunk size: 1024 bytes\nChunk size: 1024 bytes\n... (many lines of 'Chunk size: 1024 bytes') ...\nChunk size: 1024 bytes\nChunk size: 848 bytes\n\nTotal occurrences of 'e' (byte 101): 11211\n",
    "explanation": "The program first creates `large_data.txt` by writing many lines to it. It then prompts for filename and `chunk_size`. It opens the file in `'rb'` mode. It enters a `while True` loop: `f.read(chunk_size)` attempts to read a chunk. If `not chunk`, it means End Of File is reached, and the loop breaks. For each `chunk`, its length is printed, and the program iterates through its bytes to count `target_byte`. This demonstrates how to process large files without loading them entirely into RAM, suitable for very large datasets."
  },
  {
    "topic": "File Handling",
    "level": "Real World Problem",
    "title": "Student Grade Management (CSV)",
    "description": "You are building a small application for a teacher to manage student grades. This involves reading student data from a CSV, calculating average grades, and potentially writing updated data back. Your task is to: \n1. Create a `grades.csv` file with student data: \n   `Name,Math,Science,English` \n   `Alice,85,90,78` \n   `Bob,92,88,95` \n   `Charlie,70,65,72` \n2. Prompt the user for the filename. \n3. Read the `grades.csv` file. Skip the header. \n4. For each student, calculate their `average_grade` across Math, Science, and English. \n5. Store student data in a list of dictionaries, where each dictionary includes 'Name' and 'Average' (e.g., `{'Name': 'Alice', 'Average': 84.33}`). \n6. Print a formatted report of each student's name and average grade. \n7. **(Optional Advanced)**: Write a new CSV file `grades_avg.csv` containing `Name,Average` for each student. \n\n**Hint:** Use `float()` for grades. Handle `ValueError` during grade conversion. `csv` module is ideal for this, but for this problem, use manual `split(',')` to reinforce string parsing.",
    "constraints": "Create `grades.csv` with a header and at least 3 student rows. Prompt for filename. Read file line by line. Skip header. For each data row, calculate average of three numeric grades. Store results in a list of dictionaries. Print formatted report (Name, Average to 2 decimal places). Handle `FileNotFoundError` and `ValueError` for non-numeric grades (skip invalid rows or print error). (Optional: Write to new CSV).",
    "sampleInput": "Enter grades filename: grades.csv",
    "sampleOutput": "Enter grades filename: grades.csv\nFile 'grades.csv' opened successfully.\n\n--- Student Grade Report ---\nName: Alice, Average Grade: 84.33\nName: Bob, Average Grade: 91.67\nName: Charlie, Average Grade: 69.00\n\n(Optional) 'grades_avg.csv' created.\n",
    "explanation": "The program creates `grades.csv`. It prompts for the filename and handles `FileNotFoundError`. It then opens the file, reads and discards the header. It iterates through the remaining lines. For each `line`, `line.strip().split(',')` gets the parts. A `try-except ValueError` block attempts to convert the grade strings to floats. If successful, `sum(grades) / len(grades)` calculates the average. A dictionary `{'Name': student_name, 'Average': avg}` is created and added to `student_data`. Finally, it iterates through `student_data` to print the report, formatting averages to two decimal places. The optional part demonstrates writing the processed data to a new CSV file."
  }
]