[
  {
    "topic": "Constructors (Detailed)",
    "level": "Easy",
    "title": "Default Constructor and Custom Constructor for 'Person'",
    "description": "This problem illustrates the concept of default (no-argument) constructors and custom (parameterized) constructors. Your task is to: \n1. Create a `Person` class. \n2. Define two instance variables: `String name` and `int age`. \n3. Create an explicit **default constructor** for `Person` that initializes `name` to \"Unknown\" and `age` to `0`, and prints 'Default constructor called.'. \n4. Create a **parameterized constructor** for `Person` that takes `String name` and `int age` as arguments, initializes the instance variables, and prints 'Parameterized constructor called.'. \n5. In your `main` method: \n    * Create a `Person` object using the default constructor. \n    * Create another `Person` object using the parameterized constructor (e.g., \"Alice\", 30). \n    * Print the details (name and age) of both person objects.",
    "constraints": "Create `Person` class. Define `name` and `age`. Implement an explicit no-arg constructor and a parameterized constructor. Each constructor should print a message on call. Create one object with each constructor in `main`. Print details of both objects. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Default constructor called.\nPerson 1: Name: Unknown, Age: 0\nParameterized constructor called.\nPerson 2: Name: Alice, Age: 30\n",
    "explanation": "Java provides a **default constructor** automatically if you don't define any constructors. However, once you define *any* constructor (like a parameterized one), the automatic default constructor is no longer provided. This problem explicitly defines both to show their distinct roles. The default constructor initializes objects to a basic state, while the parameterized constructor allows for immediate initialization with specific values, making object creation more flexible."
  },
  {
    "topic": "Constructors (Detailed)",
    "level": "Easy",
    "title": "Constructor Overloading for 'Product'",
    "description": "This problem reinforces **constructor overloading**, allowing objects to be initialized in different ways. Your task is to: \n1. Create a `Product` class. \n2. Define instance variables: `String productId`, `String name`, `double price`, `int stock`. \n3. Create a constructor that takes `productId`, `name`, `price`, and `stock` to initialize all fields. \n4. Overload the constructor: Create another constructor that takes only `productId` and `name`. This constructor should set `price` to `0.0` and `stock` to `0`. \n5. Overload again: Create a constructor that takes `productId`, `name`, and `price`. This constructor should set `stock` to `0`. \n6. Add a `public void displayProductInfo()` method to print all product details. \n7. In `main`: \n    * Create three `Product` objects, each using a different overloaded constructor. \n    * Call `displayProductInfo()` for each product.",
    "constraints": "Create `Product` class with specified attributes. Implement three overloaded constructors with distinct parameter lists. Implement `displayProductInfo()`. Create three `Product` objects, each using a different constructor. Display info for all. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Product 1:\nID: P001, Name: Laptop, Price: $1200.00, Stock: 50\n\nProduct 2:\nID: P002, Name: Mouse, Price: $0.00, Stock: 0\n\nProduct 3:\nID: P003, Name: Keyboard, Price: $75.00, Stock: 0\n",
    "explanation": "**Constructor overloading** is a form of polymorphism that enables you to create multiple constructors within the same class, as long as each has a unique signature (different number or types of parameters). This provides flexibility in how objects can be initialized. The compiler determines which constructor to call based on the arguments provided during object creation. This improves usability by allowing objects to be created with varying levels of initial data."
  },
  {
    "topic": "Constructors (Detailed)",
    "level": "Medium",
    "title": "Constructor Chaining with 'this()'",
    "description": "This problem demonstrates **constructor chaining** using the `this()` keyword, which allows one constructor to call another constructor within the same class. Your task is to: \n1. Create an `Employee` class. \n2. Define instance variables: `String employeeId`, `String name`, `double salary`, `String department`. \n3. Create a constructor `public Employee(String employeeId, String name, double salary, String department)` that initializes all four fields. \n4. Create a second constructor `public Employee(String employeeId, String name)`: \n    * This constructor should use `this()` to call the first constructor, setting `salary` to `0.0` and `department` to \"Unassigned\" by default. \n    * Print 'Two-arg constructor called.' inside this constructor. \n5. Add a `public void displayEmployeeDetails()` method to print all employee details. \n6. In your `main` method: \n    * Create an `Employee` object using the two-argument constructor (e.g., \"E001\", \"Alice\"). \n    * Create another `Employee` object using the four-argument constructor (e.g., \"E002\", \"Bob\", 60000.0, \"IT\"). \n    * Call `displayEmployeeDetails()` for both employees.",
    "constraints": "Create `Employee` class with specified attributes. Implement a 4-arg constructor. Implement a 2-arg constructor that uses `this()` to call the 4-arg constructor with default values. The 2-arg constructor must print a message. Implement `displayEmployeeDetails()`. Create two `Employee` objects, one with each constructor. Display details for both. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Two-arg constructor called.\nEmployee ID: E001\nName: Alice\nSalary: $0.00\nDepartment: Unassigned\n\nEmployee ID: E002\nName: Bob\nSalary: $60000.00\nDepartment: IT\n",
    "explanation": "**Constructor chaining** using `this()` is a powerful technique. It allows you to reuse logic from one constructor in another, avoiding code duplication. When `this()` is called, it must be the very first statement in the constructor. This problem demonstrates how a more general constructor can set default values for some fields and then call a more specific constructor to handle the core initialization logic, making code cleaner and more maintainable."
  },
  {
    "topic": "Constructors (Detailed)",
    "level": "Medium",
    "title": "Copy Constructor for 'Circle' Class",
    "description": "This problem introduces the concept of a **copy constructor**, which creates a new object as a copy of an existing object. Your task is to: \n1. Create a `Circle` class. \n2. Define a `private double radius` instance variable. \n3. Create a constructor `public Circle(double radius)` that initializes `radius`. Add validation: if `radius` is negative, set it to `0.0` and print a warning. \n4. Create a **copy constructor** `public Circle(Circle originalCircle)`: \n    * This constructor should take an existing `Circle` object as a parameter. \n    * It should create a new `Circle` object with the same `radius` as the `originalCircle`. \n    * Print 'Copy constructor called.' \n5. Add a `public double getArea()` method that returns the area of the circle (`Math.PI * radius * radius`). \n6. In your `main` method: \n    * Create an `originalCircle` object. \n    * Create a `copiedCircle` object using the copy constructor, passing `originalCircle`. \n    * Print the `radius` and `area` of both the `originalCircle` and the `copiedCircle`.",
    "constraints": "Create `Circle` class with `private radius`. Implement a parameterized constructor with validation for non-negative radius. Implement a copy constructor that takes a `Circle` object and initializes the new object's radius from the original. The copy constructor must print a message. Implement `getArea()`. Create an `originalCircle` and a `copiedCircle` using the copy constructor in `main`. Print details of both. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Original Circle:\nRadius: 5.00, Area: 78.54\nCopy constructor called.\nCopied Circle:\nRadius: 5.00, Area: 78.54\n",
    "explanation": "A **copy constructor** is a constructor that takes an object of the same class as its parameter. Its purpose is to create a new object that is an exact copy of the provided object. This is useful when you want to avoid aliasing (where two references point to the same object) or when you need a distinct copy of an object's state. It's particularly important when objects contain mutable fields (though `double` is primitive here, the concept applies)."
  },
  {
    "topic": "Constructors (Detailed)",
    "level": "Hard",
    "title": "Immutable 'ComplexNumber' with Chained Constructors",
    "description": "This problem combines constructor chaining with the concept of immutability for a mathematical class. Your task is to: \n1. Create an **immutable** `ComplexNumber` class. \n2. Define `private final double real` and `private final double imaginary` instance variables. \n3. Create a constructor `public ComplexNumber(double real, double imaginary)` that initializes both fields. \n4. Overload the constructor: Create a constructor `public ComplexNumber(double real)` that uses `this()` to set `imaginary` to `0.0`. \n5. Overload again: Create a constructor `public ComplexNumber()` that uses `this()` to set both `real` and `imaginary` to `0.0`. \n6. Add public getter methods for `real` and `imaginary`. There should be no setters. \n7. Add a `public ComplexNumber add(ComplexNumber other)` method that returns a **new** `ComplexNumber` object representing the sum of `this` complex number and `other`. \n8. Override the `toString()` method to return a string representation like `(real + imaginary i)` (e.g., `(3.0 + 4.0i)` or `(5.0)` if imaginary is 0). \n9. In `main`: \n    * Create `ComplexNumber` objects using each of the three constructors. \n    * Demonstrate adding two `ComplexNumber` objects and print the result. \n    * Print all objects using their `toString()` method.",
    "constraints": "`ComplexNumber` class must be immutable (`private final` fields, no setters). Implement three constructors as specified, using `this()` for chaining. Implement getters. Implement `add()` method returning a *new* `ComplexNumber`. Override `toString()`. In `main`, demonstrate all constructors and the `add()` method, printing all objects. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Complex Number 1 (default): (0.0)\nComplex Number 2 (real only): (5.0)\nComplex Number 3 (full): (3.0 + 4.0i)\nSum of CN2 and CN3: (8.0 + 4.0i)\n",
    "explanation": "This problem combines several advanced constructor concepts with immutability. The `private final` fields ensure immutability. Constructor chaining (`this(real, 0.0);`, `this(0.0);`) reduces redundancy by calling the most comprehensive constructor. The `add()` method, crucial for an immutable class, doesn't modify the existing object but rather creates and returns a *new* `ComplexNumber` object with the summed values. This demonstrates how to design robust and predictable classes, especially important for mathematical objects where state consistency is vital."
  },
  {
    "topic": "Constructors (Detailed)",
    "level": "Tricky",
    "title": "Private Constructor for Singleton Pattern",
    "description": "This problem introduces the **Singleton design pattern**, which ensures a class has only one instance and provides a global point of access to it. This is typically achieved using a private constructor. Your task is to: \n1. Create a class named `Logger`. \n2. Make its constructor `private`: `private Logger()`. Inside, print 'Logger instance created.'. \n3. Add a `private static Logger instance;` field. \n4. Create a `public static Logger getInstance()` method: \n    * This method should implement the singleton logic: if `instance` is `null`, create a new `Logger` object and assign it to `instance`. \n    * Otherwise, return the existing `instance`. \n5. Add a `public void log(String message)` method that prints the message prefixed with '[LOG] '. \n6. In your `main` method: \n    * Get two `Logger` instances using `Logger.getInstance()`. \n    * Print whether the two instances are the same object (using `==`). \n    * Call `log()` on both instances to demonstrate they operate on the same object.",
    "constraints": "Create `Logger` class. Constructor must be `private`. Implement `private static Logger instance;`. Implement `public static Logger getInstance()` with lazy initialization (check `null`). Implement `log()` method. In `main`, get two instances using `getInstance()`, check for equality using `==`, and call `log()` on both. No user input required.",
    "sampleInput": "None",
    "sampleOutput": "Logger instance created.\nAre both instances the same object? true\n[LOG] First log message.\n[LOG] Second log message.\n",
    "explanation": "The **Singleton pattern** restricts instantiation of a class to a single object. The `private` constructor prevents direct instantiation from outside the class. The `getInstance()` method acts as the sole access point. The `if (instance == null)` check ensures **lazy initialization** (the object is created only when first needed). This is 'tricky' because it subverts the typical `new` keyword usage and requires careful understanding of `static` members and design patterns for controlled object creation."
  },
  {
    "topic": "Constructors (Detailed)",
    "level": "Tricky",
    "title": "Order of Initialization: Static, Instance, Constructor",
    "description": "This problem aims to clarify the order of execution for static blocks, instance initializer blocks, and constructors. Your task is to: \n1. Create a class named `InitializationOrder`. \n2. Add a `public static` field `staticField = 10;`. \n3. Add a **static initialization block** (`static {}`). Inside, print 'Static Block: staticField is ' + `staticField` and increment `staticField`. \n4. Add an `int` instance field `instanceField = 5;`. \n5. Add an **instance initializer block** (`{}`). Inside, print 'Instance Block: instanceField is ' + `instanceField` and increment `instanceField`. Also, print 'Instance Block: staticField is ' + `staticField`. \n6. Create a constructor `public InitializationOrder()`. Inside, print 'Constructor: instanceField is ' + `instanceField` and increment `instanceField`. Also, print 'Constructor: staticField is ' + `staticField`. \n7. In your `main` method: \n    * Print 'Main method started.'. \n    * Create two `InitializationOrder` objects. \n    * Print 'Main method finished.'. \n\n**Key Learning:** Carefully observe the output sequence to understand the execution order.",
    "constraints": "Create `InitializationOrder` class with specified static/instance fields and blocks. Implement static block, instance block, and constructor as described, each printing its execution and current field values. In `main`, print 'started'/'finished' and create two objects. No user input required.",
    "sampleInput": "None",
    "sampleOutput": "Main method started.\nStatic Block: staticField is 10\nInstance Block: instanceField is 5\nInstance Block: staticField is 11\nConstructor: instanceField is 6\nConstructor: staticField is 11\nInstance Block: instanceField is 5\nInstance Block: staticField is 11\nConstructor: instanceField is 6\nConstructor: staticField is 11\nMain method finished.\n",
    "explanation": "This problem meticulously demonstrates Java's object and class initialization order: \n1. **Static Members (fields and blocks)**: Executed *once*, when the class is first loaded. `staticField` is initialized, then the `static {}` block runs. \n2. **Instance Initializer Blocks (and instance field initializers)**: Executed *every time* a new object is created, *before* the constructor. `instanceField` is initialized, then the `{}` block runs. \n3. **Constructor**: Executed *every time* a new object is created, *after* instance initializer blocks. \nUnderstanding this sequence is crucial for predicting program behavior, especially when dealing with complex class structures and potential side effects during initialization."
  },
  {
    "topic": "Constructors (Detailed)",
    "level": "Real World Problem",
    "title": "Configurable Logging System (Logger with Levels)",
    "description": "You need to create a logging system where the logging level can be set during initialization. Your task is to: \n1. Create a `Logger` class (not a Singleton for this problem). \n2. Define `private String loggerName` and `private String logLevel` (e.g., \"INFO\", \"DEBUG\", \"ERROR\"). \n3. Create a constructor `public Logger(String loggerName, String logLevel)` that initializes these fields. Add validation for `logLevel`: if it's not one of \"INFO\", \"DEBUG\", \"ERROR\", default to \"INFO\" and print a warning. \n4. Create an overloaded constructor `public Logger(String loggerName)` that uses `this()` to call the two-argument constructor, setting the default `logLevel` to \"INFO\". \n5. Add a `public void logMessage(String level, String message)` method: \n    * This method should only print the `message` if the `level` of the message (`DEBUG`, `INFO`, `ERROR`) is at or above the `logger`'s configured `logLevel`. (e.g., if `logLevel` is \"INFO\", `DEBUG` messages are ignored, `INFO` and `ERROR` messages are printed). \n    * Print message in format: `[LoggerName] [LEVEL] Message: [Message]` \n6. In `main`: \n    * Create a `Logger` named \"AppLogger\" with `logLevel` \"INFO\". \n    * Create another `Logger` named \"DebugLogger\" with `logLevel` \"DEBUG\". \n    * Call `logMessage()` on both loggers with messages of different levels (DEBUG, INFO, ERROR) to observe filtering.",
    "constraints": "Create `Logger` class. Implement two constructors (one overloaded, using `this()`). Constructor must validate `logLevel` with default. Implement `logMessage()` with level filtering logic. In `main`, create two `Logger` objects with different levels and demonstrate logging messages of various levels, observing which are printed. Close `Scanner` if using. No user input beyond hardcoded values.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Configuring Logger 'AppLogger' with level INFO.\nConfiguring Logger 'DebugLogger' with level DEBUG.\n\n[AppLogger] INFO Message: Application started.\n[AppLogger] ERROR Message: An unexpected error occurred.\n[DebugLogger] DEBUG Message: Debugging network connection.\n[DebugLogger] INFO Message: User logged in.\n[DebugLogger] ERROR Message: Database connection failed.\n",
    "explanation": "This problem simulates a configurable logging system, a crucial component in most software. It reinforces constructor overloading and validation. The `logMessage` method demonstrates complex conditional logic based on the `logLevel` attribute of the `Logger` object. This requires comparing message levels (e.g., DEBUG < INFO < ERROR) to decide whether to print. This is a practical example of how constructors enable flexible object configuration and how methods implement behavior influenced by an object's initial state."
  }
]