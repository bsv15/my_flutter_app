[
  {
    "topic": "Inheritance and Polymorphism",
    "level": "Easy",
    "title": "Basic Inheritance: Animal and Dog",
    "description": "This problem introduces the fundamental concept of **inheritance** (is-a relationship). Your task is to: \n1. Create a `Animal` class: \n    * `String name`, `int age`. \n    * Constructor `public Animal(String name, int age)`. \n    * `public void makeSound()` method that prints 'Animal makes a sound.'. \n2. Create a `Dog` class that **extends** `Animal`. \n    * Add `String breed` specific to `Dog`. \n    * Constructor `public Dog(String name, int age, String breed)`: Call the superclass constructor. \n    * **Override** `public void makeSound()` method to print 'Dog barks! Woof!'. \n    * Add a `public void fetch()` method specific to `Dog` that prints 'Dog fetches the ball.'. \n3. In your `main` method: \n    * Create an `Animal` object. Call `makeSound()`. \n    * Create a `Dog` object. Call `makeSound()` and `Workspace()`. \n    * Demonstrate polymorphism: Declare an `Animal` reference but assign a `Dog` object to it. Call `makeSound()` on this reference.",
    "constraints": "`Dog` must extend `Animal`. `Dog` constructor must call `super()`. `Dog` must override `makeSound()`. Demonstrate all specified method calls, including polymorphism. No user input.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Animal makes a sound.\nDog barks! Woof!\nDog fetches the ball.\nDog barks! Woof!\n",
    "explanation": "**Inheritance** allows a class (`Dog`) to inherit properties and behaviors from another class (`Animal`), forming an 'is-a' relationship (a `Dog` *is an* `Animal`). The `super()` call in the subclass constructor invokes the superclass's constructor to initialize inherited fields. **Method overriding** allows a subclass to provide a specific implementation for a method already defined in its superclass. **Polymorphism** (meaning 'many forms') is shown when an `Animal` reference points to a `Dog` object; the overridden `makeSound()` method (from `Dog`) is executed at runtime, demonstrating runtime polymorphism."
  },
  {
    "topic": "Inheritance and Polymorphism",
    "level": "Easy",
    "title": "Abstract Class: Shape and Circle/Rectangle",
    "description": "This problem introduces **abstract classes** and methods, which define a common interface but leave implementation details to subclasses. Your task is to: \n1. Create an `abstract class Shape`: \n    * Define `String color`. \n    * Constructor `public Shape(String color)`. \n    * An `abstract public double calculateArea()` method (no implementation). \n    * A `public void displayColor()` method that prints the `color`. \n2. Create a `Circle` class that **extends** `Shape`: \n    * `double radius`. \n    * Constructor `public Circle(String color, double radius)`. \n    * **Implement** `public double calculateArea()` for a circle. \n3. Create a `Rectangle` class that **extends** `Shape`: \n    * `double length`, `double width`. \n    * Constructor `public Rectangle(String color, double length, double width)`. \n    * **Implement** `public double calculateArea()` for a rectangle. \n4. In `main`: \n    * Create `Circle` and `Rectangle` objects. \n    * Use a `Shape` array or `ArrayList` to store these objects. \n    * Iterate through the collection, call `displayColor()` and `calculateArea()` (printing the area) for each `Shape`.",
    "constraints": "`Shape` must be `abstract` with an abstract method. `Circle` and `Rectangle` must extend `Shape` and implement `calculateArea`. Use polymorphism in `main` to iterate and call methods. No user input.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Shape: Circle, Color: Red, Area: 78.54\nShape: Rectangle, Color: Blue, Area: 50.00\n",
    "explanation": "An **abstract class** cannot be instantiated directly and often contains **abstract methods** (methods without a body) that subclasses *must* implement. `Shape` defines a common blueprint (`color`, `calculateArea`, `displayColor`) for all geometric shapes. `Circle` and `Rectangle` provide their specific `calculateArea` implementations. Polymorphism allows treating `Circle` and `Rectangle` objects as generic `Shape` objects, making it easy to process different shapes uniformly in a collection. This demonstrates how abstract classes enforce structure and facilitate polymorphic behavior."
  },
  {
    "topic": "Inheritance and Polymorphism",
    "level": "Medium",
    "title": "Method Overriding and `super` Keyword",
    "description": "This problem focuses on **method overriding** and using the `super` keyword to call the superclass's overridden method. Your task is to: \n1. Create a `Vehicle` class: \n    * `String type`. \n    * Constructor `public Vehicle(String type)`. \n    * `public void startEngine()` method that prints 'The [type] engine starts.'. \n2. Create a `Car` class that extends `Vehicle`: \n    * `String model`. \n    * Constructor `public Car(String type, String model)`: Call superclass constructor. \n    * **Override** `public void startEngine()`: First, call `super.startEngine()` then print 'The [model] car's engine purrs smoothly.'. \n    * Add `public void drive()` method specific to `Car` that prints 'The [model] car is driving.'. \n3. In your `main` method: \n    * Create a `Car` object. \n    * Call `startEngine()` on the `Car` object. \n    * Call `drive()` on the `Car` object.",
    "constraints": "`Car` extends `Vehicle`. `Car` constructor calls `super()`. `Car` must override `startEngine()` and *explicitly call* `super.startEngine()`. Implement `drive()` in `Car`. Create `Car` object and call methods in `main`. No user input.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "The Car engine starts.\nThe Sedan car's engine purrs smoothly.\nThe Sedan car is driving.\n",
    "explanation": "When a subclass overrides a method, it provides its own implementation. However, sometimes you want to extend the superclass's behavior rather than completely replace it. The `super.methodName()` syntax allows you to explicitly call the overridden method of the immediate superclass. This is useful for adding subclass-specific logic while retaining or enhancing the base functionality defined in the parent class. This problem illustrates this common pattern for extending inherited behavior."
  },
  {
    "topic": "Inheritance and Polymorphism",
    "level": "Medium",
    "title": "Interfaces and Multiple Implementations",
    "description": "This problem demonstrates **interfaces** as contracts for behavior that can be implemented by multiple, unrelated classes. Your task is to: \n1. Create an `interface Drivable`: \n    * `public void start();` \n    * `public void stop();` \n    * `public void accelerate(int speed);` \n2. Create a `Bicycle` class that **implements** `Drivable`: \n    * `private int currentSpeed`. \n    * Implement all `Drivable` methods (e.g., `start` prints 'Bicycle starts pedaling', `accelerate` updates speed and prints, `stop` sets speed to 0 and prints). \n3. Create a `Car` class that **implements** `Drivable`: \n    * `private int currentSpeed`. \n    * Implement all `Drivable` methods (e.g., `start` prints 'Car engine starts', `accelerate` updates speed and prints, `stop` sets speed to 0 and prints). \n4. In your `main` method: \n    * Create an `ArrayList<Drivable>` (demonstrates polymorphism). \n    * Add a `Bicycle` object and a `Car` object to the list. \n    * Iterate through the `ArrayList`, calling `start()`, `accelerate(20)`, and `stop()` for each `Drivable` object.",
    "constraints": "`Drivable` must be an interface. Both `Bicycle` and `Car` must implement `Drivable` and provide concrete implementations for all its methods. Use `ArrayList<Drivable>` in `main` to store both types of objects. Iterate and call interface methods polymorphically. No user input.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Bicycle starts pedaling\nBicycle accelerating to 20 km/h\nBicycle stops. Current speed: 0 km/h\nCar engine starts\nCar accelerating to 20 km/h\nCar stops. Current speed: 0 km/h\n",
    "explanation": "An **interface** defines a contract: a set of methods that any class implementing it *must* provide. Unlike abstract classes, a class can implement multiple interfaces (achieving 'multiple inheritance of type'). `Drivable` ensures that any object declared as `Drivable` (like `Bicycle` or `Car`) will have `start`, `stop`, and `accelerate` methods, even though their implementations differ. Polymorphism allows you to treat `Bicycle` and `Car` interchangeably as `Drivable` objects, enabling generic programming and flexible design."
  },
  {
    "topic": "Inheritance and Polymorphism",
    "level": "Hard",
    "title": "Abstract Class with Concrete and Abstract Methods",
    "description": "This problem combines concrete methods and abstract methods within an abstract class, providing a common implementation while forcing subclasses to implement specific behavior. Your task is to: \n1. Create an `abstract class Employee`: \n    * `String name`, `String employeeId`. \n    * `double baseSalary`. \n    * Constructor `public Employee(String name, String employeeId, double baseSalary)`. \n    * A **concrete** method `public void displayBasicInfo()` that prints name and ID. \n    * An `abstract public double calculateSalary()` method. \n    * An `abstract public void performDuty()` method. \n2. Create a `SalariedEmployee` class that extends `Employee`: \n    * `double bonusRate`. \n    * Constructor `public SalariedEmployee(name, id, baseSalary, bonusRate)`. \n    * Implement `calculateSalary()`: `baseSalary + (baseSalary * bonusRate)`. \n    * Implement `performDuty()`: prints 'Salaried employee handles administrative tasks.'. \n3. Create an `HourlyEmployee` class that extends `Employee`: \n    * `double hourlyRate`, `int hoursWorked`. \n    * Constructor `public HourlyEmployee(name, id, baseSalary, hourlyRate, hoursWorked)`. \n    * Implement `calculateSalary()`: `baseSalary + (hourlyRate * hoursWorked)`. \n    * Implement `performDuty()`: prints 'Hourly employee completes assigned project work.'. \n4. In `main`: \n    * Create `SalariedEmployee` and `HourlyEmployee` objects. \n    * Store them in an `ArrayList<Employee>`. \n    * Iterate, call `displayBasicInfo()`, `performDuty()`, and print the `calculateSalary()` for each.",
    "constraints": "`Employee` is `abstract` with concrete and abstract methods. Subclasses must implement abstract methods. Use `ArrayList<Employee>` in `main`. Call methods polymorphically. No user input.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Employee: Alice (E001)\nDuty: Salaried employee handles administrative tasks.\nSalary: $55000.00\n\nEmployee: Bob (E002)\nDuty: Hourly employee completes assigned project work.\nSalary: $40000.00\n",
    "explanation": "This problem demonstrates the power of abstract classes in establishing a common framework for related classes. `Employee` provides shared functionality (`displayBasicInfo`) while deferring specific behaviors (`calculateSalary`, `performDuty`) to its concrete subclasses. This ensures consistency for common actions (`displayBasicInfo`) but allows for specialized logic based on the employee type. Polymorphism enables you to treat all types of employees uniformly through an `Employee` reference, despite their distinct implementations, which is crucial for managing diverse employee types in a system."
  },
  {
    "topic": "Inheritance and Polymorphism",
    "level": "Hard",
    "title": "Polymorphic Collections and instanceof Operator",
    "description": "This problem utilizes polymorphism with collections and introduces the `instanceof` operator for type checking. Your task is to: \n1. Reuse the `Shape` (abstract), `Circle`, and `Rectangle` classes from the 'Abstract Class' problem. \n2. In your `main` method: \n    * Create an `ArrayList<Shape> shapes`. \n    * Add a `Circle`, a `Rectangle`, and another `Circle` to the `shapes` list. \n    * Iterate through the `shapes` list using an enhanced for-loop. \n    * Inside the loop, for each `Shape` object: \n        * Call `displayColor()`. \n        * Print its area using `calculateArea()`. \n        * Use the `instanceof` operator to check if the current `Shape` is a `Circle`. If it is, cast it to `Circle` and print its `radius` (you'll need to add a getter for `radius` in `Circle`). \n        * Use `instanceof` to check if it's a `Rectangle`. If it is, cast it to `Rectangle` and print its `length` and `width` (add getters for these).",
    "constraints": "Reuse `Shape`, `Circle`, `Rectangle` classes. Add necessary getters to `Circle` and `Rectangle`. Use `ArrayList<Shape>`. Iterate with enhanced for-loop. Use `instanceof` for type checking and downcasting. No user input.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Shape: Circle, Color: Red\nArea: 78.54\nIt's a Circle with radius: 5.0\n\nShape: Rectangle, Color: Blue\nArea: 50.00\nIt's a Rectangle with length: 10.0, width: 5.0\n\nShape: Circle, Color: Green\nArea: 28.27\nIt's a Circle with radius: 3.0\n",
    "explanation": "This problem reinforces polymorphism in collections, where a single `ArrayList` can hold objects of different concrete types (Circle, Rectangle) as long as they share a common supertype (`Shape`). The `instanceof` operator is used for **runtime type identification** and allows for **downcasting** (safely converting a superclass reference to a subclass reference). This enables you to access methods or fields specific to the actual type of the object, even when stored polymorphically. This is a powerful technique for handling diverse objects in a unified way while still being able to access their specific attributes."
  },
  {
    "topic": "Inheritance and Polymorphism",
    "level": "Tricky",
    "title": "Abstract Class with Constructor Chaining",
    "description": "This problem combines abstract classes with constructor chaining and demonstrates initializing inherited fields. Your task is to: \n1. Create an `abstract class ElectronicDevice`: \n    * `String brand`, `int yearManufactured`. \n    * Constructor `public ElectronicDevice(String brand, int yearManufactured)`. \n    * `public void powerOn()` method (concrete) that prints 'The [brand] device is powering on.'. \n    * `abstract public void performAction();` (abstract method). \n2. Create a `Smartphone` class that extends `ElectronicDevice`: \n    * `String operatingSystem`. \n    * Constructor `public Smartphone(String brand, int year, String os)`: Must call the superclass constructor. \n    * Implement `performAction()`: Prints 'Smartphone is making a call on ' + `operatingSystem`. \n    * Add `public void installApp(String appName)` method specific to `Smartphone`. \n3. Create a `Laptop` class that extends `ElectronicDevice`: \n    * `double screenSize`. \n    * Constructor `public Laptop(String brand, int year, double screenSize)`: Must call the superclass constructor. \n    * Implement `performAction()`: Prints 'Laptop is running a program on ' + `screenSize` + ' inch screen.'. \n4. In `main`: \n    * Create a `Smartphone` object and a `Laptop` object. \n    * Store them in an `ArrayList<ElectronicDevice>`. \n    * Iterate through the list. For each device, call `powerOn()` and `performAction()`. \n    * After the loop, explicitly call `installApp()` on the `Smartphone` object (requires casting or separate reference).",
    "constraints": "`ElectronicDevice` abstract, with constructor and abstract method. Subclasses must implement abstract method and call `super()` in their constructors. Use `ArrayList<ElectronicDevice>`. Demonstrate polymorphic calls. Demonstrate specific method call for `Smartphone` (requires casting or separate reference). No user input.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "The Samsung device is powering on.\nSmartphone is making a call on Android.\nThe Dell device is powering on.\nLaptop is running a program on 15.6 inch screen.\n\nInstalling app on Smartphone...\nSmartphone installing Spotify.\n",
    "explanation": "This problem deepens the understanding of abstract classes by requiring constructor chaining. The `Smartphone` and `Laptop` constructors must call `super()` to properly initialize the `brand` and `yearManufactured` fields inherited from `ElectronicDevice`. This pattern ensures that the common parts of the object's state are initialized by the superclass. The `performAction()` method, being abstract, forces each specific device type to define its unique 'action', while `powerOn()` provides common behavior. The explicit `installApp()` call after the loop shows that while polymorphism handles common behavior, specific type methods still require direct access or casting."
  },
  {
    "topic": "Inheritance and Polymorphism",
    "level": "Tricky",
    "title": "Hierarchical Inheritance and Method Resolution",
    "description": "This problem explores hierarchical inheritance (multiple classes inheriting from a single parent) and how method calls are resolved at runtime. Your task is to: \n1. Create a `Vehicle` class: \n    * `public void move()`: prints 'Vehicle is moving.'. \n2. Create a `Car` class that extends `Vehicle`: \n    * `public void move()`: prints 'Car drives on the road.'. (Overrides) \n    * `public void honk()`: prints 'Car honks!'. \n3. Create a `Truck` class that extends `Vehicle`: \n    * `public void move()`: prints 'Truck rumbles down the highway.'. (Overrides) \n    * `public void loadCargo()`: prints 'Truck is loading cargo.'. \n4. Create a `Motorcycle` class that extends `Vehicle`: \n    * `public void move()`: prints 'Motorcycle zips through traffic.'. (Overrides) \n    * `public void wheelie()`: prints 'Motorcycle performs a wheelie!'. \n5. In your `main` method: \n    * Create an `ArrayList<Vehicle>` (or array). \n    * Add one `Car`, one `Truck`, and one `Motorcycle` object to the list. \n    * Iterate through the `ArrayList`. For each `Vehicle` object, call `move()`. \n    * After the loop, try to call `honk()`, `loadCargo()`, and `wheelie()` on the specific objects (you'll need to use `instanceof` and casting).",
    "constraints": "`Car`, `Truck`, `Motorcycle` must all extend `Vehicle`. Each must override `move()`. Each must have a unique method. Use `ArrayList<Vehicle>`. Polymorphically call `move()`. Use `instanceof` and casting to call specific methods. No user input.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Car drives on the road.\nTruck rumbles down the highway.\nMotorcycle zips through traffic.\n\nDemonstrating specific actions:\nCar honks!\nTruck is loading cargo.\nMotorcycle performs a wheelie!\n",
    "explanation": "This problem showcases **hierarchical inheritance**, where multiple subclasses inherit from a single superclass. When `move()` is called on a `Vehicle` reference (e.g., `vehicle.move()`), the JVM determines the actual type of the object at runtime and executes the correct overridden method. This is **dynamic method dispatch** or **runtime polymorphism**. To call methods specific to the subclass (`honk`, `loadCargo`, `wheelie`), you must first check the object's type using `instanceof` and then safely **downcast** it to the appropriate subclass type. This demonstrates how to manage a hierarchy of objects and access their unique behaviors."
  },
  {
    "topic": "Inheritance and Polymorphism",
    "level": "Real World Problem",
    "title": "Payment Gateway Integration (Interface)",
    "description": "You are building a system that needs to integrate with different payment gateways. Your task is to: \n1. Create an `interface PaymentGateway`: \n    * `public boolean processPayment(double amount);` (returns true on success) \n    * `public String getGatewayName();` \n2. Create a `PayPalGateway` class that implements `PaymentGateway`: \n    * Implement `processPayment()`: simulates processing, always returns `true` if `amount > 0`, prints 'Processing $' + amount + ' via PayPal.'. \n    * Implement `getGatewayName()`: returns 'PayPal'. \n3. Create a `StripeGateway` class that implements `PaymentGateway`: \n    * Implement `processPayment()`: simulates processing, returns `true` if `amount < 1000`, prints 'Processing $' + amount + ' via Stripe.'. Returns `false` otherwise. \n    * Implement `getGatewayName()`: returns 'Stripe'. \n4. In your `main` method: \n    * Create an `ArrayList<PaymentGateway>` to hold different gateway implementations. \n    * Add a `PayPalGateway` and a `StripeGateway` object to the list. \n    * Iterate through the list. For each gateway: \n        * Print its name using `getGatewayName()`. \n        * Call `processPayment()` with a valid amount (e.g., 50.00). \n        * Call `processPayment()` with an amount that might fail (e.g., 1200.00). \n        * Print the result of each payment attempt.",
    "constraints": "`PaymentGateway` must be an interface. Both gateways must implement it. `processPayment` should return boolean indicating success. Use `ArrayList<PaymentGateway>`. Iterate and call methods polymorphically, demonstrating different outcomes. No user input.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Gateway: PayPal\nProcessing $50.00 via PayPal. Payment successful: true\nProcessing $1200.00 via PayPal. Payment successful: true\n\nGateway: Stripe\nProcessing $50.00 via Stripe. Payment successful: true\nProcessing $1200.00 via Stripe. Payment successful: false\n",
    "explanation": "This real-world problem uses an **interface** to define a common contract for different payment gateways. This is a classic example of **polymorphism** in action: the `PaymentGateway` interface acts as a common type, allowing you to treat `PayPalGateway` and `StripeGateway` objects uniformly. The application code can then interact with any payment gateway through the `PaymentGateway` interface, without needing to know the specific implementation details. This promotes flexibility, extensibility (easily add new gateways), and loose coupling in software design."
  },
  {
    "topic": "Inheritance and Polymorphism",
    "level": "Real World Problem",
    "title": "Employee Hierarchy with Salary Calculation",
    "description": "You are extending an employee management system to include different types of employees with distinct salary calculation methods. Your task is to: \n1. Create an `abstract class Employee`: \n    * `String name`, `String employeeId`. \n    * Constructor `public Employee(String name, String employeeId)`. \n    * `abstract public double calculateSalary();` \n    * `public void displayInfo()`: prints `name` and `employeeId`. \n2. Create a `Manager` class that extends `Employee`: \n    * `double baseSalary`, `double bonusPercentage`. \n    * Constructor `public Manager(name, id, baseSalary, bonusPercentage)`. \n    * Implement `calculateSalary()`: `baseSalary + (baseSalary * bonusPercentage / 100)`. \n3. Create a `Developer` class that extends `Employee`: \n    * `double hourlyRate`, `int hoursWorked`. \n    * Constructor `public Developer(name, id, hourlyRate, hoursWorked)`. \n    * Implement `calculateSalary()`: `hourlyRate * hoursWorked`. \n4. Create a `SalesPerson` class that extends `Employee`: \n    * `double baseSalary`, `double salesAmount`, `double commissionRate`. \n    * Constructor `public SalesPerson(name, id, baseSalary, salesAmount, commissionRate)`. \n    * Implement `calculateSalary()`: `baseSalary + (salesAmount * commissionRate / 100)`. \n5. In `main`: \n    * Create an `ArrayList<Employee> employees`. \n    * Add instances of `Manager`, `Developer`, and `SalesPerson` with different values. \n    * Iterate through the `employees` list. For each `Employee`: \n        * Call `displayInfo()`. \n        * Print their calculated salary using `calculateSalary()` (formatted to two decimal places).",
    "constraints": "`Employee` must be abstract with abstract `calculateSalary()`. All three concrete classes must extend `Employee` and implement `calculateSalary()` according to their specific logic. Use `ArrayList<Employee>`. Iterate and call `displayInfo()` and `calculateSalary()` polymorphically. No user input.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Employee: Alice (M001)\nSalary: $55000.00\n\nEmployee: Bob (D002)\nSalary: $8000.00\n\nEmployee: Charlie (S003)\nSalary: $40000.00\n",
    "explanation": "This problem demonstrates the powerful combination of **inheritance** and **polymorphism** in a real-world scenario. The `Employee` abstract class establishes a common interface (`calculateSalary()`, `displayInfo()`) for all employees, ensuring that every employee type will have these fundamental behaviors. Each subclass (`Manager`, `Developer`, `SalesPerson`) then provides its unique implementation of `calculateSalary()`, reflecting the different compensation structures. By storing all employees in an `ArrayList<Employee>`, you can process them uniformly through polymorphism, calling `calculateSalary()` without needing to know the specific type of employee at compile time. This is a robust and flexible design for extensible systems."
  }
]