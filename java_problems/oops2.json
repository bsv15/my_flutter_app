[
  {
    "topic": "Object-Oriented Programming (OOP) - General Concepts",
    "level": "Easy",
    "title": "Define Class, Object, Attributes, Methods",
    "description": "This problem introduces the core concepts of OOP: class, object, attributes, and methods. Your task is to: \n1. Create a `Bicycle` class. \n2. Define three instance variables (attributes): `String brand`, `int speed`, `int gear`. \n3. Create a constructor `public Bicycle(String brand, int speed, int gear)` to initialize these attributes. \n4. Add two methods (behaviors): \n    * `void speedUp(int increment)`: increases `speed` by `increment`. \n    * `void applyBrake(int decrement)`: decreases `speed` by `decrement` (ensure speed doesn't go below 0). \n5. Add a `void displayInfo()` method that prints the brand, current speed, and gear. \n6. In your `main` method: \n    * Create a `Bicycle` object. \n    * Call `speedUp()`, `applyBrake()`, and `displayInfo()` methods to demonstrate its functionality.",
    "constraints": "Class `Bicycle` with specified attributes and methods. `speedUp` and `applyBrake` modify speed. `displayInfo` prints all. Create object and call methods in `main`. No user input.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Bicycle Brand: Trek, Speed: 15, Gear: 2\nSpeeding up by 5...\nBicycle Brand: Trek, Speed: 20, Gear: 2\nApplying brake by 10...\nBicycle Brand: Trek, Speed: 10, Gear: 2\n",
    "explanation": "This is a foundational OOP problem. The `Bicycle` class is a **blueprint**. `new Bicycle(...)` creates an **object** (an instance) of that blueprint. `brand`, `speed`, `gear` are **attributes** (data) of the object. `speedUp`, `applyBrake`, `displayInfo` are **methods** (behaviors) that operate on the object's attributes. This demonstrates how objects encapsulate data and behavior."
  },
  {
    "topic": "Object-Oriented Programming (OOP) - General Concepts",
    "level": "Easy",
    "title": "Encapsulation with Getters and Setters",
    "description": "This problem focuses on **encapsulation** using `private` access modifiers and public `getter` and `setter` methods. Your task is to: \n1. Create a `BankAccount` class. \n2. Define a `private String accountNumber` and `private double balance` instance variables. \n3. Create a constructor `public BankAccount(String accountNumber, double initialBalance)` that initializes these fields. Include validation for `initialBalance`: it must be non-negative. If negative, set to 0.0 and print a warning. \n4. Implement `public String getAccountNumber()` (getter). \n5. Implement `public double getBalance()` (getter). \n6. Implement `public void deposit(double amount)`: adds `amount` to `balance`. Amount must be positive. \n7. Implement `public void withdraw(double amount)`: subtracts `amount` from `balance`. Amount must be positive and not exceed `balance`. \n8. In `main`: \n    * Create a `BankAccount` object. \n    * Demonstrate `deposit()` and `withdraw()` with valid and invalid amounts. \n    * Print `balance` after each operation using the getter.",
    "constraints": "`accountNumber` and `balance` must be `private`. Constructor must validate `initialBalance`. `deposit` and `withdraw` must validate `amount` and `balance`. Use getters to print. No user input.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Initial Balance: $1000.00\nDepositing $200.00...\nNew Balance: $1200.00\nWithdrawing $300.00...\nNew Balance: $900.00\nAttempting to withdraw $1000.00 (insufficient funds)...\nError: Insufficient funds or invalid amount for withdrawal. Current balance: $900.00\nNew Balance: $900.00\n",
    "explanation": "**Encapsulation** protects an object's internal state. By making `accountNumber` and `balance` `private`, direct access is prevented. Public `getters` provide controlled read access. Public `deposit` and `withdraw` methods act as `setters` (or mutators), providing controlled write access with built-in validation logic. This ensures data integrity and prevents invalid state changes, making the `BankAccount` object robust."
  },
  {
    "topic": "Object-Oriented Programming (OOP) - General Concepts",
    "level": "Medium",
    "title": "Static vs. Instance Members in a 'University' Class",
    "description": "This problem differentiates between `static` (class-level) and `instance` (object-level) members. Your task is to: \n1. Create a `University` class. \n2. Define `private String studentName`, `private String studentId` (instance variables). \n3. Define `public static String UNIVERSITY_NAME = \"Tech University\";` (a static constant). \n4. Define `private static int totalEnrollment = 0;` (a static variable). \n5. Create a constructor `public University(String studentName, String studentId)`: \n    * Initializes `studentName` and `studentId`. \n    * Increments `totalEnrollment`. \n6. Add a `public void displayStudentDetails()` method to print a student's name, ID, and the `UNIVERSITY_NAME`. \n7. Add a `public static int getTotalEnrollment()` method to return `totalEnrollment`. \n8. In your `main` method: \n    * Create two `University` objects. \n    * Call `displayStudentDetails()` on each object. \n    * Print the `totalEnrollment` using `University.getTotalEnrollment()`. \n    * Directly print `University.UNIVERSITY_NAME`.",
    "constraints": "Proper use of `static` and instance members. `totalEnrollment` updated in constructor. Static methods access static fields. Print all details as specified. No user input.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Student Name: John Doe, ID: S001, University: Tech University\nStudent Name: Jane Smith, ID: S002, University: Tech University\nTotal University Enrollment: 2\nUniversity Name (Direct Access): Tech University\n",
    "explanation": "Static members belong to the class itself, shared by all objects. `UNIVERSITY_NAME` is a constant available globally, and `totalEnrollment` keeps a cumulative count across all `University` objects. Instance members (`studentName`, `studentId`) are unique to each object. Static methods can only access static members (or other static methods). Instance methods can access both static and instance members."
  },
  {
    "topic": "Object-Oriented Programming (OOP) - General Concepts",
    "level": "Medium",
    "title": "Composition: 'Computer' and 'CPU'/'Monitor'",
    "description": "This problem demonstrates **composition**, where one object is composed of (has-a) other objects. Your task is to: \n1. Create a `CPU` class with `String manufacturer` and `String model`. Include a constructor and `displayCPUInfo()` method. \n2. Create a `Monitor` class with `String brand`, `double size`. Include a constructor and `displayMonitorInfo()` method. \n3. Create a `Computer` class. \n4. Inside `Computer`, define `private String computerName`, `private CPU processor`, and `private Monitor display`. \n5. Create a constructor `public Computer(String computerName, CPU processor, Monitor display)` that takes `CPU` and `Monitor` objects as parameters and initializes them. \n6. Add a `public void displayComputerInfo()` method that prints the `computerName` and then calls the `displayCPUInfo()` and `displayMonitorInfo()` methods of its contained `processor` and `display` objects. \n7. In `main`: \n    * Create `CPU` and `Monitor` objects. \n    * Create a `Computer` object, passing the `CPU` and `Monitor` objects to its constructor. \n    * Call `displayComputerInfo()` on the `Computer` object.",
    "constraints": "`CPU` and `Monitor` are separate classes. `Computer` must 'contain' instances of `CPU` and `Monitor`. `Computer`'s constructor takes `CPU` and `Monitor` objects. Display methods for each. No user input.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Computer Name: My Gaming PC\n--- CPU Info ---\nManufacturer: Intel, Model: i9-12900K\n--- Monitor Info ---\nBrand: Dell, Size: 27.0 inches\n",
    "explanation": "**Composition** (a 'has-a' relationship) is a strong form of association where one class contains instances of other classes. A `Computer` 'has a' `CPU` and 'has a' `Monitor`. This allows for building complex objects from simpler, reusable components, promoting modularity and maintainability. The `Computer` object is responsible for managing its contained `CPU` and `Monitor` objects."
  },
  {
    "topic": "Object-Oriented Programming (OOP) - General Concepts",
    "level": "Hard",
    "title": "Association: Student and Course Enrollment",
    "description": "This problem models a **many-to-many association** between `Student` and `Course` classes. Your task is to: \n1. Create a `Student` class with `String studentId`, `String name`. Add a constructor and `displayStudentInfo()` method. \n2. Create a `Course` class with `String courseId`, `String courseName`. Add a constructor and `displayCourseInfo()` method. \n3. Implement an `Enrollment` class (or directly within `Student`/`Course` if simpler). For this problem, let's keep it simple: `Student` will *know* about its `Course`s. \n4. In the `Student` class: \n    * Add an `ArrayList<Course> enrolledCourses;` instance variable. \n    * Modify the constructor to initialize `enrolledCourses` as an empty list. \n    * Add a `public void enrollInCourse(Course course)` method that adds a `Course` to `enrolledCourses` and prints a confirmation. \n    * Modify `displayStudentInfo()` to also list all `enrolledCourses` for that student. \n5. In `main`: \n    * Create several `Student` objects. \n    * Create several `Course` objects. \n    * Enroll students in various courses using the `enrollInCourse` method. \n    * Display details for each student to show their enrolled courses.",
    "constraints": "Separate `Student` and `Course` classes. `Student` must have an `ArrayList<Course>`. `enrollInCourse` adds to list and prints. `displayStudentInfo` lists courses. Create multiple students and courses, enroll them, and display. No user input.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Student ID: S001, Name: Alice\nEnrolled Courses:\n- Course ID: CS101, Name: Intro to Programming\n- Course ID: MA201, Name: Calculus I\n\nStudent ID: S002, Name: Bob\nEnrolled Courses:\n- Course ID: CS101, Name: Intro to Programming\n- Course ID: PH101, Name: Physics Basics\n",
    "explanation": "**Association** represents a relationship between two separate classes, where one class 'uses' or 'is related to' another. Here, `Student` and `Course` are associated. A `Student` object maintains a list (`ArrayList`) of `Course` objects they are enrolled in. This models a 'many-to-many' relationship because one student can take many courses, and one course can have many students. This problem demonstrates how objects can hold references to other objects in a collection, facilitating complex system modeling."
  },
  {
    "topic": "Object-Oriented Programming (OOP) - General Concepts",
    "level": "Tricky",
    "title": "Immutable 'Vector2D' Class",
    "description": "This problem introduces the concept of **immutability** in classes. An immutable object's state cannot be changed after it's created. Your task is to: \n1. Create an **immutable** `Vector2D` class. \n2. Define `private final double x` and `private final double y` instance variables. \n3. Create a constructor `public Vector2D(double x, double y)` that initializes both fields. \n4. Add public getter methods for `x` and `y`. There should be NO setter methods. \n5. Add a `public Vector2D add(Vector2D other)` method. Instead of modifying the current `Vector2D` object, this method should return a **new `Vector2D` object** representing the sum of `this` vector and `other`. \n6. Add a `public double magnitude()` method that returns the magnitude of the vector (`sqrt(x*x + y*y)`). \n7. Override the `toString()` method to return a string representation like `(x, y)`. \n8. In your `main` method: \n    * Create an `originalVector` object. \n    * Call the `add()` method and assign its result to a **new `Vector2D` reference**. \n    * Print both the original and the new `Vector2D` objects to demonstrate that the original object remains unchanged.",
    "constraints": "`Vector2D` class must be immutable (`private final` fields, no setters). `add()` must return a *new* `Vector2D` object. Implement `magnitude()` and `toString()`. In `main`, demonstrate immutability by showing original unchanged. No user input.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Original Vector: (3.0, 4.0)\nVector to Add: (1.0, 2.0)\nNew Vector after addition: (4.0, 6.0)\nOriginal Vector (still unchanged): (3.0, 4.0)\nMagnitude of Original: 5.0\n",
    "explanation": "An **immutable class** ensures that once an object is created, its internal state cannot be altered. This is achieved by: \n1. Declaring all instance variables as `private` and `final`. \n2. Providing no setter methods. \n3. If any method would 'modify' the object, it instead returns a *new* object with the desired changes. \nThis design choice promotes thread safety, simplifies reasoning about object state, and is good practice for value objects. The `add` method returning a new `Vector2D` is the core demonstration of this principle."
  },
  {
    "topic": "Object-Oriented Programming (OOP) - General Concepts",
    "level": "Tricky",
    "title": "Singleton Design Pattern for a Print Spooler",
    "description": "This problem implements the **Singleton design pattern**, ensuring that a class has only one instance and provides a global point of access to it. Your task is to: \n1. Create a `PrintSpooler` class. \n2. Make its constructor `private`: `private PrintSpooler()`. Inside the constructor, print 'PrintSpooler instance initialized.'. \n3. Add a `private static PrintSpooler instance;` field. \n4. Create a `public static PrintSpooler getInstance()` method: \n    * This method should implement the singleton logic: if `instance` is `null`, create a new `PrintSpooler` object and assign it to `instance`. \n    * Otherwise, return the existing `instance`. \n5. Add a `public void printJob(String documentName)` method that prints 'Printing: ' + `documentName` + ' (via unique spooler)'. \n6. In your `main` method: \n    * Get two `PrintSpooler` instances using `PrintSpooler.getInstance()`. \n    * Print whether the two instances are the same object (using `==`). \n    * Call `printJob()` on both instances to demonstrate they operate on the same object.",
    "constraints": "Constructor must be `private`. `instance` field must be `private static`. `getInstance()` must be `public static` and implement lazy initialization. `printJob` method. In `main`, get two instances, check equality, and call `printJob` on both. No user input.",
    "sampleInput": "None",
    "sampleOutput": "PrintSpooler instance initialized.\nAre both instances the same object? true\nPrinting: Report.pdf (via unique spooler)\nPrinting: Memo.docx (via unique spooler)\n",
    "explanation": "The **Singleton pattern** is a creational design pattern that restricts the instantiation of a class to one object. The `private` constructor prevents direct `new PrintSpooler()` calls. The `getInstance()` method is the sole access point, responsible for creating the object only once (lazy initialization) and returning the same instance on subsequent calls. This is 'tricky' because it's a common design pattern that modifies the standard object creation process, ensuring a single shared resource (like a print spooler or configuration manager) across an application."
  },
  {
    "topic": "Object-Oriented Programming (OOP) - General Concepts",
    "level": "Real World Problem",
    "title": "Online Shopping Cart with Item Management",
    "description": "You are building a simplified online shopping cart system. Your task is to: \n1. Create an `Item` class: \n    * `private String name`, `private double price`, `private int quantity`. \n    * Constructor, getters for all. \n    * `public double getTotalItemCost()` method (returns `price * quantity`). \n2. Create a `ShoppingCart` class: \n    * `private String cartId` \n    * `private ArrayList<Item> items` (to store `Item` objects). \n    * Constructor that takes `cartId` and initializes `items` `ArrayList`. \n    * `public void addItem(Item item)`: Adds an `Item` to the cart. If the item already exists by name, update its quantity and price (summing quantities and overwriting price, or finding and incrementing quantity for existing item). Print confirmation. \n    * `public void removeItem(String itemName)`: Removes an item by name. Print confirmation. \n    * `public double calculateTotalCost()`: Sums up `getTotalItemCost()` for all items. \n    * `public void displayCartContents()`: Prints `cartId`, and for each item: `name`, `price`, `quantity`, `totalItemCost`, then `totalOrderCost` at the end (all formatted). \n3. In your `main` method: \n    * Create a `ShoppingCart` object. \n    * Create several `Item` objects and add them to the cart, including one that is added twice (to test quantity update). \n    * Display cart contents. \n    * Remove one item. \n    * Display cart contents again.",
    "constraints": "Two classes (`Item`, `ShoppingCart`). `ShoppingCart` uses `ArrayList<Item>`. `addItem` must handle existing items (update quantity). `removeItem` by name. All calculation and display methods. Currency to two decimal places. No user input beyond hardcoded values.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Item added to cart: Laptop\nItem added to cart: Mouse\nUpdating quantity for existing item: Mouse. New quantity: 3\n\n--- Shopping Cart (ID: CART001) ---\n- Product: Laptop, Unit Price: $1200.00, Quantity: 1, Item Cost: $1200.00\n- Product: Mouse, Unit Price: $25.00, Quantity: 3, Item Cost: $75.00\nTotal Cart Cost: $1275.00\n\nRemoving item: Laptop...\nItem 'Laptop' removed from cart.\n\n--- Shopping Cart (ID: CART001) ---\n- Product: Mouse, Unit Price: $25.00, Quantity: 3, Item Cost: $75.00\nTotal Cart Cost: $75.00\n",
    "explanation": "This problem is a practical application of OOP concepts: \n* **Classes & Objects**: `Item` and `ShoppingCart` model real-world entities. \n* **Encapsulation**: Private fields with getters/setters protect data integrity. \n* **Composition**: `ShoppingCart` 'has-a' `ArrayList` of `Item` objects. \n* **Behavior**: Methods like `addItem`, `removeItem`, `calculateTotalCost` encapsulate the logic for managing the cart. \n* **List Management**: The `addItem` method's logic to update existing items (rather than adding duplicates) is a key real-world detail, requiring iteration through the list to check for existing items."
  }
]