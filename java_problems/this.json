[
  {
    "topic": "`this` Keyword",
    "level": "Easy",
    "title": "Distinguish Instance Variable from Parameter",
    "description": "This problem highlights the most common use of the `this` keyword: disambiguating between an instance variable and a local parameter with the same name. Your task is to: \n1. Create a class named `Product`. \n2. Define two instance variables: `String name` and `double price`. \n3. Create a constructor `public Product(String name, double price)`: \n    * Inside the constructor, use the `this` keyword to correctly assign the parameter values to the instance variables. \n    * For example: `this.name = name;` \n4. Add a `public void displayProduct()` method that prints the product's name and price. \n5. In your `main` method, create a `Product` object (e.g., \"Laptop\", 1200.50) and call `displayProduct()`.",
    "constraints": "Create `Product` class with `name` and `price`. Constructor must use `this` keyword to differentiate parameters from instance variables. Implement `displayProduct()`. Create one `Product` object in `main` and display it. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Product Name: Laptop\nProduct Price: $1200.50\n",
    "explanation": "When a local variable (like a method parameter) has the same name as an instance variable, the local variable 'shadows' the instance variable. The `this` keyword provides a way to explicitly refer to the **current object's** instance variable. So, `this.name` refers to the `name` field of the `Product` object being constructed, while `name` refers to the `name` parameter passed to the constructor. This is fundamental for correctly initializing object state in constructors."
  },
  {
    "topic": "`this` Keyword",
    "level": "Easy",
    "title": "Call Another Constructor (Constructor Chaining)",
    "description": "This problem directly demonstrates using `this()` for constructor chaining, a more organized way to initialize objects. Your task is to: \n1. Create a `Book` class. \n2. Define instance variables: `String title`, `String author`, `int year`. \n3. Create a constructor `public Book(String title, String author, int year)` that initializes all three fields. \n4. Create an overloaded constructor `public Book(String title, String author)`: \n    * This constructor should use `this()` to call the first constructor, setting `year` to `0` (or a default value like `1900`). \n    * Print 'Two-argument Book constructor called.' from this constructor. \n5. Add a `public void displayBookInfo()` method that prints all book details. \n6. In `main`: \n    * Create a `Book` object using the two-argument constructor. \n    * Create another `Book` object using the three-argument constructor. \n    * Display info for both books.",
    "constraints": "Create `Book` class with specified attributes. Implement a 3-arg constructor. Implement a 2-arg constructor that *must* use `this()` to call the 3-arg constructor with a default year. The 2-arg constructor must print a message. Implement `displayBookInfo()`. Create two `Book` objects, one with each constructor. Display details. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Two-argument Book constructor called.\nTitle: The Alchemist, Author: Paulo Coelho, Year: 1900\nTitle: Sapiens, Author: Yuval Noah Harari, Year: 2014\n",
    "explanation": "The `this()` keyword (with parentheses) is used *only* within a constructor to call another constructor of the **same class**. This is called **constructor chaining**. It must be the very first statement in the constructor. This is efficient because it prevents code duplication; common initialization logic can be put into one constructor, and other constructors can simply call it with default values for missing parameters. It's a common pattern for flexible object initialization."
  },
  {
    "topic": "`this` Keyword",
    "level": "Medium",
    "title": "Pass 'this' as an Argument to a Method",
    "description": "This problem demonstrates passing the `this` reference to another method, often used when an object needs to register itself or provide its own context. Your task is to: \n1. Create a class named `Processor`. \n2. Inside `Processor`, create a `public void process(Data data)` method. This method should take a `Data` object and print 'Processing data from: ' + `data.getName()`. \n3. Create a class named `Data`. \n4. Inside `Data`, define a `private String name` instance variable. \n5. Create a constructor `public Data(String name)` that initializes `name`. \n6. Add a `public String getName()` getter method. \n7. Add a `public void sendToProcessor(Processor processor)` method to the `Data` class. Inside this method, it should call `processor.process(this);`. \n8. In your `main` method: \n    * Create a `Processor` object. \n    * Create a `Data` object (e.g., \"Sensor Reading\"). \n    * Call `dataObject.sendToProcessor(processorObject)`. \n\n**Key Learning:** How `this` refers to the current object itself.",
    "constraints": "Create `Processor` and `Data` classes. `Processor` has `process(Data)`. `Data` has `name`, constructor, getter. `Data` has `sendToProcessor(Processor)` which calls `processor.process(this)`. Create objects and demonstrate the interaction in `main`. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Processing data from: Sensor Reading\n",
    "explanation": "When you use `this` as an argument to a method, you are passing a **reference to the current object** itself. In this case, `dataObject.sendToProcessor(processorObject)` causes `sendToProcessor` to execute. Inside `sendToProcessor`, `processor.process(this)` means the `processorObject` is told to `process` the `dataObject` that `this` refers to. This pattern is common in event handling, callbacks, or when an object needs to register itself with another component, providing itself as the context."
  },
  {
    "topic": "`this` Keyword",
    "level": "Medium",
    "title": "Return 'this' from a Method (Method Chaining)",
    "description": "This problem demonstrates returning `this` from a method, enabling **method chaining** (fluent API design). Your task is to: \n1. Create a `StringBuilderWrapper` class. \n2. Define a `private String content` instance variable. Initialize it to an empty string in the constructor. \n3. Create a constructor `public StringBuilderWrapper()`. \n4. Add a `public StringBuilderWrapper append(String text)` method: \n    * This method should append `text` to `content`. \n    * It should then **return `this`**. \n5. Add a `public StringBuilderWrapper toUpperCase()` method: \n    * This method should convert `content` to uppercase. \n    * It should then **return `this`**. \n6. Add a `public String toString()` method that returns `content`. \n7. In your `main` method: \n    * Create a `StringBuilderWrapper` object. \n    * Perform a sequence of operations using method chaining: `wrapper.append(\"hello\").toUpperCase().append(\" world\");` \n    * Print the final `wrapper` object.",
    "constraints": "Create `StringBuilderWrapper` class. `content` private. Constructor initializes `content`. `append()` and `toUpperCase()` methods must return `this`. Override `toString()`. Demonstrate method chaining in `main`. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "HELLO world\n",
    "explanation": "When a method returns `this`, it returns a reference to the **current object**. This allows you to call another method on the *same object* immediately after the first one, leading to **method chaining** (also known as a fluent API). This makes code more concise and readable, especially when performing multiple operations on an object. The `StringBuilder` class in Java famously uses this pattern. This problem illustrates how to design methods for such a fluent interface."
  },
  {
    "topic": "`this` Keyword",
    "level": "Hard",
    "title": "Builder Pattern with 'this' for Object Construction",
    "description": "This problem introduces the **Builder design pattern**, which uses method chaining and the `this` keyword to construct complex objects step-by-step. Your task is to: \n1. Create a `Pizza` class. \n2. Define `private final` instance variables: `String size`, `boolean cheese`, `boolean pepperoni`, `boolean mushrooms`. \n3. Make the `Pizza` constructor `private`: `private Pizza(Builder builder)`. This constructor will take a `Builder` object and initialize `Pizza`'s fields from the `Builder`'s fields (e.g., `this.size = builder.size;`). \n4. Create a **nested static class** `public static class Builder` inside `Pizza`. \n5. Inside `Builder`, define instance variables corresponding to `Pizza`'s fields (e.g., `String size`, `boolean cheese`). \n6. Inside `Builder`, create a constructor `public Builder(String size)` that initializes `size`. \n7. Inside `Builder`, create methods for each optional topping: \n    * `public Builder withCheese(boolean hasCheese)`: sets `this.cheese = hasCheese;` and returns `this`. \n    * `public Builder withPepperoni(boolean hasPepperoni)`: sets `this.pepperoni = hasPepperoni;` and returns `this`. \n    * `public Builder withMushrooms(boolean hasMushrooms)`: sets `this.mushrooms = hasMushrooms;` and returns `this`. \n8. Inside `Builder`, create a `public Pizza build()` method. This method should return `new Pizza(this);`. \n9. Add a `public String toString()` method to `Pizza` to display its details. \n10. In `main`: \n    * Construct a `Pizza` object using the Builder pattern (e.g., `new Pizza.Builder(\"Large\").withCheese(true).withPepperoni(true).build();`). \n    * Print the created `Pizza` object.",
    "constraints": "Create `Pizza` class with private final fields and a private constructor taking a `Builder`. Create a nested `public static class Builder` with corresponding fields, a constructor for `size`, and fluent methods (returning `this`) for optional toppings. `Builder` must have a `build()` method returning `new Pizza(this)`. Override `Pizza.toString()`. Demonstrate building a `Pizza` in `main` using method chaining. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Your Pizza: Size: Large, Cheese: true, Pepperoni: true, Mushrooms: false\n",
    "explanation": "The **Builder pattern** is a creational pattern designed for objects with many optional parameters, making constructors cumbersome. It uses a separate `Builder` class (often nested) to construct the main object. Key roles of `this`: \n* In `Builder`'s `withX()` methods, `return this;` enables method chaining. \n* In `Pizza`'s `private` constructor, `new Pizza(this);` passes the fully configured `Builder` object to `Pizza` to initialize its `final` fields. \nThis pattern significantly improves readability and maintainability when constructing complex objects, as it separates the construction logic from the object's representation."
  },
  {
    "topic": "`this` Keyword",
    "level": "Tricky",
    "title": "Reference to 'this' in Inner Class (Shadowing)",
    "description": "This problem explores how `this` behaves within **nested (inner) classes**, especially when there's potential for shadowing. Your task is to: \n1. Create an outer class named `OuterClass`. \n2. Inside `OuterClass`, define a `private String name = \"Outer\";`. \n3. Add a `public void displayOuterName()` method in `OuterClass` that prints `this.name`. \n4. Create a **non-static inner class** named `InnerClass` inside `OuterClass`. \n5. Inside `InnerClass`, define a `private String name = \"Inner\";`. \n6. Inside `InnerClass`, add a `public void displayNames()` method: \n    * Print the `name` of the `InnerClass` instance (e.g., `this.name`). \n    * Print the `name` of the `OuterClass` instance that contains this `InnerClass` instance (e.g., `OuterClass.this.name`). \n7. In your `main` method: \n    * Create an `OuterClass` object. \n    * Using the `OuterClass` object, create an `InnerClass` object. \n    * Call `displayNames()` on the `InnerClass` object.",
    "constraints": "Create `OuterClass` with a `name` field and `displayOuterName()` method. Create a non-static `InnerClass` inside `OuterClass` with its own `name` field. `InnerClass.displayNames()` must print both its own `name` (`this.name`) and the `OuterClass`'s `name` (`OuterClass.this.name`). Demonstrate creation and calls in `main`. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Inner Class Name: Inner\nOuter Class Name from Inner: Outer\n",
    "explanation": "This problem showcases the specific syntax `OuterClass.this` to access the `this` reference of the **enclosing outer class** from within an inner class. When an instance variable in an inner class has the same name as one in its outer class, the inner class variable `shadows` the outer one. `this.name` inside `InnerClass` refers to `InnerClass`'s `name`. To access the outer class's `name`, you must explicitly qualify `this` with the outer class's name (`OuterClass.this.name`). This is a critical distinction when working with nested classes and understanding variable scope."
  },
  {
    "topic": "`this` Keyword",
    "level": "Real World Problem",
    "title": "Event Handling: 'Button' and 'ClickListener'",
    "description": "This problem simulates a simplified event handling mechanism where a 'Button' object notifies a 'ClickListener' object about a click, showcasing how `this` is used to pass the event source. Your task is to: \n1. Create an interface named `ClickListener`. \n    * Define a `public void onClick(Button button)` method. \n2. Create a `Button` class. \n3. Define a `private String label` instance variable. \n4. Add a constructor `public Button(String label)` that initializes `label`. \n5. Add a `private ClickListener listener;` field. \n6. Add a `public void setClickListener(ClickListener listener)` method to register a listener. \n7. Add a `public void performClick()` method: \n    * This method simulates a click. If a `listener` is registered (not `null`), it should call `listener.onClick(this);`. \n    * Print 'Button \"[label]\" clicked.' when `performClick` is called. \n8. In your `main` method: \n    * Create a `Button` object (e.g., \"Submit Button\"). \n    * Create an **anonymous inner class** that implements `ClickListener`. \n    * In the `onClick` method of this anonymous class, print 'Clicked button: ' + `button.getLabel()`. \n    * Set this anonymous listener on the button using `setClickListener()`. \n    * Call `performClick()` on the button.",
    "constraints": "Create `ClickListener` interface with `onClick(Button)`. Create `Button` class with `label`, constructor, `setClickListener()`, and `performClick()`. `performClick()` must call `listener.onClick(this)` if listener is not null. In `main`, create `Button`, create and set an anonymous `ClickListener` implementation, then call `performClick()`. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Button \"Submit Button\" clicked.\nClicked button: Submit Button\n",
    "explanation": "This problem demonstrates a common pattern in GUI programming and event handling. The `Button` acts as an event source. When `performClick()` is called, it notifies its registered `ClickListener`. The `listener.onClick(this);` line is crucial: `this` inside `performClick()` refers to the `Button` object itself. This allows the `onClick` method in the listener to receive a reference to the specific `Button` that was clicked, enabling it to query the button for its properties (like its label). This is a practical example of how `this` enables communication between objects in a decoupled way."
  }
]