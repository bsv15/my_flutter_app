[
  {
    "topic": "Object-Oriented Programming (OOP) - Classes and Objects",
    "level": "Easy",
    "title": "Create a Basic 'Car' Class and Object",
    "description": "This problem introduces the fundamental concepts of creating a class, defining attributes (fields), and instantiating an object. Your task is to: \n1. Create a Java class named `Car`. \n2. Inside the `Car` class, define two instance variables (attributes): \n    * `String brand` \n    * `String model` \n3. In your `main` method (in a separate class or the same file, e.g., `Main.java`): \n    * Create an object (instance) of the `Car` class. \n    * Assign values to its `brand` and `model` attributes (e.g., \"Toyota\" and \"Camry\"). \n    * Print the `brand` and `model` of the created car object.",
    "constraints": "Create a class `Car` with `String brand` and `String model`. Create a `Car` object in `main`. Assign values to its attributes. Print the attributes. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Car Brand: Toyota\nCar Model: Camry\n",
    "explanation": "This problem demonstrates the blueprint-like nature of a **class** (`Car`) and the concrete instance (the actual car) that's an **object**. `new Car()` creates the object, allocating memory for its `brand` and `model` fields. The dot operator (`.`) is used to access and assign values to these fields (e.g., `myCar.brand = \"Toyota\";`). This is the very first step in understanding OOP: defining data structures."
  },
  {
    "topic": "Object-Oriented Programming (OOP) - Classes and Objects",
    "level": "Easy",
    "title": "Add Methods to 'Dog' Class (Bark and Sleep)",
    "description": "This problem extends the concept of objects to include **methods** (behaviors). Your task is to: \n1. Create a Java class named `Dog`. \n2. Inside the `Dog` class, define one instance variable: `String name`. \n3. Add two `public void` methods to the `Dog` class: \n    * `bark()`: This method should print '[DogName] says Woof!'. (Use the `name` instance variable). \n    * `sleep()`: This method should print '[DogName] is now sleeping... Zzz.'. \n4. In your `main` method: \n    * Create a `Dog` object and give it a `name` (e.g., \"Buddy\"). \n    * Call both the `bark()` and `sleep()` methods on your `Dog` object.",
    "constraints": "Create a class `Dog` with `String name`. Add two `public void` methods `bark()` and `sleep()`. Call these methods on a `Dog` object in `main`. Print messages using the `name` variable. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Buddy says Woof!\nBuddy is now sleeping... Zzz.\n",
    "explanation": "Here, the `Dog` class not only holds data (`name`) but also defines actions (`bark()` and `sleep()`) that a `Dog` object can perform. These are called **methods**. When `myDog.bark()` is called, the `bark()` method specific to the `myDog` object is executed. Methods encapsulate behavior, making objects more active entities. The `name` variable within the methods refers to the name of the *current* `Dog` object."
  },
  {
    "topic": "Object-Oriented Programming (OOP) - Classes and Objects",
    "level": "Easy",
    "title": "Use a Constructor in 'Book' Class",
    "description": "This problem introduces **constructors**, special methods used to initialize objects when they are created. Your task is to: \n1. Create a Java class named `Book`. \n2. Inside the `Book` class, define three instance variables: \n    * `String title` \n    * `String author` \n    * `int publicationYear` \n3. Create a **constructor** for the `Book` class that takes `title`, `author`, and `publicationYear` as parameters and initializes the instance variables. \n4. Add a `public void` method `displayBookInfo()` to the `Book` class that prints all book details. \n5. In your `main` method: \n    * Create two `Book` objects using the constructor, providing different book details. \n    * Call `displayBookInfo()` for each `Book` object.",
    "constraints": "Create a `Book` class with the specified attributes. Create a constructor that initializes all attributes. Add a `displayBookInfo` method. Create two `Book` objects using the constructor. Call `displayBookInfo` for both objects. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Book Title: The Hobbit\nAuthor: J.R.R. Tolkien\nPublication Year: 1937\n\nBook Title: 1984\nAuthor: George Orwell\nPublication Year: 1949\n",
    "explanation": "A **constructor** has the same name as the class and no return type. It's automatically called when you create a new object using `new Book(...)`. This allows you to initialize an object's state right at creation, ensuring it's in a valid and ready-to-use condition. The `this` keyword inside the constructor (`this.title = title;`) distinguishes between the instance variable (`this.title`) and the constructor parameter (`title`)."
  },
  {
    "topic": "Object-Oriented Programming (OOP) - Classes and Objects",
    "level": "Easy",
    "title": "Encapsulation: Getters and Setters for 'BankAccount'",
    "description": "This problem introduces the core OOP principle of **encapsulation** using **getters** and **setters**. Your task is to: \n1. Create a Java class named `BankAccount`. \n2. Inside the `BankAccount` class, define a `private` instance variable: \n    * `double balance` \n3. Create a constructor that takes an initial `balance` and initializes the private variable. \n4. Add a `public double getBalance()` method (getter) to retrieve the `balance`. \n5. Add a `public void setBalance(double newBalance)` method (setter) to update the `balance`. Inside the setter, add a basic validation: only update if `newBalance` is non-negative. If negative, print an error. \n6. In your `main` method: \n    * Create a `BankAccount` object with an initial balance. \n    * Use the setter to try and update the balance (once with a valid amount, once with a negative amount). \n    * Use the getter to print the balance after each operation.",
    "constraints": "Create a `BankAccount` class. `balance` must be `private`. Implement a constructor, `getBalance()` (getter), and `setBalance()` (setter). The setter must include validation for non-negative `newBalance`. Call these methods in `main` and observe output. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Initial Balance: $1000.00\nSetting balance to 1200.50...\nNew Balance: $1200.50\nSetting balance to -50.00...\nError: Balance cannot be negative. Balance remains: $1200.50\n",
    "explanation": "**Encapsulation** means bundling data (attributes) and methods (behaviors) that operate on the data within a single unit (a class) and restricting direct access to some of the component's internals. Making `balance` `private` prevents direct manipulation from outside the class. **Getters** (`getBalance()`) provide controlled read access, and **setters** (`setBalance()`) provide controlled write access, allowing for validation or other logic before the data is changed. This protects the integrity of the object's state."
  },
  {
    "topic": "Object-Oriented Programming (OOP) - Classes and Objects",
    "level": "Medium",
    "title": "Student Class with Grade Calculation",
    "description": "This problem combines attributes, a constructor, and a method for calculation within a class. Your task is to: \n1. Create a `Student` class. \n2. Define instance variables: \n    * `String name` \n    * `int[] grades` (an array to store multiple grades) \n3. Create a constructor that takes `name` and an `int[]` of `grades` as parameters and initializes them. \n4. Add a `public double calculateAverageGrade()` method that calculates and returns the average of the grades in the `grades` array. \n5. Add a `public void displayStudentInfo()` method that prints the student's name and their calculated average grade (formatted to two decimal places). \n6. In your `main` method: \n    * Create two `Student` objects with different names and arrays of grades. \n    * Call `displayStudentInfo()` for both students.",
    "constraints": "Create a `Student` class. Use specified attributes. Implement a constructor. Implement `calculateAverageGrade()` returning `double`. Implement `displayStudentInfo()` printing name and formatted average. Create two `Student` objects in `main`. Call `displayStudentInfo` on both. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Student Name: Alice\nAverage Grade: 88.50\n\nStudent Name: Bob\nAverage Grade: 75.83\n",
    "explanation": "This problem demonstrates how objects can hold more complex data (like an array of grades) and perform calculations based on that data. The `calculateAverageGrade()` method encapsulates the logic for averaging, making the `Student` class responsible for its own data processing. Passing an array to the constructor allows a single student object to be initialized with all their relevant grades, promoting a cohesive data structure."
  },
  {
    "topic": "Object-Oriented Programming (OOP) - Classes and Objects",
    "level": "Medium",
    "title": "Representing Geometric Shapes: Rectangle Class",
    "description": "This problem models a real-world entity using a class, including methods for calculating properties. Your task is to: \n1. Create a `Rectangle` class. \n2. Define `private` instance variables: \n    * `double length` \n    * `double width` \n3. Create a constructor that takes `length` and `width` and initializes these variables. Include validation in the constructor: if `length` or `width` are negative or zero, set them to `1.0` and print a warning. \n4. Add public getter methods for `length` and `width`. \n5. Add a `public double calculateArea()` method. \n6. Add a `public double calculatePerimeter()` method. \n7. In your `main` method: \n    * Create a `Rectangle` object with valid dimensions. \n    * Create another `Rectangle` object with invalid dimensions to test validation. \n    * For both rectangles, print their length, width, area, and perimeter (formatted to two decimal places).",
    "constraints": "Create `Rectangle` class. `length` and `width` must be `private`. Constructor must validate dimensions (set to 1.0 if invalid). Implement getters, `calculateArea()`, `calculatePerimeter()`. Create two `Rectangle` objects in `main`, one valid, one invalid. Print details for both. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Rectangle 1:\nLength: 5.00, Width: 10.00\nArea: 50.00\nPerimeter: 30.00\n\nRectangle 2 (Invalid Dimensions Test):\nWarning: Length and/or width cannot be negative or zero. Setting to 1.0.\nLength: 1.00, Width: 1.00\nArea: 1.00\nPerimeter: 4.00\n",
    "explanation": "This problem emphasizes `private` attributes for encapsulation and robust constructors with validation. The `Rectangle` class models a real-world concept. Methods like `calculateArea()` and `calculatePerimeter()` define the behaviors associated with a `Rectangle` object. The constructor's validation logic ensures that a `Rectangle` object is always created in a consistent and valid state, even if invalid inputs are provided, which is crucial for reliable software."
  },
  {
    "topic": "Object-Oriented Programming (OOP) - Classes and Objects",
    "level": "Medium",
    "title": "Static Members: 'Calculator' Utility Class",
    "description": "This problem introduces **static members** (variables and methods) that belong to the class itself, not to individual objects. Your task is to: \n1. Create a `Calculator` class. \n2. Add a `public static int` method `add(int a, int b)` that returns the sum of `a` and `b`. \n3. Add a `public static int` method `subtract(int a, int b)` that returns the difference. \n4. Add a `public static double` method `multiply(double a, double b)` that returns the product. \n5. Add a `public static double` method `divide(double a, double b)` that returns the quotient. Include a check for division by zero: if `b` is 0, print an error message and return `Double.NaN` (Not a Number). \n6. Add a `public static final double` constant `PI = 3.14159;`. \n7. In your `main` method, perform several calculations using the `Calculator`'s static methods and print `Calculator.PI`. You should call these methods directly on the class name (e.g., `Calculator.add(5, 3)`), not on an object.",
    "constraints": "Create a `Calculator` class. All methods and `PI` constant must be `public static`. `divide` method must handle division by zero and return `Double.NaN`. Call methods directly on the `Calculator` class in `main`. Print results. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "5 + 3 = 8\n10 - 4 = 6\n7.5 * 2.0 = 15.0\n10.0 / 2.5 = 4.0\n10.0 / 0.0 = Error: Cannot divide by zero.\nResult: NaN\nValue of PI: 3.14159\n",
    "explanation": "**Static members** belong to the class itself, not to any specific object of that class. You don't need to create an object of `Calculator` to use `add()` or `PI`; you access them directly using the class name (`Calculator.add()`, `Calculator.PI`). This is ideal for utility classes or constants that don't need object-specific state. `final` makes `PI` a constant, meaning its value cannot be changed after initialization. This demonstrates a key aspect of class design for reusable utilities."
  },
  {
    "topic": "Object-Oriented Programming (OOP) - Classes and Objects",
    "level": "Hard",
    "title": "Employee Management System with Salary Calculation",
    "description": "This problem involves creating a class to represent employees, managing their data, and performing calculations based on their attributes, including bonuses. Your task is to: \n1. Create an `Employee` class. \n2. Define `private` instance variables: \n    * `String employeeId` \n    * `String name` \n    * `double baseSalary` \n    * `int yearsOfExperience` \n3. Create a constructor that initializes all these variables. \n4. Add public getter methods for all attributes. \n5. Add a `public void setBaseSalary(double baseSalary)` setter method with validation: `baseSalary` must be positive. \n6. Add a `public double calculateBonus()` method. The bonus calculation is as follows: \n    * 5% of `baseSalary` for 0-2 years experience. \n    * 10% of `baseSalary` for 3-5 years experience. \n    * 15% of `baseSalary` for 6+ years experience. \n7. Add a `public double calculateTotalSalary()` method that returns `baseSalary + calculateBonus()`. \n8. Add a `public void displayEmployeeDetails()` method to print all relevant employee information (ID, Name, Base Salary, Bonus, Total Salary), formatted to two decimal places. \n9. In `main`: \n    * Create at least three `Employee` objects with varied experience levels. \n    * Call `displayEmployeeDetails()` for each employee.",
    "constraints": "Create `Employee` class with specified private attributes. Constructor must initialize all. Getters for all. Setter for `baseSalary` with positive validation. `calculateBonus()` and `calculateTotalSalary()` must implement specified logic. `displayEmployeeDetails()` must print all formatted info. Create at least 3 `Employee` objects and display their details in `main`. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Employee ID: E001\nName: John Doe\nBase Salary: $50000.00\nBonus (5%): $2500.00\nTotal Salary: $52500.00\n\nEmployee ID: E002\nName: Jane Smith\nBase Salary: $65000.00\nBonus (10%): $6500.00\nTotal Salary: $71500.00\n\nEmployee ID: E003\nName: Peter Jones\nBase Salary: $80000.00\nBonus (15%): $12000.00\nTotal Salary: $92000.00\n",
    "explanation": "This problem simulates a common business scenario: managing employee data. It solidifies encapsulation by making attributes private and providing controlled access via getters/setters. The `calculateBonus()` method demonstrates conditional logic within a class's behavior, and `calculateTotalSalary()` shows how methods can build upon each other. This is a practical application of OOP, where objects represent real-world entities with their own data and behaviors."
  },
  {
    "topic": "Object-Oriented Programming (OOP) - Classes and Objects",
    "level": "Hard",
    "title": "Shopping Cart System (Item Class and Cart Logic)",
    "description": "This problem combines object creation with array (or `ArrayList`, if comfortable) manipulation to simulate a simple shopping cart. Your task is to: \n1. Create an `Item` class. \n2. Define `private` instance variables: \n    * `String name` \n    * `double price` \n    * `int quantity` \n3. Create a constructor that initializes these variables. \n4. Add public getter methods for all attributes. \n5. In your `main` method: \n    * Create an array (or `ArrayList`) of `Item` objects to represent the `shoppingCart`. \n    * Populate the `shoppingCart` with at least three different `Item` objects (e.g., \"Laptop\", 1200.00, 1; \"Mouse\", 25.00, 2; \"Keyboard\", 75.00, 1). \n    * Iterate through the `shoppingCart` to print details of each item (Name, Price, Quantity). \n    * Calculate and print the `total cost` of all items in the cart (sum of `price * quantity` for each item), formatted to two decimal places.",
    "constraints": "Create an `Item` class with specified private attributes, constructor, and getters. In `main`, create an array/`ArrayList` of `Item` objects. Populate with at least 3 items. Iterate and print each item's details. Calculate and print total cost. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Shopping Cart Items:\n- Laptop (Quantity: 1) - $1200.00\n- Mouse (Quantity: 2) - $25.00\n- Keyboard (Quantity: 1) - $75.00\n\nTotal Cost of Cart: $1325.00\n",
    "explanation": "This problem models a fundamental e-commerce concept: a shopping cart. The `Item` class defines what an item is. The `shoppingCart` (an array of `Item` objects) demonstrates how collections can hold objects, not just primitive data. Iterating through the cart allows for processing each `Item` object to display its details and contribute to the total cost. This is a practical example of how classes and objects are used to structure complex data in real-world applications."
  },
  {
    "topic": "Object-Oriented Programming (OOP) - Classes and Objects",
    "level": "Hard",
    "title": "Library Book Management (Class with Status)",
    "description": "You're building a system for a small library to track books. Your task is to: \n1. Create a `Book` class. \n2. Define `private` instance variables: \n    * `String title` \n    * `String author` \n    * `String isbn` \n    * `boolean isBorrowed` (default to `false` in constructor) \n3. Create a constructor that initializes `title`, `author`, and `isbn`. \n4. Add public getter methods for all attributes. \n5. Add a `public void borrowBook()` method: \n    * If `isBorrowed` is `false`, set it to `true` and print '\"[BookTitle]\" has been borrowed.'. \n    * If already `true`, print '\"[BookTitle]\" is already borrowed.'. \n6. Add a `public void returnBook()` method: \n    * If `isBorrowed` is `true`, set it to `false` and print '\"[BookTitle]\" has been returned.'. \n    * If already `false`, print '\"[BookTitle]\" is already available.'. \n7. Add a `public void displayStatus()` method that prints '\"[BookTitle]\" by [Author]. Status: [Available/Borrowed]'. \n8. In your `main` method: \n    * Create at least two `Book` objects. \n    * Demonstrate borrowing one book, then trying to borrow it again. \n    * Demonstrate returning the other book, then trying to return it again. \n    * Call `displayStatus()` after each operation to show changes.",
    "constraints": "Create `Book` class with specified private attributes, constructor, and getters. Implement `borrowBook()`, `returnBook()`, `displayStatus()` methods with specified logic and output. Create at least 2 `Book` objects in `main`. Demonstrate operations and print status after each. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Initial Status:\n\"The Great Gatsby\" by F. Scott Fitzgerald. Status: Available\n\"To Kill a Mockingbird\" by Harper Lee. Status: Available\n\nAttempting to borrow The Great Gatsby...\n\"The Great Gatsby\" has been borrowed.\n\"The Great Gatsby\" by F. Scott Fitzgerald. Status: Borrowed\n\nAttempting to borrow The Great Gatsby again...\n\"The Great Gatsby\" is already borrowed.\n\"The Great Gatsby\" by F. Scott Fitzgerald. Status: Borrowed\n\nAttempting to return To Kill a Mockingbird (already available)...\n\"To Kill a Mockingbird\" is already available.\n\"To Kill a Mockingbird\" by Harper Lee. Status: Available\n\n",
    "explanation": "This problem models a state-based system (`isBorrowed` attribute). The `borrowBook()` and `returnBook()` methods not only change the `isBorrowed` state but also contain conditional logic to handle invalid state transitions (e.g., trying to borrow an already borrowed book). This emphasizes how methods can encapsulate behavior, manage internal state, and provide meaningful feedback. It's a common pattern in systems where objects have lifecycles or distinct states."
  },
  {
    "topic": "Object-Oriented Programming (OOP) - Classes and Objects",
    "level": "Tricky",
    "title": "Immutable 'Point' Class",
    "description": "This problem introduces the concept of **immutability** in classes. An immutable object's state cannot be changed after it's created. Your task is to: \n1. Create a `Point` class. \n2. Define `private final` instance variables: \n    * `int x` \n    * `int y` \n3. Create a constructor that initializes `x` and `y`. \n4. Add `public` getter methods for `x` and `y`. There should be NO setter methods. \n5. Add a `public Point move(int dx, int dy)` method. Instead of modifying the current `Point` object, this method should return a **new `Point` object** representing the new coordinates (`x + dx`, `y + dy`). \n6. Override the `toString()` method to return a string representation like `(x, y)`. \n7. In your `main` method: \n    * Create an initial `Point` object. \n    * Call the `move()` method and assign its result to a **new `Point` reference**. \n    * Print both the original and the new `Point` objects to demonstrate that the original object remains unchanged.",
    "constraints": "`Point` class must have `private final` `x` and `y`. No setters. `move()` must return a `new Point` object, not modify `this`. Override `toString()`. In `main`, create original and new `Point` objects after `move()` call, print both. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Original Point: (5, 10)\nMoved by (3, -2):\nNew Point: (8, 8)\nOriginal Point (still unchanged): (5, 10)\n",
    "explanation": "An **immutable class** has `final` instance variables (initialized only in the constructor) and no setter methods. Any operation that seemingly 'modifies' the object (like `move()`) actually returns a *new* object with the updated state. This design choice has benefits like thread safety and easier reasoning about program state. This problem challenges the common mutable object pattern by forcing the creation of new objects for state changes, showcasing a powerful design principle."
  },
  {
    "topic": "Object-Oriented Programming (OOP) - Classes and Objects",
    "level": "Tricky",
    "title": "Static Initialization Block and Class Loading",
    "description": "This problem explores how **static initialization blocks** work and when they are executed during class loading. Your task is to: \n1. Create a `public class StaticExample`. \n2. Inside `StaticExample`, define a `public static int` variable `staticCounter = 0;`. \n3. Add a `static {}` (static initialization) block. Inside this block, increment `staticCounter` and print 'Static initialization block executed.'. \n4. Add a constructor `public StaticExample()` for the class. Inside the constructor, increment `staticCounter` and print 'Constructor executed.'. \n5. In your `main` method: \n    * Print the initial value of `staticCounter`. \n    * Create two `StaticExample` objects. \n    * Print the value of `staticCounter` again after creating objects. \n\n**Key Learning:** Observe when the static block runs versus the constructor.",
    "constraints": "Create `StaticExample` class with `staticCounter`. Implement a static block that increments `staticCounter` and prints. Implement a constructor that increments `staticCounter` and prints. In `main`, print `staticCounter` before creating objects, create two objects, then print `staticCounter` again. No user input required.",
    "sampleInput": "None",
    "sampleOutput": "Initial staticCounter in main: 0\nStatic initialization block executed.\nConstructor executed.\nConstructor executed.\nStaticCounter after creating objects: 2\n",
    "explanation": "This problem highlights the execution order of static blocks and constructors. A **static initialization block** (`static {}`) is executed **only once** when the class is first loaded into the Java Virtual Machine (JVM), before any objects of that class are created or any static members are accessed. Constructors, on the other hand, are executed **every time** a new object of the class is instantiated. This demonstrates how `staticCounter` is affected by class loading vs. object creation, which is crucial for understanding class lifecycle and shared resources."
  },
  {
    "topic": "Object-Oriented Programming (OOP) - Classes and Objects",
    "level": "Real World Problem",
    "title": "Customer Relationship Management (CRM) - Customer Class",
    "description": "You're building a basic CRM system. Your task is to: \n1. Create a `Customer` class. \n2. Define `private` instance variables: \n    * `String customerId` (e.g., 'CUST001') \n    * `String name` \n    * `String email` \n    * `String phoneNumber` \n3. Create a constructor that takes all attributes as parameters and initializes them. \n4. Add public getter methods for all attributes. \n5. Add `public void updateContactInfo(String newEmail, String newPhoneNumber)` method that updates both `email` and `phoneNumber` and prints a confirmation message. \n6. Add a `public void displayCustomerDetails()` method to print all customer information. \n7. In `main`: \n    * Create an `ArrayList` to hold `Customer` objects. \n    * Add at least three `Customer` objects to the `ArrayList`. \n    * Iterate through the `ArrayList` and call `displayCustomerDetails()` for each customer. \n    * Choose one customer and call `updateContactInfo()` to change their email and phone. \n    * Call `displayCustomerDetails()` for that updated customer to show the change.",
    "constraints": "Create `Customer` class with specified private attributes, constructor, and getters. Implement `updateContactInfo()` and `displayCustomerDetails()` methods. In `main`, use `ArrayList<Customer>`. Add at least 3 customers. Loop to display all. Update one customer's info and display again. No user input required for specific customer details, but you can hardcode. Close `Scanner` if using for some part of the problem. (This problem focuses on objects and collections, not user input on all details).",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "--- Initial Customer List ---\nCustomer ID: CUST001\nName: Alice Wonderland\nEmail: alice@example.com\nPhone: 111-222-3333\n\nCustomer ID: CUST002\nName: Bob The Builder\nEmail: bob@example.com\nPhone: 444-555-6666\n\nCustomer ID: CUST003\nName: Charlie Chaplin\nEmail: charlie@example.com\nPhone: 777-888-9999\n\n--- Updating Alice's Contact Info ---\nContact info for Alice Wonderland updated successfully.\n\n--- Alice's Updated Details ---\nCustomer ID: CUST001\nName: Alice Wonderland\nEmail: alice.w@newmail.com\nPhone: 000-111-2222\n",
    "explanation": "This problem simulates a foundational part of a CRM system. The `Customer` class encapsulates all data related to a single customer. Using an `ArrayList` allows dynamic storage of multiple `Customer` objects, demonstrating how collections are used to manage groups of objects. The `updateContactInfo` method shows how object methods can be used to modify an object's internal state in a controlled way. This is a very common pattern in business applications where data needs to be structured, stored, and updated."
  },
  {
    "topic": "Object-Oriented Programming (OOP) - Classes and Objects",
    "level": "Real World Problem",
    "title": "Online Order Processing - OrderItem and Order Classes",
    "description": "You are building a simplified online order processing system. Your task is to: \n1. Create an `OrderItem` class to represent a single item within an order. \n    * `private String productName` \n    * `private double unitPrice` \n    * `private int quantity` \n    * Constructor, getters for all. \n    * `public double getTotalItemCost()` method (returns `unitPrice * quantity`). \n2. Create an `Order` class. \n    * `private String orderId` \n    * `private ArrayList<OrderItem> items` (to store multiple `OrderItem` objects) \n    * Constructor that takes `orderId` and initializes the `items` `ArrayList`. \n    * `public void addOrderItem(OrderItem item)` method to add an item to the order. \n    * `public double calculateTotalOrderCost()` method (sums up `getTotalItemCost()` for all items). \n    * `public void displayOrderDetails()` method to print the `orderId`, and for each item: `productName`, `unitPrice`, `quantity`, `totalItemCost`, then the `totalOrderCost` at the end (all formatted). \n3. In your `main` method: \n    * Create an `Order` object. \n    * Create several `OrderItem` objects. \n    * Add these `OrderItem` objects to your `Order` object using `addOrderItem()`. \n    * Call `displayOrderDetails()` on your `Order` object.",
    "constraints": "Create `OrderItem` and `Order` classes as specified, with private attributes, constructors, and getters. Implement `getTotalItemCost()`, `addOrderItem()`, `calculateTotalOrderCost()`, `displayOrderDetails()` methods. Use `ArrayList` for `Order`'s `items`. In `main`, create an `Order` and multiple `OrderItem`s, add them, then display order details. All currency to two decimal places. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Order ID: ORD12345\n--- Items in Order ---\n- Product: Laptop, Unit Price: $1200.00, Quantity: 1, Item Cost: $1200.00\n- Product: Wireless Mouse, Unit Price: $25.50, Quantity: 2, Item Cost: $51.00\n- Product: USB-C Hub, Unit Price: $40.00, Quantity: 1, Item Cost: $40.00\n\nTotal Order Cost: $1291.00\n",
    "explanation": "This real-world problem uses two interacting classes to model an online order. `OrderItem` represents a line item, and `Order` aggregates multiple `OrderItem`s, showcasing **composition** (an `Order` 'has-a' `ArrayList` of `OrderItem`s). The `ArrayList` is crucial for holding a variable number of items. `calculateTotalOrderCost()` demonstrates iterating over a collection of objects and invoking methods on each object (`item.getTotalItemCost()`) to aggregate a final result. This is a classic example of how OOP is used to design complex, hierarchical data structures for business logic."
  }
]