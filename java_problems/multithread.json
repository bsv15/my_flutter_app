[
  {
    "topic": "Basic Multithreading",
    "level": "Easy",
    "title": "Create Threads using `Thread` Class",
    "description": "This problem introduces the most basic way to create threads by extending the `Thread` class. Your task is to: \n1. Create a class `MyThread` that **extends** `java.lang.Thread`. \n2. Override the `public void run()` method. Inside `run()`, print a message indicating which thread is running (e.g., 'Thread [thread name] is running.'). \n3. In your `main` method: \n    * Create two instances of `MyThread`. \n    * Call the `start()` method on both instances to begin their execution.",
    "constraints": "`MyThread` must extend `Thread`. `run()` method must print a message. Create two `MyThread` objects. Call `start()` on both. No user input.",
    "sampleInput": "None",
    "sampleOutput": "(Order may vary due to concurrent execution)\nThread Thread-0 is running.\nThread Thread-1 is running.\n",
    "explanation": "Extending the `Thread` class is one way to create a thread. The `run()` method contains the code that the new thread will execute. Calling `start()` (not `run()`) on a `Thread` object initializes a new thread and calls its `run()` method. The output order can vary because threads execute concurrently, meaning the JVM schedules them, and their execution might interleave."
  },
  {
    "topic": "Basic Multithreading",
    "level": "Easy",
    "title": "Create Threads using `Runnable` Interface",
    "description": "This problem introduces the preferred way to create threads using the `Runnable` interface, which promotes better design (separation of concerns). Your task is to: \n1. Create a class `MyRunnable` that **implements** `java.lang.Runnable`. \n2. Implement the `public void run()` method. Inside `run()`, print a message indicating which thread is running (e.g., 'Runnable executed by Thread [thread name].'). \n3. In your `main` method: \n    * Create two instances of `MyRunnable`. \n    * Create two `Thread` objects, passing a `MyRunnable` instance to each `Thread` constructor. \n    * Call the `start()` method on both `Thread` objects.",
    "constraints": "`MyRunnable` must implement `Runnable`. `run()` method must print a message. Create two `MyRunnable` instances. Create two `Thread` objects (wrapping `MyRunnable`). Call `start()` on both `Thread` objects. No user input.",
    "sampleInput": "None",
    "sampleOutput": "(Order may vary)\nRunnable executed by Thread Thread-0.\nRunnable executed by Thread Thread-1.\n",
    "explanation": "Implementing `Runnable` is generally preferred over extending `Thread` because it allows your class to extend another class if needed (Java doesn't support multiple inheritance of classes). It also separates the task (what to run) from the thread (how to run it). A `Runnable` object is then passed to a `Thread` constructor, and `Thread.start()` is called on the `Thread` object to begin execution."
  },
  {
    "topic": "Basic Multithreading",
    "level": "Medium",
    "title": "Thread Sleep for Pausing Execution",
    "description": "This problem demonstrates using `Thread.sleep()` to pause a thread's execution for a specified duration. Your task is to: \n1. Create a class `CountdownThread` that implements `Runnable`. \n2. In its constructor, take a `String name` to identify the thread. \n3. In the `run()` method: \n    * Loop 5 times. \n    * In each iteration, print 'Thread [name]: Count [i]'. \n    * After printing, use `Thread.sleep(500)` to pause for 500 milliseconds. \n    * Handle `InterruptedException` by printing 'Thread [name] was interrupted!' and exiting the loop. \n4. In your `main` method: \n    * Create two `CountdownThread` objects with different names. \n    * Create and start two `Thread` objects for them. \n    * Observe the interleaved output.",
    "constraints": "`CountdownThread` implements `Runnable`. Constructor takes `name`. `run()` loops 5 times, prints, then `sleep(500)`. Must `catch InterruptedException`. Create and start two threads in `main`. No user input.",
    "sampleInput": "None",
    "sampleOutput": "(Interleaved output, example shown)\nThread A: Count 1\nThread B: Count 1\nThread A: Count 2\nThread B: Count 2\n...\n",
    "explanation": "`Thread.sleep(milliseconds)` causes the current thread to pause execution for the specified time. This is useful for simulating work, controlling animation speeds, or avoiding busy-waiting. It throws an `InterruptedException` if another thread interrupts the sleeping thread, which must be caught or declared. The interleaved output demonstrates how pausing one thread allows the other to run, highlighting concurrency."
  },
  {
    "topic": "Basic Multithreading",
    "level": "Medium",
    "title": "Thread `join()` for Waiting",
    "description": "This problem demonstrates using the `join()` method to make one thread wait for another to complete its execution. Your task is to: \n1. Create a class `WorkerThread` that implements `Runnable`. \n2. In its constructor, take a `String name` and `long sleepDuration` (in milliseconds). \n3. In the `run()` method: \n    * Print 'Thread [name] started.' \n    * `Thread.sleep(sleepDuration)` to simulate work. Handle `InterruptedException`. \n    * Print 'Thread [name] finished.' \n4. In your `main` method: \n    * Create two `WorkerThread` objects: `worker1` (sleep 2000ms), `worker2` (sleep 1000ms). \n    * Create and start their respective `Thread` objects. \n    * Call `thread1.join();` and `thread2.join();` after starting them. \n    * After the `join()` calls, print 'All worker threads have finished.'. \n    * Handle `InterruptedException` for `join()` calls.",
    "constraints": "`WorkerThread` implements `Runnable`, constructor takes `name` and `sleepDuration`. `run()` prints start/end and sleeps. `main` starts two threads, then `join()`s both. `main` prints 'All worker threads...' *after* joins. Handle `InterruptedException`. No user input.",
    "sampleInput": "None",
    "sampleOutput": "(Order of 'started' messages may vary, but 'finished' messages will be in order of completion, and 'All worker threads...' always last)\nThread WorkerA started.\nThread WorkerB started.\nThread WorkerB finished.\nThread WorkerA finished.\nAll worker threads have finished.\n",
    "explanation": "The `join()` method allows a thread to wait until another thread terminates. When `main` calls `thread1.join()`, `main` pauses its execution and waits for `thread1` to complete. Only after `thread1` is dead (or the timeout for `join(timeout)` expires) does `main` resume. This is essential for coordinating threads when you need to ensure certain tasks are completed before proceeding, like waiting for background processing to finish before displaying a final result."
  },
  {
    "topic": "Basic Multithreading",
    "level": "Hard",
    "title": "Synchronization: Solving Race Condition with `synchronized`",
    "description": "This problem introduces the concept of a **race condition** and how to solve it using the `synchronized` keyword. Your task is to: \n1. Create a class `Counter` with a `private int count = 0;`. \n2. Add a `public void increment()` method that increments `count`. **Do not synchronize this method initially.** \n3. Add a `public int getCount()` method. \n4. Create a `CountingThread` class that implements `Runnable`. \n    * Its constructor takes a `Counter` object. \n    * In its `run()` method, loop 1000 times, calling `counter.increment()` in each iteration. \n5. In your `main` method: \n    * Create a single `Counter` object. \n    * Create two `CountingThread` objects, both passing the *same* `Counter` instance. \n    * Create and start two `Thread` objects for them. \n    * `join()` both threads. \n    * Print the final `counter.getCount()`. (You'll likely see a value less than 2000). \n6. **Now, modify** the `increment()` method in `Counter` to be `public synchronized void increment()`. Rerun and observe the correct count.",
    "constraints": "`Counter` class with `count` and `increment()` (initially unsynchronized), `getCount()`. `CountingThread` calls `increment` 1000 times. `main` uses *one* `Counter` instance with *two* `CountingThread`s. `join()` threads. Print final count. Then, modify `increment` to `synchronized` and observe. No user input.",
    "sampleInput": "None",
    "sampleOutput": "(Without synchronization - varies, likely less than 2000)\nFinal count (without sync): [e.g., 1897]\n\n(With synchronization - always 2000)\nFinal count (with sync): 2000\n",
    "explanation": "A **race condition** occurs when multiple threads access and modify shared data concurrently, leading to unpredictable results. In this case, `increment()` is a critical section: `count++` is not an atomic operation (it's read, incremented, then written back). Without `synchronized`, threads can interleave these steps, causing increments to be lost. \n`synchronized` ensures that only one thread can execute the `increment()` method on a given `Counter` object at any one time. It acts as a lock, preventing other threads from entering the synchronized block until the current thread exits it, thus eliminating the race condition and guaranteeing the correct count."
  },
  {
    "topic": "Basic Multithreading",
    "level": "Hard",
    "title": "Producer-Consumer Problem with `wait()` and `notify()`",
    "description": "This problem implements the classic Producer-Consumer problem using `wait()` and `notify()` for inter-thread communication. Your task is to: \n1. Create a `MessageQueue` class: \n    * `private List<String> queue = new ArrayList<>();` \n    * `private final int CAPACITY = 5;` \n    * `public synchronized void put(String message)` method: \n        * If `queue.size() == CAPACITY`, call `wait()` (handle `InterruptedException`). \n        * Add message to `queue`. \n        * Print 'Produced: [message]'. \n        * Call `notifyAll()`. \n    * `public synchronized String take()` method: \n        * If `queue.isEmpty()`, call `wait()` (handle `InterruptedException`). \n        * Remove and return the first message. \n        * Print 'Consumed: [message]'. \n        * Call `notifyAll()`. \n2. Create a `Producer` class implements `Runnable`: \n    * Constructor takes `MessageQueue` object. \n    * In `run()`, loop 10 times, generating and putting messages into the queue. \n3. Create a `Consumer` class implements `Runnable`: \n    * Constructor takes `MessageQueue` object. \n    * In `run()`, loop 10 times, taking and printing messages from the queue. \n4. In `main`: \n    * Create a `MessageQueue` object. \n    * Create `Producer` and `Consumer` objects, passing the same `MessageQueue`. \n    * Create and start `Thread` objects for `Producer` and `Consumer`. \n    * `join()` both threads.",
    "constraints": "`MessageQueue` class with `queue`, `CAPACITY`. `put` and `take` methods must be `synchronized`. Use `wait()` when queue full/empty, `notifyAll()` after modification. Handle `InterruptedException`. `Producer` and `Consumer` run 10 times each. `main` sets up and joins. No user input.",
    "sampleInput": "None",
    "sampleOutput": "(Interleaved output of produced/consumed messages)\nProduced: Message 0\nProduced: Message 1\nConsumed: Message 0\nProduced: Message 2\nConsumed: Message 1\n...\nProduced: Message 9\nConsumed: Message 9\n",
    "explanation": "The **Producer-Consumer problem** involves threads (producers) generating data and other threads (consumers) processing it via a shared buffer. `wait()` and `notify()` (or `notifyAll()`) are crucial for inter-thread communication: \n* `wait()`: Releases the object's lock and puts the calling thread into a waiting state until another thread invokes `notify()` or `notifyAll()`. \n* `notifyAll()`: Wakes up all threads that are waiting on the object's monitor. \nBoth `wait()` and `notify()` must be called within a `synchronized` block on the same object that is being waited on. This mechanism prevents busy-waiting and ensures threads efficiently yield control when they cannot proceed (e.g., producer buffer full, consumer buffer empty)."
  },
  {
    "topic": "Basic Multithreading",
    "level": "Tricky",
    "title": "Deadlock Scenario",
    "description": "This problem demonstrates a **deadlock** scenario, where two or more threads are blocked indefinitely, waiting for each other to release resources. Your task is to: \n1. Create two `Object` instances, `ResourceA` and `ResourceB`, to act as locks. \n2. Create a `ThreadA` class that implements `Runnable`: \n    * In its `run()` method: \n        * Acquire lock on `ResourceA`. Print 'ThreadA: Acquired ResourceA'. \n        * `Thread.sleep(50);` (to ensure ThreadB gets a chance to acquire its first lock). \n        * Acquire lock on `ResourceB`. Print 'ThreadA: Acquired ResourceB'. \n        * Print 'ThreadA: Finished.'. \n3. Create a `ThreadB` class that implements `Runnable`: \n    * In its `run()` method: \n        * Acquire lock on `ResourceB`. Print 'ThreadB: Acquired ResourceB'. \n        * `Thread.sleep(50);` \n        * Acquire lock on `ResourceA`. Print 'ThreadB: Acquired ResourceA'. \n        * Print 'ThreadB: Finished.'. \n4. In `main`: \n    * Create two `Thread` objects, one for `ThreadA` and one for `ThreadB`. \n    * Start both threads. \n    * Observe the output, which should show both threads acquiring their first lock but then getting stuck trying to acquire the second one.",
    "constraints": "Define two `Object` locks (`ResourceA`, `ResourceB`). `ThreadA` locks A then B. `ThreadB` locks B then A. Use `Thread.sleep()` to help ensure specific interleaving leading to deadlock. Start both threads in `main`. No user input.",
    "sampleInput": "None",
    "sampleOutput": "(Exact output order leading to deadlock may vary, but typically will show this pattern and then hang)\nThreadA: Acquired ResourceA\nThreadB: Acquired ResourceB\n(Program hangs here)\n",
    "explanation": "A **deadlock** occurs when: \n1. **Mutual exclusion**: Resources are exclusively held by one thread. \n2. **Hold and wait**: Threads hold resources while waiting for others. \n3. **No preemption**: Resources cannot be forcibly taken. \n4. **Circular wait**: A circular chain of threads exists, each waiting for a resource held by the next. \nIn this problem, `ThreadA` holds `ResourceA` and waits for `ResourceB`, while `ThreadB` holds `ResourceB` and waits for `ResourceA`. This creates a circular dependency, leading to a deadlock. This is a common and difficult-to-debug problem in concurrent programming, illustrating the importance of careful resource allocation."
  },
  {
    "topic": "Basic Multithreading",
    "level": "Real World Problem",
    "title": "Concurrent File Download Simulation",
    "description": "You're simulating concurrent file downloads. Each download is a separate thread. Your task is to: \n1. Create a `FileDownloader` class that implements `Runnable`. \n2. In its constructor, take `String fileName` and `int downloadTimeMillis` (to simulate download duration). \n3. In the `run()` method: \n    * Print 'Starting download for: ' + `fileName`. \n    * Simulate download by `Thread.sleep(downloadTimeMillis)`. Handle `InterruptedException`. \n    * Print 'Finished download for: ' + `fileName`. \n4. In your `main` method: \n    * Create an `ArrayList` of `Thread` objects. \n    * Create at least three `FileDownloader` instances with different file names and download times. \n    * Create `Thread` objects for each downloader and add them to the `ArrayList`. \n    * Start all threads in the list. \n    * After starting all, `join()` each thread in the `ArrayList` to wait for all downloads to complete. \n    * Finally, print 'All downloads completed.'.",
    "constraints": "`FileDownloader` implements `Runnable`, constructor takes `fileName` and `downloadTimeMillis`. `run()` prints start/end and sleeps. Handle `InterruptedException`. Use `ArrayList<Thread>`. Create and start at least 3 `FileDownloader` threads. `join()` all threads in the list. Print final message after all joins. No user input.",
    "sampleInput": "None",
    "sampleOutput": "(Order of starting/finishing will vary based on sleep times and CPU scheduling)\nStarting download for: document.pdf\nStarting download for: image.jpg\nStarting download for: video.mp4\nFinished download for: image.jpg\nFinished download for: document.pdf\nFinished download for: video.mp4\nAll downloads completed.\n",
    "explanation": "This real-world problem demonstrates how multithreading can be used to perform concurrent tasks (simulating multiple file downloads). Each `FileDownloader` runs independently in its own thread. The `main` thread starts all downloads and then uses `join()` on each `Thread` object in the `ArrayList` to wait until all downloads have finished. This is a practical example of how threads can be used to improve the responsiveness and efficiency of applications by performing time-consuming operations in the background without blocking the main program flow."
  }
]