[
  {
    "topic": "Pointers and References",
    "level": "Easy",
    "title": "Basic Pointer Declaration and Dereferencing",
    "description": "This problem introduces the fundamental concept of **pointers**, which are variables that store memory addresses. It also covers **dereferencing** (using the `*` operator) to access the value stored at the address a pointer holds. Your task is to: \n1.  Declare an `int` variable and initialize it with a value (e.g., 100). \n2.  Declare an `int` pointer and make it point to the address of the `int` variable using the address-of operator (`&`). \n3.  Print the value of the `int` variable directly. \n4.  Print the address stored in the pointer. \n5.  Print the value accessed through the pointer (dereferencing the pointer). \nThis exercise is crucial for understanding how pointers store addresses and retrieve values.",
    "constraints": "You must declare an `int` variable and an `int*` pointer. Use `&` to get the address and `*` for dereferencing. Print the variable's value, the pointer's address, and the value through the pointer. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Value of num: 100\nAddress stored in ptr: 0x7ffee1f0a8ac (Actual address may vary)\nValue accessed via ptr: 100\n",
    "explanation": "An `int` variable `num` is declared. An `int*` pointer `ptr` is declared and initialized with the address of `num` using `&num`. The program then prints `num` directly. It prints the hexadecimal memory address stored in `ptr`. Finally, it prints `*ptr`, which dereferences `ptr` to access the value at `num`'s memory location, confirming it's 100."
  },
  {
    "topic": "Pointers and References",
    "level": "Easy",
    "title": "Introduction to References",
    "description": "This problem introduces **references (`&`)**, which are aliases (alternative names) for existing variables. Unlike pointers, references cannot be null, cannot be re-assigned to refer to a different variable after initialization, and do not require dereferencing (`*`) to access the original value. Your task is to: \n1.  Declare an `int` variable and initialize it with a value (e.g., 50). \n2.  Declare an `int` reference and make it refer to the `int` variable. \n3.  Print the value of the `int` variable. \n4.  Print the value of the `int` reference. \n5.  Modify the value through the reference. \n6.  Print the value of the `int` variable again to show it was modified by the reference. \nThis exercise clarifies how references act as direct aliases.",
    "constraints": "You must declare an `int` variable and an `int&` reference. Initialize the reference to refer to the variable. Modify the variable's value *through the reference*. Print values to demonstrate the alias behavior. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Original value of num: 50\nValue via reference ref_num: 50\nValue of num after modification via ref_num: 75\n",
    "explanation": "An `int` variable `num` is declared. An `int&` reference `ref_num` is declared and initialized to refer to `num`. When `ref_num` is printed, it shows `num`'s value. When `ref_num = 75;` is executed, it directly modifies `num` to 75, which is then verified by printing `num` again. This demonstrates that `ref_num` is simply another name for `num`."
  },
  {
    "topic": "Pointers and References",
    "level": "Easy",
    "title": "Pass by Pointer: Modify Value in Function",
    "description": "This problem explicitly demonstrates **pass-by-pointer** to allow a function to modify a variable in the caller's scope. When a pointer is passed, the function receives a copy of the memory address. By dereferencing this copied address, the function can access and modify the original variable. Your task is to: \n1.  Define a function `void increment_by_pointer(int* ptr)` that takes an `int` pointer as a parameter. Inside this function, increment the value that `ptr` points to by 10. \n2.  In `main`, declare an `int` variable (e.g., `num = 5`). \n3.  Print `num`'s initial value. \n4.  Call `increment_by_pointer`, passing the address of `num`. \n5.  Print `num`'s value again to confirm it was modified. \nThis exercise highlights how pointers enable functions to have side effects on caller variables.",
    "constraints": "You must define a function `increment_by_pointer` taking an `int*` parameter and returning `void`. The function must modify the value pointed to by the pointer. `main` must call this function. Print values before and after modification. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Initial value of num: 5\nValue of num after increment: 15\n",
    "explanation": "The `increment_by_pointer` function takes an `int* ptr`. Inside, `(*ptr) += 10;` dereferences `ptr` to access the original `num` in `main` and adds 10 to it. When `increment_by_pointer(&num)` is called in `main`, the address of `num` is passed. The function modifies `num` through this address, changing it from 5 to 15. The final print confirms this change."
  },
  {
    "topic": "Pointers and References",
    "level": "Easy",
    "title": "Array Name as Pointer (Access Elements)",
    "description": "In C++, a C-style array's name often **decays to a pointer** to its first element when used in expressions (like function arguments). This problem demonstrates using pointer arithmetic to access array elements. Your task is to: \n1.  Declare and initialize a C-style `double` array (e.g., `double prices[] = {10.5, 20.0, 5.75};`). \n2.  Declare a `double` pointer and make it point to the beginning of the `prices` array (e.g., `double* ptr = prices;`). \n3.  Using **pointer arithmetic** (`ptr + offset`) and dereferencing (`*`), print each element of the array. Do not use array indexing (`[]`) for printing the elements. \nThis problem clarifies the relationship between array names and pointers.",
    "constraints": "You must use a C-style `double[]` array. You must declare a `double*` pointer pointing to the array's beginning. You must use pointer arithmetic and dereferencing (e.g., `*(ptr + i)`) to access and print each element. Do not use `[]` for element access during printing. Print elements on separate lines. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Elements of the array:\n10.50\n20.00\n5.75\n",
    "explanation": "A `double` array `prices` is initialized. A `double*` pointer `ptr` is initialized to `prices` (which decays to a pointer to its first element). A `for` loop iterates from `i = 0` up to the array size. `*(ptr + i)` calculates the address of the `i`-th element relative to `ptr` (the start of the array) and then dereferences it to get the value. This prints each element of the array."
  },
  {
    "topic": "Pointers and References",
    "level": "Medium",
    "title": "Dynamic Allocation of Single Variable",
    "description": "This problem extends dynamic memory management to single variables, not just arrays. Using `new` for a single variable allocates memory on the heap and returns a pointer to it. `delete` is then used to deallocate that memory. Your task is to: \n1.  Prompt the user to enter an integer value. \n2.  Dynamically allocate an `int` variable on the heap using `new`. \n3.  Store the user's input value into this dynamically allocated `int` variable (via its pointer). \n4.  Print the value stored in the dynamically allocated memory (by dereferencing the pointer). \n5.  **Crucially**, deallocate the memory using `delete`. \n\nThis problem emphasizes correct `new` and `delete` usage for single objects and safe memory practices.",
    "constraints": "You must use `new int` for dynamic allocation of a single integer. You must use `delete` for deallocation. You must use `std::cin` for input. Print the value. Assume valid integer input.",
    "sampleInput": "Enter an integer value: 42",
    "sampleOutput": "Enter an integer value: 42\nValue stored in dynamically allocated memory: 42\nMemory deallocated.\n",
    "explanation": "The program declares an `int*` pointer `dynamic_int`. `dynamic_int = new int;` allocates memory for a single `int` on the heap and assigns its address to `dynamic_int`. The user's input is read into this memory location via `*dynamic_int = user_value;`. The value is then printed using `*dynamic_int`. Finally, `delete dynamic_int;` deallocates the memory, and `dynamic_int = nullptr;` sets the pointer to null to avoid a dangling pointer."
  },
  {
    "topic": "Pointers and References",
    "level": "Medium",
    "title": "Pointer to Pointer (Double Pointer)",
    "description": "This problem introduces **pointers to pointers** (also known as double pointers or `**`), which store the address of another pointer. This concept is typically used in scenarios like passing pointers by reference to functions that modify where a pointer points, or for managing dynamic 2D arrays. Your task is to: \n1.  Declare an `int` variable and initialize it. \n2.  Declare an `int*` pointer and make it point to the `int` variable. \n3.  Declare an `int**` (pointer to an `int` pointer) and make it point to the `int*` pointer. \n4.  Using the `int**` pointer, print: \n    * The address of the `int*` pointer. \n    * The address of the `int` variable (by dereferencing the `int**` once). \n    * The value of the `int` variable (by dereferencing the `int**` twice). \nThis exercise helps you navigate multiple levels of indirection.",
    "constraints": "You must declare an `int`, an `int*`, and an `int**`. All pointers must be correctly linked (pointing to the level below them). Print the addresses and values as specified using the double pointer. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Value of num: 123\nAddress of ptr: 0x7ffee1f0a8c8 (Actual address may vary)\nAddress of num: 0x7ffee1f0a8c4 (Actual address may vary)\nValue of num via double_ptr: 123\n",
    "explanation": "An `int num`, an `int* ptr`, and an `int** double_ptr` are declared. `ptr` stores the address of `num`. `double_ptr` stores the address of `ptr`. \n* `double_ptr` prints the address of `ptr`. \n* `*double_ptr` dereferences `double_ptr` to get the value stored in `ptr` (which is the address of `num`). \n* `**double_ptr` dereferences `double_ptr` twice: first to get `ptr`, then `ptr` is dereferenced to get the value of `num`. This demonstrates reaching the original value through two levels of indirection."
  },
  {
    "topic": "Pointers and References",
    "level": "Medium",
    "title": "Return by Reference from Function",
    "description": "This problem explores **return-by-reference** from functions. A function can return a reference to a variable, meaning it returns an alias to an existing variable, not a copy of its value. This allows the caller to directly modify the original variable through the returned reference. This is powerful but must be used carefully to avoid returning references to local (stack) variables that will be destroyed when the function exits. Your task is to: \n1.  Declare a global or static `int` array (or an array in `main` that you pass to a function and return a reference from). Let's aim for the safer approach: an array defined in `main`. \n2.  Define a function `int& get_element_by_ref(int arr[], int index)` that takes a C-style array and an index. It should return a reference to the element at that `index` in the array. \n3.  In `main`, declare an `int` array. Call `get_element_by_ref` to get a reference to a specific element (e.g., `arr[2]`). \n4.  Modify the value of this element *through the returned reference*. \n5.  Print the array before and after the modification to confirm the change. \nThis problem highlights the ability to directly modify caller's data through a function's return value.",
    "constraints": "You must use a C-style `int[]` array declared in `main`. You must define a function `get_element_by_ref` that takes an `int[]` and `int index`, and returns `int&`. You must modify an array element *through the returned reference*. Print the array before and after modification. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Original array: 10 20 30 40 50\nElement at index 2 (value 30) will be changed.\nArray after modification: 10 20 99 40 50\n",
    "explanation": "An `int` array `my_array` is defined in `main`. The `get_element_by_ref` function takes the array (as a pointer) and an index. It returns `arr[index]` **by reference** (`int&`). In `main`, `int& third_element = get_element_by_ref(my_array, 2);` makes `third_element` an alias for `my_array[2]`. When `third_element = 99;` is executed, it directly modifies `my_array[2]` from 30 to 99. The before and after prints confirm this in-place modification."
  },
  {
    "topic": "Pointers and References",
    "level": "Hard",
    "title": "Implementing `swap` using Pointers (Deep Understanding)",
    "description": "This problem is a classic way to demonstrate the necessity of pointers (or references) when you want a function to modify its arguments. You've seen `std::swap` or `swap_numbers` with references. Here, you will implement it using pointers, which requires manual dereferencing. Your task is to: \n1.  Define a function `void custom_swap(int* a, int* b)` that takes two `int` pointers as arguments. \n2.  Inside `custom_swap`, swap the *values* pointed to by `a` and `b`. You will need a temporary variable of type `int`. \n3.  In `main`, declare two `int` variables and initialize them. \n4.  Print their initial values. \n5.  Call `custom_swap`, passing the addresses of your two variables. \n6.  Print their values again to show they have been swapped. \n\nThis problem is hard because it requires careful use of the dereference operator (`*`) and understanding how memory addresses enable a function to reach outside its own scope.",
    "constraints": "You must define a function `custom_swap` with the signature `void custom_swap(int* a, int* b)`. The function must swap the values pointed to by `a` and `b`. `main` must call `custom_swap` by passing addresses. Print values before and after the swap. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Before swap: num1 = 100, num2 = 200\nAfter swap: num1 = 200, num2 = 100\n",
    "explanation": "The `custom_swap` function takes two `int*` pointers, `a` and `b`. \n1.  `int temp = *a;` copies the value that `a` points to (which is `num1`'s value) into `temp`. \n2.  `*a = *b;` copies the value that `b` points to (which is `num2`'s value) into the memory location pointed to by `a` (i.e., `num1`'s location). \n3.  `*b = temp;` copies the value from `temp` into the memory location pointed to by `b` (i.e., `num2`'s location). \nThis sequence effectively swaps the *original values* of `num1` and `num2` in `main` because the function operates directly on the memory locations via the passed pointers."
  },
  {
    "topic": "Pointers and References",
    "level": "Hard",
    "title": "Dynamic 2D Array (Matrix) Allocation",
    "description": "This problem involves dynamically allocating a **2D array (matrix)** on the heap, which is more complex than a 1D array as it often involves an array of pointers, where each pointer points to a 1D array (a row). This is critical for creating matrices of runtime-determined dimensions. Your task is to: \n1.  Prompt the user for the number of `rows` and `cols` for a 2D integer matrix. \n2.  Dynamically allocate a 2D integer array (matrix) on the heap. This typically means allocating an array of `int*` pointers, and then for each `int*`, allocating an `int[]` for the row. \n3.  Populate the matrix with values (e.g., sequentially from 1, or user input). \n4.  Print the matrix in a clear, formatted way. \n5.  **Crucially**, deallocate all the dynamically allocated memory for the 2D array, ensuring no memory leaks. \n\nThis problem is hard due to the multi-step allocation and deallocation process, requiring a deep understanding of pointers and nested `new`/`delete` operations.",
    "constraints": "You must use `new` and `delete` (or `new[]` and `delete[]`) for dynamic allocation and deallocation. You must prompt for `rows` and `cols`. You must allocate a 2D array (matrix) structure. Populate and print the matrix. Ensure all allocated memory is correctly deallocated. Assume valid positive integer inputs for dimensions.",
    "sampleInput": "Enter number of rows: 2\nEnter number of columns: 3",
    "sampleOutput": "Enter number of rows: 2\nEnter number of columns: 3\nDynamically allocated matrix:\n1 2 3\n4 5 6\nMemory deallocated.\n",
    "explanation": "The program prompts for `rows` and `cols`. \n1.  `int** matrix = new int*[rows];` allocates an array of `int*` pointers (for the rows). \n2.  A `for` loop then iterates through these `rows`, and for each `matrix[i]`, `matrix[i] = new int[cols];` allocates a 1D array for that specific row. \n3.  Nested loops populate the matrix with sequential numbers. \n4.  The matrix is then printed. \n5.  For deallocation, a `for` loop iterates through `rows` again, calling `delete[] matrix[i];` for each row to free the individual 1D arrays. \n6.  Finally, `delete[] matrix;` frees the array of pointers itself. Setting `matrix = nullptr;` is good practice."
  },
  {
    "topic": "Pointers and References",
    "level": "Tricky",
    "title": "Reference to Pointer and Modifying Pointer Target",
    "description": "This problem combines references with pointers in a tricky way: passing a **reference to a pointer** to a function. This allows the function to *change which variable the original pointer in the caller's scope points to*. This is distinct from passing a pointer by value (where you can only change the value *pointed to*), or passing a regular variable by reference. \n\nYour task is to: \n1.  In `main`, declare two `int` variables, `valA = 10` and `valB = 20`. \n2.  Declare an `int*` pointer `p` and initially make it point to `valA`. Print the value `p` points to. \n3.  Define a function `void redirect_pointer(int*& ptr_ref, int* new_target_ptr)`: \n    * It takes a reference to an `int*` (a pointer to an integer). \n    * It takes another `int*` which is the address of the new target. \n    * Inside the function, assign `ptr_ref = new_target_ptr;`. This will change *which variable* the original pointer in `main` points to. \n4.  In `main`, call `redirect_pointer` passing `p` (the pointer itself, but captured by reference in the function) and the address of `valB`. \n5.  Print the value that `p` now points to, demonstrating that it has been redirected to `valB`. \n\nThis problem is tricky because `int*&` syntax can be confusing and its implications on modifying the pointer variable itself (not just the value it points to) are subtle.",
    "constraints": "You must use `int*&` for the function parameter that modifies the original pointer. You must have two distinct `int` variables in `main`. The `main` pointer must initially point to one, and then be redirected to the other via the function. Print values to demonstrate the pointer redirection. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Initial: p points to value 10\nAfter redirect: p now points to value 20\n",
    "explanation": "1.  In `main`, `valA = 10`, `valB = 20`, and `p` initially points to `valA`. Printing `*p` shows 10. \n2.  `redirect_pointer(p, &valB)` is called. \n    * `ptr_ref` inside the function becomes an alias for the actual pointer variable `p` in `main`. \n    * `new_target_ptr` receives a copy of the address of `valB`. \n3.  `ptr_ref = new_target_ptr;` effectively does `p = &valB;` in `main`'s scope. The pointer `p` now stores the address of `valB`. \n4.  After the function returns, printing `*p` shows `20`, confirming that `p` itself was successfully changed to point to `valB`."
  },
  {
    "topic": "Pointers and References",
    "level": "Tricky",
    "title": "Const Pointers and Pointers to Const",
    "description": "This problem explores the nuances of `const` with pointers: **pointer to constant (`const int*`)** and **constant pointer (`int* const`)**, and their combination (`const int* const`). Understanding these distinctions is crucial for writing robust and safe C++ code, especially when dealing with function parameters and protecting data integrity. \n\nYour task is to: \n1.  Declare an `int` variable `x = 50;`. \n2.  Declare a `const int* ptr_to_const = &x;` (a pointer to a constant integer). Try to modify `*ptr_to_const` (should be a compile error). Print `*ptr_to_const`. \n3.  Declare an `int* const const_ptr = &x;` (a constant pointer to an integer). Try to change `const_ptr` to point to a different variable (should be a compile error). Print `*const_ptr`. \n4.  (Optional for extra challenge) Declare a `const int* const full_const_ptr = &x;` (a constant pointer to a constant integer). Try to modify `*full_const_ptr` and `full_const_ptr` itself (both should be compile errors). Print `*full_const_ptr`. \n\nThis problem is tricky due to the subtle but important differences in `const` placement and the compile-time errors they prevent, enforcing correct usage.",
    "constraints": "You must use `const int*`, `int* const`, and optionally `const int* const`. For each type of pointer, demonstrate through commented-out code (or a clear explanation in comments) attempts to modify what they restrict, leading to compile errors. Print the value pointed to by each pointer where allowed. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Value via ptr_to_const: 50\nValue via const_ptr: 50\nValue via full_const_ptr: 50\n(Attempts to modify values or addresses would result in compile-time errors, demonstrated in code comments).\n",
    "explanation": "1.  `const int* ptr_to_const = &x;`: This pointer *points to* a constant `int`. You **cannot** change the value `*ptr_to_const` (e.g., `*ptr_to_const = 60;` is illegal). You **can** change `ptr_to_const` to point to a different `int` (e.g., `ptr_to_const = &y;` is legal). \n2.  `int* const const_ptr = &x;`: This is a `const` pointer. You **can** change the value `*const_ptr` (e.g., `*const_ptr = 60;` is legal). You **cannot** change `const_ptr` to point to a different address (e.g., `const_ptr = &y;` is illegal). \n3.  `const int* const full_const_ptr = &x;`: This is a `const` pointer to a `const` integer. You **cannot** change `*full_const_ptr` nor `full_const_ptr` itself. All attempts are compile errors. \nThe sample output only shows successful prints, while the problem explanation (and ideal code solution) would highlight the compile-time restrictions for the illegal operations."
  },
  {
    "topic": "Pointers and References",
    "level": "Real World Problem",
    "title": "Dynamic Inventory Management (Pointers to Structs)",
    "description": "You are building a dynamic inventory system where items can be added or removed at runtime. This requires using dynamically allocated structs and managing them with pointers. Your task is to: \n1.  Define a `struct Product` with `std::string name`, `double price`, and `int quantity`. \n2.  Implement a function `Product* create_product(std::string name, double price, int quantity)` that dynamically allocates a `Product` object on the heap, initializes its members with the given parameters, and returns a pointer to the new `Product`. \n3.  Implement a function `void display_product(const Product* p)` that takes a constant pointer to a `Product` and prints its details. \n4.  Implement a function `void delete_product(Product*& p)` that takes a reference to a `Product*` pointer, deallocates the memory that `p` points to, and sets `p` to `nullptr`. (The reference to pointer is crucial here to modify the pointer in the caller's scope). \n5.  In `main`, create a `Product` using `create_product`. Display it. Then, 'delete' it using `delete_product` and demonstrate that the pointer is now `nullptr` (e.g., by checking if `p` is `nullptr` before trying to display it again). \n\nThis problem integrates structs, dynamic allocation, function calls with pointers, and proper memory deallocation, all essential for real-world dynamic data management.",
    "constraints": "You must define the `Product` struct. You must implement `create_product` (returning `Product*`), `display_product` (taking `const Product*`), and `delete_product` (taking `Product*&`). Use `new` and `delete` for allocation/deallocation. Ensure `delete_product` sets the caller's pointer to `nullptr`. Print product details formatted appropriately. No user input required.",
    "sampleInput": "None (logic hardcoded)",
    "sampleOutput": "Created Product:\nName: Laptop\nPrice: $1200.50\nQuantity: 5\n\nDeleting product...\nProduct pointer is now nullptr.\n",
    "explanation": "1.  The `Product` struct is defined. \n2.  `create_product` uses `new Product` to allocate memory, initializes members using the `->` operator (since `this` is a pointer), and returns the new `Product*`. \n3.  `display_product` takes a `const Product*` (emphasizing it won't modify the data) and prints the members via `->`. \n4.  `delete_product(Product*& p)` is key: it takes a reference to the pointer `p` from `main`. `delete p;` deallocates the memory *that `p` points to*. `p = nullptr;` then changes the *original `p` in `main`* to `nullptr`, preventing a dangling pointer. \n5.  In `main`, a product is created, displayed, and then deleted. A check `if (my_product_ptr == nullptr)` demonstrates successful deletion and `nullptr` assignment."
  }
]