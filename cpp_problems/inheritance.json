[
  {
    "topic": "Inheritance and Polymorphism",
    "level": "Easy",
    "title": "Basic Single Inheritance",
    "description": "This problem introduces **single inheritance**, a fundamental OOP concept where a new class (derived class or subclass) inherits properties and behaviors from an existing class (base class or superclass). This promotes code reusability. Your task is to: \n1.  Define a **base class** `Animal` with a public member variable `std::string species` and a public member function `void eat()` that prints 'Animal is eating.'. \n2.  Define a **derived class** `Dog` that **inherits publicly** from `Animal`. \n3.  Inside `Dog`, add a public member variable `std::string breed`. \n4.  Implement a public member function `void bark()` that prints 'Dog is barking!'. \n5.  In `main`, create a `Dog` object. Assign values to its `species` (inherited from `Animal`) and `breed` (from `Dog`). Call its `eat()` method (inherited) and its `bark()` method (its own). \nThis exercise demonstrates how a derived class gains access to public members of its base class.",
    "constraints": "You must define a base class `Animal` and a derived class `Dog` using public inheritance. `Animal` must have `species` and `eat()`. `Dog` must have `breed` and `bark()`. `main` must create a `Dog` object and use both inherited and its own members. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Species: Canine, Breed: Golden Retriever\nAnimal is eating.\nDog is barking!\n",
    "explanation": "The `Animal` class is defined. The `Dog` class inherits publicly from `Animal`, meaning all public members of `Animal` (like `species` and `eat()`) are also public members of `Dog`. `Dog` then adds its own `breed` and `bark()` functionality. In `main`, a `Dog` object uses `myDog.species` and `myDog.eat()` as if they were directly part of `Dog`, demonstrating inheritance. It also uses `myDog.breed` and `myDog.bark()`, which are unique to `Dog`."
  },
  {
    "topic": "Inheritance and Polymorphism",
    "level": "Easy",
    "title": "Method Overriding in Derived Class",
    "description": "This problem introduces **method overriding**, where a derived class provides its own implementation for a member function that is already defined in its base class. This allows specialized behavior while retaining a common interface. Your task is to: \n1.  Define a **base class** `Shape` with a public member function `void draw()` that prints 'Drawing a generic shape.'. \n2.  Define two **derived classes**, `Circle` and `Rectangle`, both inheriting publicly from `Shape`. \n3.  In both `Circle` and `Rectangle`, **override** the `draw()` method to print a more specific message (e.g., 'Drawing a circle.' for `Circle`, 'Drawing a rectangle.' for `Rectangle`). \n4.  In `main`, create objects of `Shape`, `Circle`, and `Rectangle`. Call the `draw()` method on each object. \nThis exercise demonstrates how derived classes can specialize inherited behavior.",
    "constraints": "You must define a base class `Shape` and derived classes `Circle` and `Rectangle`. `Shape` must have a `draw()` method. Both `Circle` and `Rectangle` must override `draw()` with specialized output. `main` must create objects of all three classes and call their respective `draw()` methods. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Drawing a generic shape.\nDrawing a circle.\nDrawing a rectangle.\n",
    "explanation": "The `Shape` class defines a `draw()` method. Both `Circle` and `Rectangle` classes inherit from `Shape` and provide their own implementations for `draw()`. When `s.draw()`, `c.draw()`, and `r.draw()` are called in `main`, the specific version of `draw()` defined within each object's actual class (`Shape`, `Circle`, or `Rectangle`) is executed, demonstrating method overriding."
  },
  {
    "topic": "Inheritance and Polymorphism",
    "level": "Easy",
    "title": "Protected Members in Inheritance",
    "description": "This problem illustrates the use of the **`protected` access specifier**. `protected` members are accessible within the class itself and by its derived classes, but *not* directly from outside the class (like `private` members). This provides a balance between strict encapsulation (`private`) and full accessibility (`public`) for inheritance hierarchies. Your task is to: \n1.  Define a **base class** `Vehicle` with a **protected** member variable `int max_speed`. \n2.  Implement a public constructor `Vehicle(int speed)`. \n3.  Define a **derived class** `Car` that inherits publicly from `Vehicle`. \n4.  In `Car`, implement a public member function `void display_speed()` that directly accesses and prints the inherited `max_speed` (e.g., 'Car Max Speed: [speed] mph.'). \n5.  In `main`, create a `Car` object and call `display_speed()`. (Attempting to directly access `myCar.max_speed` from `main` should cause a compile error, showing `protected` access). \nThis exercise clarifies the `protected` access level.",
    "constraints": "You must define a base class `Vehicle` with `protected int max_speed` and a public constructor. You must define a derived class `Car` that inherits publicly from `Vehicle`. `Car` must have a public method that directly accesses the inherited `protected max_speed`. `main` must create a `Car` object and call its method. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Car Max Speed: 180 mph.\n",
    "explanation": "The `Vehicle` class declares `max_speed` as `protected`. The `Car` class inherits from `Vehicle`. Because `max_speed` is `protected`, `Car`'s member function `display_speed()` has direct access to it, even though it's not a `public` member. In `main`, a `Car` object is created and `display_speed()` is called. If you tried `std::cout << myCar.max_speed;` in `main`, it would result in a compile error because `max_speed` is `protected` and not directly accessible from outside the class hierarchy."
  },
  {
    "topic": "Inheritance and Polymorphism",
    "level": "Easy",
    "title": "Calling Base Class Constructor from Derived",
    "description": "This problem focuses on how derived class constructors properly initialize base class components. When a derived class object is created, its base class's constructor is called first, often implicitly. However, if the base class has a constructor that requires arguments, the derived class's constructor *must explicitly* call the base class constructor. Your task is to: \n1.  Define a **base class** `Person` with a `std::string name` (private) and a constructor `Person(std::string n)`. Include a `get_name() const` method. \n2.  Define a **derived class** `Student` that inherits publicly from `Person`. \n3.  Inside `Student`, add a `int student_id` (private). \n4.  Implement `Student`'s constructor `Student(std::string n, int id)` which explicitly calls the `Person` base class constructor using a **member initializer list** (e.g., `Student(...) : Person(n), student_id(id) { ... }`). \n5.  In `main`, create a `Student` object, passing both name and ID. Print the student's name (via inherited `get_name()`) and their ID. \nThis exercise demonstrates how to properly initialize inherited components when base class constructors require arguments.",
    "constraints": "You must define `Person` (base) and `Student` (derived) classes. `Person` must have a constructor taking a string. `Student` must have a constructor taking a string and an int, and explicitly call the `Person` constructor in its initializer list. Print the inherited name and its own ID. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Student Name: Alice, ID: 12345\n",
    "explanation": "The `Person` class has a constructor `Person(std::string n)`. The `Student` class constructor `Student(std::string n, int id) : Person(n), student_id(id) {}` uses a member initializer list to first call `Person(n)` to initialize the inherited `name` member, and then initializes `student_id`. This ensures that the base class part of the `Student` object is correctly constructed before the `Student`'s own members are initialized. In `main`, the `Student` object is created, and its inherited name and own ID are printed."
  },
  {
    "topic": "Inheritance and Polymorphism",
    "level": "Medium",
    "title": "Virtual Functions and Runtime Polymorphism",
    "description": "This problem introduces **`virtual` functions** and **runtime polymorphism**. When a base class pointer or reference points to a derived class object, calling a `virtual` function through the base class pointer/reference will execute the derived class's version of the function (late binding). This is the core of polymorphism in C++. Your task is to: \n1.  Define a **base class** `Animal` with a `std::string name` and a **`virtual`** member function `void make_sound()` that prints 'Generic animal sound.'. \n2.  Define two **derived classes**, `Dog` and `Cat`, inheriting publicly from `Animal`. \n3.  In both `Dog` and `Cat`, **override** the `make_sound()` function to print specific sounds (e.g., 'Woof!' for `Dog`, 'Meow!' for `Cat`). Use the `override` keyword (C++11 and later) for clarity. \n4.  In `main`, create pointers of type `Animal*`. Assign a `new Dog()` object to one pointer and a `new Cat()` object to another. Call `make_sound()` through these `Animal*` pointers. Remember to `delete` dynamically allocated objects. \nThis problem is crucial for understanding how `virtual` functions enable dynamic behavior based on the actual object type at runtime.",
    "constraints": "You must define a base class `Animal` with a `virtual void make_sound()`. You must define derived classes `Dog` and `Cat` that override `make_sound()` (use `override` keyword). In `main`, use `Animal*` pointers to point to `Dog` and `Cat` objects. Call `make_sound()` through these base pointers. Remember to `delete` allocated memory. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Woof!\nMeow!\n",
    "explanation": "The `Animal` base class has a `virtual void make_sound()`. This tells the compiler that `make_sound()` should be dispatched at runtime based on the actual object type. `Dog` and `Cat` override this function. \nIn `main`, `Animal* animal1 = new Dog();` creates a `Dog` object, but `animal1` is an `Animal*`. When `animal1->make_sound();` is called, because `make_sound()` is `virtual`, the program looks at the *actual type* of the object `animal1` points to (which is `Dog`), and executes `Dog::make_sound()`. The same logic applies to `animal2` and `Cat::make_sound()`. This is runtime polymorphism."
  },
  {
    "topic": "Inheritance and Polymorphism",
    "level": "Medium",
    "title": "Abstract Base Class and Pure Virtual Functions",
    "description": "This problem introduces **abstract base classes** and **pure virtual functions**. An abstract class cannot be instantiated directly and serves as an interface. It contains at least one **pure virtual function** (declared with `= 0;`). Derived classes *must* implement (override) all pure virtual functions to become concrete (instantiable). Your task is to: \n1.  Define an **abstract base class** `PaymentMethod`. \n2.  Declare a **pure virtual function** `void process_payment(double amount) = 0;` inside `PaymentMethod`. \n3.  Define two **concrete derived classes**, `CreditCardPayment` and `PayPalPayment`, both inheriting publicly from `PaymentMethod`. \n4.  In both `CreditCardPayment` and `PayPalPayment`, **implement (override)** the `process_payment` function to print specific messages related to the payment type (e.g., 'Processing Credit Card payment of $[amount].' for `CreditCardPayment`). \n5.  In `main`, create pointers of type `PaymentMethod*`. Assign `new CreditCardPayment()` and `new PayPalPayment()` objects to them. Call `process_payment()` through these base pointers. Remember to `delete` dynamically allocated objects. \nThis problem illustrates how abstract classes define interfaces and how polymorphism works with them.",
    "constraints": "You must define an abstract base class `PaymentMethod` with at least one pure virtual function `process_payment`. You must define two concrete derived classes `CreditCardPayment` and `PayPalPayment` that inherit from `PaymentMethod` and *must* implement `process_payment`. In `main`, use `PaymentMethod*` pointers to demonstrate polymorphism. Remember to `delete` allocated memory. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Processing Credit Card payment of $150.75.\nProcessing PayPal payment of $75.00.\n",
    "explanation": "The `PaymentMethod` class is abstract because `process_payment` is a pure virtual function. This means `PaymentMethod` cannot be instantiated directly. `CreditCardPayment` and `PayPalPayment` are concrete because they provide an implementation for `process_payment`. \nIn `main`, `PaymentMethod*` pointers are used. When `payment1->process_payment(150.75)` is called, even though `payment1` is an `PaymentMethod*`, polymorphism ensures that the `CreditCardPayment::process_payment` is called because `payment1` actually points to a `CreditCardPayment` object. The same applies to `payment2` and `PayPalPayment::process_payment`. This demonstrates interface definition through abstract classes and dynamic dispatch."
  },
  {
    "topic": "Inheritance and Polymorphism",
    "level": "Medium",
    "title": "Virtual Destructors for Proper Cleanup",
    "description": "This problem highlights the critical importance of **`virtual` destructors** in base classes when dealing with polymorphism and dynamic memory. If a derived class object is deleted through a base class pointer and the base class destructor is not `virtual`, only the base class's destructor is called (undefined behavior, potential memory leaks if derived class has its own resources). A `virtual` destructor ensures the correct derived class destructor (and then base class destructors) are called. Your task is to: \n1.  Define a **base class** `Base` with a **`virtual` destructor** `virtual ~Base()` that prints 'Base destructor called.'. \n2.  Define a **derived class** `Derived` that inherits publicly from `Base`. \n3.  Implement a destructor `~Derived()` that prints 'Derived destructor called.'. \n4.  In `main`, dynamically create a `Derived` object using a `Base*` pointer (e.g., `Base* obj = new Derived();`). \n5.  Then, `delete obj;`. Observe the order of destructor calls. If you were to remove the `virtual` keyword from `~Base()`, the output would change (only 'Base destructor called.' would print). \nThis problem is crucial for preventing resource leaks in polymorphic hierarchies.",
    "constraints": "You must define a base class `Base` with a `virtual` destructor. You must define a derived class `Derived` with its own destructor. Both destructors must print messages. In `main`, dynamically allocate a `Derived` object through a `Base*` pointer and then `delete` that pointer. The output must show both destructors being called correctly. No user input required.",
    "sampleInput": "None (logic hardcoded)",
    "sampleOutput": "Derived object created.\nDerived destructor called.\nBase destructor called.\n",
    "explanation": "The `Base` class has a `virtual ~Base()`. The `Derived` class has `~Derived()`. \n1.  `Base* obj = new Derived();` calls `Derived`'s constructor, which implicitly calls `Base`'s constructor. 'Derived object created.' is (implicitly or explicitly) printed. \n2.  When `delete obj;` is called, because `Base`'s destructor is `virtual`, the C++ runtime correctly identifies that `obj` points to a `Derived` object. It first calls `Derived`'s destructor, printing 'Derived destructor called.'. \n3.  After `Derived`'s destructor finishes, it automatically calls `Base`'s destructor, printing 'Base destructor called.'. \nThis ensures proper cleanup of both derived and base class resources, which is essential for resource management in polymorphic classes."
  },
  {
    "topic": "Inheritance and Polymorphism",
    "level": "Hard",
    "title": "Multiple Inheritance (Diamond Problem Intro)",
    "description": "This problem introduces **multiple inheritance**, where a class inherits from more than one base class. While powerful, it can lead to complexities like the 'diamond problem' (ambiguity when two base classes share a common ancestor). This problem will provide a basic example, demonstrating syntax, without explicitly resolving the diamond problem. Your task is to: \n1.  Define a base class `Creature` with a public member function `void breathe()` that prints 'Creature is breathing.'. \n2.  Define two other base classes: `Walker` with `void walk()` ('Walker is walking.') and `Swimmer` with `void swim()` ('Swimmer is swimming.'). \n3.  Define a derived class `Amphibian` that **publicly inherits from both `Walker` and `Swimmer`**. (It does *not* inherit from `Creature` for this simplified scenario, avoiding a diamond). \n4.  In `Amphibian`, implement a public member function `void display_abilities()` that calls `walk()` and `swim()`. \n5.  In `main`, create an `Amphibian` object. Call its `display_abilities()` method. \n\nThis problem demonstrates the syntax of multiple inheritance and how a class combines behaviors from multiple parent classes.",
    "constraints": "You must define a `Creature` class (though not directly used in the diamond for this problem, it's illustrative). You must define `Walker` and `Swimmer` base classes, each with a unique public method. You must define `Amphibian` that inherits publicly from *both* `Walker` and `Swimmer`. `Amphibian` must have a method that calls inherited methods. `main` must create an `Amphibian` object and call its method. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Amphibian abilities:\nWalker is walking.\nSwimmer is swimming.\n",
    "explanation": "The `Walker` and `Swimmer` classes are defined, each with a specific action. The `Amphibian` class then inherits publicly from *both* `Walker` and `Swimmer`. This means an `Amphibian` object contains sub-objects of both `Walker` and `Swimmer`, and thus gains access to their public member functions. In `main`, an `Amphibian` object calls `display_abilities()`, which in turn invokes `walk()` (from `Walker`) and `swim()` (from `Swimmer`), demonstrating how `Amphibian` combines behaviors from multiple base classes."
  },
  {
    "topic": "Inheritance and Polymorphism",
    "level": "Hard",
    "title": "Abstract Factory Pattern (Polymorphic Object Creation)",
    "description": "This problem implements a simplified version of the **Abstract Factory design pattern**, which provides an interface for creating families of related or dependent objects without specifying their concrete classes. This is a common advanced use of polymorphism and abstract classes. Your task is to: \n1.  Define an **abstract base class** `Chair` with a pure virtual `void sit() = 0;`. \n2.  Define a **concrete derived class** `ModernChair` that implements `sit()` to print 'Sitting on a modern chair.'. \n3.  Define another **concrete derived class** `VictorianChair` that implements `sit()` to print 'Sitting on a victorian chair.'. \n4.  Define an **abstract base class** `FurnitureFactory` with pure virtual functions to create different types of furniture: `virtual Chair* create_chair() = 0;`. \n5.  Define two **concrete derived factories**: `ModernFactory` and `VictorianFactory`, both inheriting from `FurnitureFactory`. Each should implement `create_chair()` to return a dynamically allocated object of its specific chair type (e.g., `ModernFactory` returns `new ModernChair()`). \n6.  In `main`, create a `FurnitureFactory*` pointer. Based on a simulated configuration (e.g., a boolean `is_modern_style`), assign either a `new ModernFactory()` or `new VictorianFactory()` to it. \n7.  Then, use the factory pointer to create a `Chair*` object (e.g., `Chair* my_chair = factory->create_chair();`). Call `my_chair->sit()`. Remember to `delete` all dynamically allocated objects. \n\nThis problem is hard because it involves multiple layers of abstraction, polymorphic object creation, and managing dynamic memory for objects created by factories.",
    "constraints": "You must define abstract `Chair` and `FurnitureFactory` classes with pure virtual functions. You must define concrete derived classes (`ModernChair`, `VictorianChair`, `ModernFactory`, `VictorianFactory`) that implement these. `FurnitureFactory` subclasses must dynamically allocate and return `Chair*` objects. In `main`, demonstrate creating a factory polymorphically, then using it to create a chair polymorphically, and calling the chair's method. Ensure all `new`s have corresponding `delete`s. No user input required, use a boolean flag.",
    "sampleInput": "None (logic hardcoded, assume is_modern_style = true)",
    "sampleOutput": "Creating modern style furniture...\nSitting on a modern chair.\n",
    "explanation": "This demonstrates the Abstract Factory pattern. \n* `Chair` and `FurnitureFactory` are abstract interfaces. \n* `ModernChair` and `VictorianChair` are concrete products. \n* `ModernFactory` and `VictorianFactory` are concrete factories that implement the creation logic for their specific product families. \nIn `main`, `FurnitureFactory* factory` is assigned a `ModernFactory` instance polymorphically. When `factory->create_chair()` is called, because `create_chair()` is `virtual`, the `ModernFactory::create_chair()` implementation is executed, which returns a `new ModernChair()`. This `ModernChair` object is stored in a `Chair* my_chair` pointer. Finally, `my_chair->sit()` calls `ModernChair::sit()` polymorphically. This structure allows you to switch between 'modern' and 'victorian' styles by simply changing which concrete factory is instantiated, without altering the client code that uses `factory->create_chair()` and `my_chair->sit()`."
  },
  {
    "topic": "Inheritance and Polymorphism",
    "level": "Tricky",
    "title": "Virtual Base Classes (Diamond Problem Resolution)",
    "description": "This problem addresses the **diamond problem** in multiple inheritance and how to resolve it using **virtual base classes**. The diamond problem occurs when a class indirectly inherits from the same base class multiple times, leading to ambiguity and redundant base class sub-objects. `virtual` inheritance ensures only one shared instance of the common base class. Your task is to: \n1.  Define a base class `Device` with a public member function `void identify()`, which prints 'Device detected.'. \n2.  Define two classes `Scanner` and `Printer`, both inheriting **virtually** from `Device` (e.g., `class Scanner : virtual public Device { ... };`). Each should have a specific `void scan()` or `void print_page()` method. \n3.  Define a derived class `MultifunctionDevice` that inherits from *both* `Scanner` and `Printer` (`class MultifunctionDevice : public Scanner, public Printer { ... };`). \n4.  In `MultifunctionDevice`, implement a `void perform_all_functions()` method that calls `identify()`, `scan()`, and `print_page()`. \n5.  In `main`, create a `MultifunctionDevice` object and call `perform_all_functions()`. Observe that `identify()` is called only once, demonstrating the single shared `Device` sub-object. \n\nThis problem is tricky due to the complex syntax and conceptual understanding required to resolve the diamond problem effectively.",
    "constraints": "You must define `Device`, `Scanner`, `Printer`, and `MultifunctionDevice` classes. `Scanner` and `Printer` must inherit **virtually** from `Device`. `MultifunctionDevice` must inherit from both `Scanner` and `Printer`. `Device` must have `identify()`. `Scanner` and `Printer` must have their own unique methods. `MultifunctionDevice` must call `identify()` (only once) and its inherited methods. `main` must create a `MultifunctionDevice` and call its comprehensive method. No user input required.",
    "sampleInput": "None (logic hardcoded)",
    "sampleOutput": "Device detected.\nScanning document...\nPrinting page...\n",
    "explanation": "1.  `Device` is the common base. \n2.  `Scanner` and `Printer` inherit `virtual public Device`. The `virtual` keyword here is crucial: it tells the compiler that `Device` should be treated as a virtual base class, and if `Device` appears multiple times in a later inheritance hierarchy, only *one* `Device` sub-object should be created. \n3.  `MultifunctionDevice` inherits from `Scanner` and `Printer`. \nBecause `Device` was inherited virtually by `Scanner` and `Printer`, `MultifunctionDevice` contains only **one shared `Device` sub-object**. Thus, when `mfd.identify()` is called, it correctly resolves to this single `Device::identify()` method, printing 'Device detected.' only once. Without `virtual` inheritance, a compile error due to ambiguity or two `Device` sub-objects would occur."
  },
  {
    "topic": "Inheritance and Polymorphism",
    "level": "Tricky",
    "title": "Slicing Problem with Pointers/References",
    "description": "This problem illustrates the **object slicing problem**, a common pitfall in C++ polymorphism. Slicing occurs when a derived class object is assigned to or initialized by a base class object (by value). The derived-specific parts are 'sliced off', and only the base class portion is copied, leading to loss of polymorphic behavior. This problem is tricky because it often leads to unexpected behavior rather than compile errors. Your task is to: \n1.  Define a base class `Shape` with a `virtual void print_type()` that prints 'I am a Shape.'. \n2.  Define a derived class `Circle` that inherits publicly from `Shape` and overrides `print_type()` to print 'I am a Circle.'. \n3.  In `main`: \n    * Create a `Circle` object directly (e.g., `Circle c;`). Call `c.print_type()`. \n    * Create a `Shape` object and assign the `Circle` object to it by value (e.g., `Shape s_copy = c;`). Call `s_copy.print_type()`. Observe the slicing: `s_copy` is a pure `Shape`, not a `Circle`. \n    * Create a `Shape*` pointer and make it point to the `Circle` object (e.g., `Shape* s_ptr = &c;`). Call `s_ptr->print_type()`. Observe correct polymorphic behavior. \n    * Create a `Shape&` reference and make it refer to the `Circle` object (e.g., `Shape& s_ref = c;`). Call `s_ref.print_type()`. Observe correct polymorphic behavior. \n\nThis problem highlights the crucial difference between passing/assigning objects by value versus by pointer/reference when dealing with inheritance and polymorphism.",
    "constraints": "You must define `Shape` (base, with `virtual print_type()`) and `Circle` (derived, overriding `print_type()`). In `main`, demonstrate object slicing by assigning a `Circle` to a `Shape` *by value*. Contrast this with using `Shape*` and `Shape&` pointers/references to the `Circle` object, showing correct polymorphic behavior. Print clear messages indicating each step. No user input required.",
    "sampleInput": "None (logic hardcoded)",
    "sampleOutput": "Direct Circle object: I am a Circle.\n\nObject slicing demo:\nShape object (sliced copy of Circle): I am a Shape.\n\nPolymorphism with pointers/references:\nShape pointer to Circle: I am a Circle.\nShape reference to Circle: I am a Circle.\n",
    "explanation": "1.  `Circle c; c.print_type();`: Direct call, prints 'I am a Circle.' \n2.  `Shape s_copy = c;`: This is where slicing occurs. A `Circle` object `c` is copied to a `Shape` object `s_copy`. Only the `Shape` part of `c` is copied; the `Circle`-specific parts are 'sliced off'. So, `s_copy` is truly a `Shape` object, and `s_copy.print_type()` calls `Shape::print_type()`, printing 'I am a Shape.'. \n3.  `Shape* s_ptr = &c;` and `Shape& s_ref = c;`: When using pointers or references, polymorphism works as intended. `s_ptr` and `s_ref` both refer to the *original* `Circle` object `c`. Because `print_type()` is `virtual`, calling it through these base pointers/references correctly dispatches to `Circle::print_type()`, printing 'I am a Circle.' This demonstrates that polymorphism relies on using base class pointers or references, not value copies, to preserve derived class behavior."
  },
  {
    "topic": "Inheritance and Polymorphism",
    "level": "Real World Problem",
    "title": "Employee Payroll System (Polymorphic Processing)",
    "description": "You are developing a payroll system for a company that has different types of employees (e.g., Salaried, Hourly, Commission). This problem demonstrates how to use inheritance and polymorphism to process different employee types uniformly through a common interface. \n\nYour task is to: \n1.  Define an **abstract base class** `Employee` with: \n    * **Private** member: `std::string name`. \n    * **Public** constructor `Employee(std::string name)`. \n    * **Public const getter**: `std::string get_name() const`. \n    * A **pure virtual function** `virtual double calculate_payroll() = 0;` \n    * A **pure virtual function** `virtual void print_details() const = 0;` \n    * A **virtual destructor** `virtual ~Employee() {}`. \n\n2.  Define three **concrete derived classes**: \n    * `SalariedEmployee` (inherits from `Employee`): \n        * **Private** member: `double weekly_salary`. \n        * Constructor. \n        * Overrides `calculate_payroll()` to return `weekly_salary`. \n        * Overrides `print_details()` to show name and weekly salary. \n    * `HourlyEmployee` (inherits from `Employee`): \n        * **Private** members: `double hourly_rate`, `int hours_worked`. \n        * Constructor. \n        * Overrides `calculate_payroll()` to return `hourly_rate * hours_worked`. \n        * Overrides `print_details()` to show name, rate, and hours. \n    * `CommissionEmployee` (inherits from `Employee`): \n        * **Private** members: `double base_salary`, `double sales_made`, `double commission_rate`. \n        * Constructor. \n        * Overrides `calculate_payroll()` to return `base_salary + (sales_made * commission_rate)`. \n        * Overrides `print_details()` to show name, base salary, sales, and commission. \n\n3.  In `main`: \n    * Create a `std::vector<Employee*>` to store pointers to various employee types. \n    * Dynamically create objects of `SalariedEmployee`, `HourlyEmployee`, and `CommissionEmployee` and add their pointers to the vector. \n    * Iterate through the `std::vector<Employee*>` using a loop. For each `Employee*`, call `print_details()` and `calculate_payroll()`, demonstrating polymorphic behavior. \n    * Finally, iterate again to `delete` all dynamically allocated `Employee` objects to prevent memory leaks. \n\nThis problem integrates abstract classes, virtual functions, inheritance, vectors of pointers, and memory management to simulate a flexible payroll system, demonstrating the power of polymorphism in real-world applications.",
    "constraints": "You must define `Employee` as an abstract base class with a `virtual` destructor and two pure virtual functions. You must define three concrete derived classes implementing these functions. `main` must use `std::vector<Employee*>` to store different employee types. Loop through the vector and call `print_details()` and `calculate_payroll()` polymorphically. Ensure all dynamically allocated memory is `delete`d. Format all currency outputs to two decimal places. No user input required.",
    "sampleInput": "None (logic hardcoded)",
    "sampleOutput": "--- Payroll Summary ---\nName: Alice (Salaried), Weekly Salary: $1000.00\nPayroll: $1000.00\n\nName: Bob (Hourly), Hourly Rate: $20.00, Hours Worked: 40\nPayroll: $800.00\n\nName: Charlie (Commission), Base Salary: $500.00, Sales: $2000.00, Commission Rate: 15.00%\nPayroll: $800.00\n\n--- Memory Cleanup ---\n",
    "explanation": "1.  **`Employee` Class:** Serves as the common interface for all employee types, defining `calculate_payroll()` and `print_details()` as pure virtual functions, ensuring all derived classes implement them. The `virtual` destructor ensures correct cleanup. \n2.  **Derived Classes:** Each derived class (`SalariedEmployee`, `HourlyEmployee`, `CommissionEmployee`) implements these virtual functions according to its specific payroll logic and detail printing needs. \n3.  **`main` Function:** A `std::vector<Employee*>` allows storing pointers to any `Employee`-derived object. When iterating and calling `employee->calculate_payroll()` or `employee->print_details()`, runtime polymorphism ensures that the *correct* overridden version (e.g., `SalariedEmployee::calculate_payroll()`, `HourlyEmployee::print_details()`) is called based on the *actual type* of the object pointed to. This demonstrates a flexible system where new employee types can be added without modifying the core payroll processing loop. Proper `delete` ensures memory safety."
  }
]