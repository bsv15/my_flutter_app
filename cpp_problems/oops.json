[
  {
    "topic": "Object-Oriented Programming",
    "level": "Easy",
    "title": "Basic Class Definition and Object Creation",
    "description": "This problem introduces the core concept of **classes and objects** in C++. A class is a blueprint for creating objects (instances), encapsulating data (member variables) and behavior (member functions). Your task is to: \n1.  Define a simple class named `Car`. \n2.  Inside the `Car` class, declare two **public** member variables: `std::string brand` and `int year`. \n3.  In your `main` function, create an object (instance) of the `Car` class. \n4.  Access its public member variables using the `.` operator and assign values to them (e.g., `myCar.brand = \"Toyota\";`). \n5.  Print the `brand` and `year` of your `Car` object. \nThis exercise is the most fundamental step in understanding OOP: defining a class and creating/accessing its objects.",
    "constraints": "You must define a class `Car` with at least `public std::string brand` and `public int year`. You must create a `Car` object in `main`. You must assign values to its members and print them. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Car Details:\nBrand: Toyota\nYear: 2022\n",
    "explanation": "A `Car` class is defined with public member variables `brand` and `year`. In `main`, a `Car` object named `myCar` is created. Values are assigned to `myCar.brand` and `myCar.year` using the dot operator. Finally, these values are printed from the `myCar` object."
  },
  {
    "topic": "Object-Oriented Programming",
    "level": "Easy",
    "title": "Class with Member Function",
    "description": "This problem extends basic class definition by adding **member functions** (methods), which define the behavior of objects of that class. Member functions operate on the object's data. Your task is to: \n1.  Define a class named `Dog`. \n2.  Inside the `Dog` class, declare a **private** member variable `std::string name` (demonstrating encapsulation). \n3.  Declare **public** member functions: \n    * A constructor `Dog(std::string dog_name)` that initializes the `name`. \n    * `void bark()`: Prints '[Dog Name] says Woof!'. \n    * `void set_name(std::string new_name)`: Sets the dog's name. \n    * `std::string get_name()`: Returns the dog's name. \n4.  In `main`, create a `Dog` object, call `bark()`, then `set_name()`, and call `bark()` again to show the updated name. \nThis exercise demonstrates constructors, private members, and public member functions for managing object data.",
    "constraints": "You must define a class `Dog` with `private std::string name`. You must implement a constructor, `bark()`, `set_name()`, and `get_name()` as public members. `main` must demonstrate creating an object, calling `bark`, updating name via `set_name`, and calling `bark` again. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Buddy says Woof!\nMax says Woof!\n",
    "explanation": "The `Dog` class is defined. `name` is private. The constructor initializes `name`. `bark()` uses `name` to print. `set_name()` modifies `name`. `get_name()` provides read access. In `main`, `dog1` is created, `bark()` is called. Then `set_name()` updates its name, and `bark()` is called again, reflecting the name change. This illustrates how member functions interact with private data."
  },
  {
    "topic": "Object-Oriented Programming",
    "level": "Easy",
    "title": "Using `this` Pointer in a Class",
    "description": "The **`this` pointer** is an implicit parameter to every non-static member function, pointing to the object for which the member function was called. It's often used to differentiate between member variables and function parameters that have the same name, or to return the current object. Your task is to: \n1.  Define a class named `Point`. \n2.  Inside `Point`, declare **private** member variables `int x` and `int y`. \n3.  Implement a constructor `Point(int x, int y)` that initializes these members. Use the `this` pointer to resolve ambiguity between member variables and parameters with the same names (e.g., `this->x = x;`). \n4.  Implement a public member function `void print_coords()` that prints the point's coordinates. \n5.  In `main`, create a `Point` object and call `print_coords()`. \nThis exercise clarifies the purpose and usage of the `this` pointer.",
    "constraints": "You must define a class `Point` with private `x` and `y`. The constructor must use `this->` to initialize member variables when parameter names clash. Implement `print_coords()` to display coordinates. `main` must create a `Point` object and call `print_coords()`. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Coordinates: (10, 20)\n",
    "explanation": "The `Point` class has private `x` and `y`. The constructor parameters are also named `x` and `y`. `this->x = x;` explicitly tells the compiler that the left `x` refers to the member variable of the current object (pointed to by `this`), and the right `x` refers to the parameter. This resolves the naming conflict. `print_coords` then accesses these members. In `main`, a `Point` object is created, and its coordinates are printed."
  },
  {
    "topic": "Object-Oriented Programming",
    "level": "Easy",
    "title": "Constructors and Destructors",
    "description": "This problem illustrates the role of **constructors** (special member functions that initialize objects upon creation) and **destructors** (special member functions that clean up resources when an object is destroyed). Your task is to: \n1.  Define a class named `ResourceUser`. \n2.  Implement a default constructor `ResourceUser()` that prints 'ResourceUser object created.' \n3.  Implement a destructor `~ResourceUser()` that prints 'ResourceUser object destroyed.' \n4.  In `main`, create a `ResourceUser` object. Observe when the constructor is called. \n5.  Then, create a scope block `{}` and inside it, create another `ResourceUser` object. Observe when its constructor and destructor are called, demonstrating its limited lifetime. \nThis exercise helps visualize object lifecycle and resource management.",
    "constraints": "You must define a class `ResourceUser`. It must have a public default constructor and a public destructor. The constructor must print 'ResourceUser object created.'. The destructor must print 'ResourceUser object destroyed.'. `main` must demonstrate object creation, and specifically, one object creation within a nested scope to show controlled destruction. No user input required.",
    "sampleInput": "None (logic hardcoded)",
    "sampleOutput": "ResourceUser object created.\nResourceUser object created.\nResourceUser object destroyed.\nResourceUser object destroyed.\n",
    "explanation": "The `ResourceUser` class has a constructor and destructor that print messages. \n1.  `ResourceUser obj1;` in `main` calls the constructor, printing 'ResourceUser object created.'. \n2.  The nested scope `{}` is entered. `ResourceUser obj2;` calls the constructor again, printing 'ResourceUser object created.'. \n3.  The nested scope ends. `obj2` goes out of scope, so its destructor `~ResourceUser()` is called, printing 'ResourceUser object destroyed.'. \n4.  `main` finishes. `obj1` goes out of scope, so its destructor `~ResourceUser()` is called, printing 'ResourceUser object destroyed.'. This accurately demonstrates object creation and destruction order based on scope."
  },
  {
    "topic": "Object-Oriented Programming",
    "level": "Medium",
    "title": "Encapsulation with Getters and Setters",
    "description": "This problem deepens the understanding of **encapsulation** by using private member variables and public 'getter' and 'setter' (mutator and accessor) functions to control access to data. This protects data integrity and provides an interface for interacting with objects. Your task is to: \n1.  Define a class named `BankAccount`. \n2.  Inside `BankAccount`, declare a **private** member variable `double balance`. \n3.  Implement **public** member functions: \n    * A constructor `BankAccount(double initial_balance)` that initializes `balance`. Enforce `initial_balance` to be non-negative (if negative, set to 0.0 and print a warning). \n    * `void deposit(double amount)`: Adds `amount` to `balance`. Only allow positive `amount`. \n    * `void withdraw(double amount)`: Subtracts `amount` from `balance`. Only allow positive `amount` and sufficient balance. \n    * `double get_balance() const`: Returns the `balance`. Make it `const` because it doesn't modify the object. \n4.  In `main`, create a `BankAccount` object, perform some deposits and withdrawals, and print the balance after each operation. \nThis problem emphasizes controlling data access and ensuring data validity through methods.",
    "constraints": "You must define a class `BankAccount` with `private double balance`. You must implement a constructor, `deposit`, `withdraw`, and `get_balance` (as `const`). Enforce validation rules (non-negative balance, positive deposit/withdrawal amounts, sufficient withdrawal balance). Print balance after each operation. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Initial balance: $1000.00\nDepositing $200.00. New balance: $1200.00\nWithdrawing $300.00. New balance: $900.00\nAttempted to withdraw $1000.00. Insufficient funds.\nCurrent balance: $900.00\nAttempted to deposit -50.00. Deposit amount must be positive.\nCurrent balance: $900.00\n",
    "explanation": "The `BankAccount` class encapsulates `balance` as private. \n* The constructor validates initial balance. \n* `deposit` and `withdraw` methods include checks for positive amounts and sufficient funds, printing appropriate messages if rules are violated, thus protecting the `balance` from invalid states. \n* `get_balance` provides read-only access. \nIn `main`, operations are performed, and the output demonstrates how the class methods enforce business rules and maintain the integrity of the `balance` data."
  },
  {
    "topic": "Object-Oriented Programming",
    "level": "Medium",
    "title": "Static Member Variables and Functions",
    "description": "This problem introduces **static member variables** and **static member functions**. A `static` member variable belongs to the class itself, not to any specific object, meaning all objects of that class share the same copy. A `static` member function can only access static member variables and static member functions; it does not have a `this` pointer and cannot access non-static members. They are often used for tracking class-level data (e.g., number of objects created) or for utility functions. Your task is to: \n1.  Define a class named `Counter`. \n2.  Inside `Counter`, declare a **private `static int` member variable** `count` (initialized to 0 outside the class definition). \n3.  Implement a **public constructor** `Counter()` that increments `count` each time a `Counter` object is created. \n4.  Implement a **public `static` member function** `int get_total_objects()` that returns the current value of `count`. \n5.  In `main`, create several `Counter` objects. Then, call `Counter::get_total_objects()` to print the total number of objects created, demonstrating that `count` is shared across all instances. \nThis problem illustrates class-level data and behavior using static members.",
    "constraints": "You must define a class `Counter`. It must have a `private static int count` (initialized to 0). The constructor must increment `count`. You must have a `public static int get_total_objects()` method. `main` must create multiple `Counter` objects and then call `Counter::get_total_objects()` to show the aggregate count. No user input required.",
    "sampleInput": "None (logic hardcoded)",
    "sampleOutput": "Counter object created.\nCounter object created.\nCounter object created.\nTotal Counter objects created: 3\n",
    "explanation": "The `Counter` class has a `static int count` member, shared by all `Counter` objects. It is initialized to 0 outside the class definition. \n* Each time a `Counter` object is created (e.g., `Counter obj1;`), its constructor increments `count`. \n* The `static` function `Counter::get_total_objects()` can be called directly using the class name (not an object), and it accesses the shared `static count` variable. \nThe output shows `count` correctly tracking the total number of `Counter` objects created, regardless of how many individual objects are instantiated."
  },
  {
    "topic": "Object-Oriented Programming",
    "level": "Medium",
    "title": "Copy Constructor and Assignment Operator",
    "description": "This problem introduces the **copy constructor** and the **copy assignment operator (`operator=`)**. These are special member functions that C++ provides by default, but you often need to define your own ('deep copy') when a class manages dynamic memory (pointers) to prevent shallow copies, dangling pointers, and double-free issues. While this problem won't explicitly require dynamic memory, it's a stepping stone to understanding these concepts. Your task is to: \n1.  Define a class named `MyString` that wraps a `std::string` member (e.g., `private std::string data;`). \n2.  Implement a constructor `MyString(const std::string& str)` to initialize `data`. \n3.  Implement a **copy constructor** `MyString(const MyString& other)` that prints 'Copy constructor called.' and copies `other.data` to `this->data`. \n4.  Implement a **copy assignment operator** `MyString& operator=(const MyString& other)` that prints 'Assignment operator called.' and correctly copies `other.data` to `this->data`, returning `*this`. Remember to handle self-assignment (`if (this != &other)`). \n5.  Implement a `void print()` method to print `data`. \n6.  In `main`, demonstrate: \n    * Object creation. \n    * Copy constructor usage (e.g., `MyString s2 = s1;` or `MyString s2(s1);`). \n    * Copy assignment operator usage (e.g., `MyString s3; s3 = s1;`). \n    * Pass-by-value to a function (which also invokes copy constructor). \n\nThis problem is crucial for understanding how objects are copied and assigned, especially relevant for classes with custom resource management.",
    "constraints": "You must define a class `MyString` with a `private std::string data`. Implement a constructor, copy constructor, copy assignment operator, and a `print()` method. The copy constructor and assignment operator *must* print their respective messages. Demonstrate all three forms of copying/assignment in `main`. No user input required.",
    "sampleInput": "None (logic hardcoded)",
    "sampleOutput": "Initial string: Hello\nCopy constructor called.\nCopied string (s2): Hello\nAssignment operator called.\nAssigned string (s3): Hello\nCopy constructor called.\nPassed by value: Hello\n",
    "explanation": "The `MyString` class is defined. \n* The constructor initializes `data`. \n* The copy constructor `MyString(const MyString& other)` is called when `s2` is initialized from `s1` (`MyString s2 = s1;` or `MyString s2(s1);`) and when `s1` is passed by value to `print_by_value`. It prints 'Copy constructor called.' and copies `other.data`. \n* The copy assignment operator `operator=(const MyString& other)` is called when `s3` (already existing) is assigned `s1` (`s3 = s1;`). It prints 'Assignment operator called.', handles self-assignment, and copies `other.data`. \nThis output clearly shows when each special member function is invoked during object copying and assignment."
  },
  {
    "topic": "Object-Oriented Programming",
    "level": "Hard",
    "title": "Friend Functions for Non-Member Access",
    "description": "This problem introduces **friend functions**, which are non-member functions (or member functions of another class) that are granted special permission to access a class's private and protected members. While breaking encapsulation, they are sometimes necessary for specific scenarios, such as operator overloading for mixed types or global utility functions that need direct access. Your task is to: \n1.  Define a class `Wallet` with a **private** `double balance`. \n2.  Implement a constructor `Wallet(double initial_balance)`. \n3.  Declare a **friend function** `void display_wallet_balance(const Wallet& w)` outside the class (or just its prototype inside the class with `friend`). This function should take a `const Wallet&` and be able to directly access `w.balance` to print it. \n4.  In `main`, create a `Wallet` object and call `display_wallet_balance` to print its balance. \n\nThis problem is hard because `friend` breaks the usual encapsulation rules and requires careful handling of function prototypes and definitions.",
    "constraints": "You must define a class `Wallet` with `private double balance`. The constructor must initialize `balance`. You must declare `display_wallet_balance` as a `friend` function within the `Wallet` class. The `display_wallet_balance` function must be a non-member function (defined outside the class) and directly access the `private balance` member. Print the balance formatted to two decimal places. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Wallet balance (via friend function): $500.75\n",
    "explanation": "The `Wallet` class declares `double balance` as private. The line `friend void display_wallet_balance(const Wallet& w);` inside the class grants the `display_wallet_balance` function (which is a regular non-member function) permission to access `Wallet`'s private members. When `display_wallet_balance(myWallet)` is called, it can directly access `w.balance` despite `balance` being private. This demonstrates how friend functions can bypass encapsulation for specific, controlled access."
  },
  {
    "topic": "Object-Oriented Programming",
    "level": "Hard",
    "title": "Constant Objects and Member Functions",
    "description": "This problem focuses on the concept of **`const` correctness** in C++ classes: marking objects as `const` and member functions as `const` to ensure data integrity and improve code safety. A `const` object cannot have its state modified, and only `const` member functions can be called on `const` objects. \n\nYour task is to: \n1.  Define a class `Book` with **private** members: `std::string title` and `std::string author`. \n2.  Implement a constructor `Book(const std::string& title, const std::string& author)`. \n3.  Implement a `const` member function `std::string get_title() const`: Returns the title. \n4.  Implement a `const` member function `std::string get_author() const`: Returns the author. \n5.  Implement a `const` member function `void print_details() const`: Prints the book's title and author. \n6.  Attempt to implement a non-`const` function (e.g., `void change_title(const std::string& new_title)`) and then: \n    * Create a **non-`const` `Book` object** and call `change_title`. Print its details. \n    * Create a **`const Book` object**. Attempt to call `change_title` on it (this should result in a compile error, which you should note in comments). Call only its `const` member functions (`print_details`, `get_title`, `get_author`). \n\nThis problem demonstrates how `const` affects objects and member functions, enforcing read-only access and preventing accidental modification.",
    "constraints": "You must define a class `Book` with private title/author. Implement a constructor and at least two `const` member functions (`get_title` and `print_details`). Implement one non-`const` member function (`change_title`). In `main`, create both a non-`const` and a `const` `Book` object. Demonstrate calling `change_title` on the non-`const` object. Attempt to call `change_title` on the `const` object (and describe/comment on the compile error). Show `const` functions working on `const` objects. No user input required.",
    "sampleInput": "None (logic hardcoded)",
    "sampleOutput": "Non-const book details:\nTitle: The Hobbit, Author: J.R.R. Tolkien\nChanging title...\nNew title: The Hobbit (Revised)\n\nConst book details:\nTitle: 1984, Author: George Orwell\n(Attempting to call change_title() on const_book would cause a compile-time error.)\n",
    "explanation": "The `Book` class is defined. Its `get_title`, `get_author`, and `print_details` methods are marked `const`, meaning they do not modify the object's state. `change_title` is *not* `const`. \n* `non_const_book` can call both `const` and non-`const` methods. `change_title` is called, modifying its title. \n* `const_book` is declared as `const`. This means it cannot have its state modified. Therefore, it can *only* call `const` member functions. An attempt to call `const_book.change_title(\"New Title\");` would result in a compile-time error (e.g., `error: passing 'const Book' as 'this' argument discards qualifiers`). This demonstrates `const` correctness: the compiler ensures you don't modify a `const` object."
  },
  {
    "topic": "Object-Oriented Programming",
    "level": "Tricky",
    "title": "Singleton Pattern (Static Members & Private Constructor)",
    "description": "The **Singleton design pattern** ensures that a class has only one instance and provides a global point of access to that instance. This is typically achieved using a combination of `static` members, a private constructor, and a static 'get instance' method. This problem is tricky because it requires careful control of object creation and lifetime. \n\nYour task is to: \n1.  Define a class `Logger` to implement the Singleton pattern. \n2.  Declare a **private static member** `Logger* instance_ptr = nullptr;`. \n3.  Declare a **private constructor** `Logger()`, which prints 'Logger instance created.' \n4.  Declare a **private copy constructor and copy assignment operator** to prevent copying (e.g., `Logger(const Logger&) = delete; Logger& operator=(const Logger&) = delete;`). \n5.  Implement a **public static member function** `Logger* get_instance()`: \n    * If `instance_ptr` is `nullptr`, create the *single* `Logger` object using `new Logger();` and assign it to `instance_ptr`. \n    * Return `instance_ptr`. \n6.  Implement a public member function `void log_message(const std::string& message)` that prints the message. \n7.  In `main`, call `Logger::get_instance()` multiple times and demonstrate that it always returns the same instance (e.g., by checking addresses or observing constructor output only once). Call `log_message` through the instance. \n\nThis problem deeply tests static members, access specifiers, and careful object lifecycle management to enforce a single instance.",
    "constraints": "You must implement the Singleton pattern for the `Logger` class. It must have a private static pointer `instance_ptr`. The constructor must be private. Copy constructor and assignment operator must be deleted (`= delete`). `get_instance()` must be a public static method that ensures only one instance is ever created and returned. `log_message` should print. `main` must call `get_instance` multiple times and demonstrate the single instance behavior. No user input required.",
    "sampleInput": "None (logic hardcoded)",
    "sampleOutput": "Logger instance created.\nLogger message: Application started.\nLogger message: User logged in.\n(Note: 'Logger instance created.' appears only once)\n",
    "explanation": "The `Logger` class uses the Singleton pattern. \n* The `instance_ptr` is `static` and `private`, ensuring only one pointer exists for the class. \n* The constructor is `private`, preventing direct object creation. \n* Copy constructor and assignment operator are `= delete;` to prevent accidental copying. \n* `get_instance()` is the only way to get a `Logger` object. The first time it's called, `instance_ptr` is `nullptr`, so `new Logger()` is executed, creating the single instance and calling its private constructor. Subsequent calls to `get_instance()` will find `instance_ptr` already pointing to the existing instance and simply return it. \nThe output clearly shows 'Logger instance created.' only once, confirming that only one object is ever instantiated, even with multiple `get_instance()` calls."
  },
  {
    "topic": "Object-Oriented Programming",
    "level": "Tricky",
    "title": "Operator Overloading: `+` for Complex Numbers",
    "description": "This problem introduces **operator overloading**, a powerful C++ feature that allows you to redefine how standard operators (like `+`, `-`, `*`, `=`, `<<`, etc.) behave when used with user-defined types (classes). This makes code more intuitive and readable. Your task is to: \n1.  Define a class `Complex` to represent complex numbers, with **private** `double real` and `double imag` members. \n2.  Implement a constructor `Complex(double r = 0.0, double i = 0.0)`. \n3.  **Overload the `+` operator** as a **non-member function** (`Complex operator+(const Complex& c1, const Complex& c2)`). This function should take two `Complex` objects by constant reference, add their real and imaginary parts respectively, and return a new `Complex` object representing the sum. You may need to declare this as a `friend` function if you can't use public getters/setters for real/imag parts. \n4.  Implement a public member function `void print() const` that prints the complex number in the format `(real + imag i)` (e.g., `(3.0 + 5.0i)`). \n5.  In `main`, create two `Complex` objects, add them using the overloaded `+` operator, and print the result. \n\nThis problem is tricky due to the syntax of operator overloading (especially as a non-member function) and ensuring correct arithmetic for custom types.",
    "constraints": "You must define a `Complex` class with private `real` and `imag` doubles. Implement a constructor and `print()` method. You must **overload the `+` operator** as a **non-member function** (or a friend function if private members are accessed directly). The overloaded operator must return a new `Complex` object. Print results clearly. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Complex Number 1: (3.00 + 4.00i)\nComplex Number 2: (1.50 + 2.50i)\nSum: (4.50 + 6.50i)\n",
    "explanation": "The `Complex` class stores `real` and `imag` parts. \n* The constructor initializes them. \n* The `print()` method displays the number. \n* The `operator+` is defined as a non-member function (or friend). It takes two `const Complex&` arguments. It accesses their `real` and `imag` parts (either directly if `friend`, or via getters if public getters exist) and constructs a new `Complex` object with the summed parts, which it then returns. \nIn `main`, `c3 = c1 + c2;` invokes the overloaded `operator+`, which calculates `(3.0 + 1.5)` for real and `(4.0 + 2.5)` for imag, resulting in `(4.5 + 6.5i)`, which is then printed."
  },
  {
    "topic": "Object-Oriented Programming",
    "level": "Real World Problem",
    "title": "Online Store: Product and Shopping Cart Classes",
    "description": "You are building a simplified model of an online store. This problem requires you to design multiple classes that interact with each other, demonstrating object composition, data encapsulation, and method interactions in a real-world scenario. \n\nYour task is to: \n1.  Define a `Product` class: \n    * **Private** members: `std::string name`, `double price`. \n    * **Public** constructor `Product(const std::string& name, double price)`. \n    * **Public const getters**: `get_name()`, `get_price()`. \n    * `void print_product_details() const`: Prints product name and price formatted to two decimal places. \n\n2.  Define a `ShoppingCart` class: \n    * **Private** member: `std::vector<Product> items;` (to store products). \n    * **Public** member function `void add_item(const Product& product)`: Adds a product to the cart. Prints 'Added [product name] to cart.'. \n    * **Public** member function `void remove_item(const std::string& product_name)`: Removes the first occurrence of a product with `product_name` from the cart. Prints 'Removed [product name] from cart.' or 'Product [product name] not found in cart.'. \n    * **Public** member function `double calculate_total() const`: Iterates through `items` and returns the sum of all product prices (formatted to two decimal places). \n    * **Public** member function `void view_cart() const`: Prints all items currently in the cart, or 'Cart is empty.' if no items. \n\n3.  In `main`, demonstrate the interaction: \n    * Create a few `Product` objects. \n    * Create a `ShoppingCart` object. \n    * Add products to the cart. \n    * View the cart. \n    * Calculate and print the total. \n    * Remove an item. \n    * View the cart again. \n\nThis problem integrates multiple OOP concepts: class design, constructors, getters, encapsulation, data storage (`std::vector`), and inter-object communication to model a practical system.",
    "constraints": "You must define `Product` and `ShoppingCart` classes with specified members and functions. Use `std::vector<Product>` in `ShoppingCart`. Implement all methods as described. Print prices and totals formatted to two decimal places (`std::fixed`, `std::setprecision(2)`). All interactions in `main` must demonstrate the correct functionality. No user input required.",
    "sampleInput": "None (logic hardcoded)",
    "sampleOutput": "Created Products:\nName: Laptop, Price: $1200.00\nName: Mouse, Price: $25.50\nName: Keyboard, Price: $75.00\n\nAdding items to cart...\nAdded Laptop to cart.\nAdded Mouse to cart.\nAdded Keyboard to cart.\n\n--- Your Shopping Cart ---\nLaptop ($1200.00)\nMouse ($25.50)\nKeyboard ($75.00)\nTotal: $1300.50\n\nRemoving Mouse...\nRemoved Mouse from cart.\n\n--- Your Shopping Cart ---\nLaptop ($1200.00)\nKeyboard ($75.00)\nTotal: $1275.00\n",
    "explanation": "1.  **`Product` Class:** Encapsulates `name` and `price`. Provides a constructor and `const` getters, along with a `print_product_details` for displaying itself. \n2.  **`ShoppingCart` Class:** Holds a `std::vector<Product>` (`items`). \n    * `add_item` uses `push_back()` to add products. \n    * `remove_item` iterates to find the product by name and uses `items.erase()` to remove it. \n    * `calculate_total` iterates through `items` and sums prices. \n    * `view_cart` iterates and prints each item. \n\nIn `main`, products are created. They are added to the `cart` which stores copies (or moves) of them. The `view_cart`, `calculate_total`, and `remove_item` methods are called, demonstrating how these objects interact to manage the cart's state and provide relevant information. All financial outputs are formatted."
  }
]