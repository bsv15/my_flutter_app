[
  {
    "topic": "Exception Handling and Templates",
    "level": "Easy",
    "title": "Basic Exception Handling: Divide by Zero",
    "description": "This problem introduces basic **exception handling** using `try`, `throw`, and `catch` blocks. Exceptions are a mechanism to deal with runtime errors gracefully, separating error-handling code from normal program logic. Your task is to write a C++ program that prompts the user to enter two integers, `numerator` and `denominator`. Implement a division operation. If the `denominator` is 0, `throw` an `std::runtime_error` exception with an informative message. Otherwise, calculate the division result. Wrap the division logic in a `try` block and `catch` the `std::runtime_error`, printing the exception's message. Print the result if no exception occurs. This is the simplest demonstration of throwing and catching a standard exception.",
    "constraints": "You must use `std::cin` for two integer inputs. You must `throw` an `std::runtime_error` if `denominator` is 0. You must use a `try-catch` block to handle the exception. Print the division result (as `double`) or the error message. Assume valid integer inputs.",
    "sampleInput": "Enter numerator: 10\nEnter denominator: 0",
    "sampleOutput": "Enter numerator: 10\nEnter denominator: 0\nError: Division by zero is not allowed.\n",
    "explanation": "The program prompts for two numbers. Inside the `try` block, it checks if `denominator` is 0. If it is, `std::runtime_error(\"Division by zero is not allowed.\")` is `throw`n. This immediately transfers control to the `catch (const std::runtime_error& e)` block, which then prints the message contained within the exception object (`e.what()`). If the denominator were non-zero, the division would proceed, and the result would be printed."
  },
  {
    "topic": "Exception Handling and Templates",
    "level": "Easy",
    "title": "Function Template for Max Value",
    "description": "This problem introduces **function templates**, a core feature of C++ that allows you to write generic functions that can operate on different data types without rewriting the entire function for each type. The compiler generates specific versions of the function at compile time based on the types used in calls. Your task is to define a **function template** named `get_max` that takes two parameters of the same type `T` and returns the larger of the two. In your `main` function, call `get_max` with `int` values, then with `double` values, and finally with `std::string` values. Print the result of each call. This demonstrates how a single template can work with multiple types.",
    "constraints": "You must define a **function template** `get_max`. It must take two parameters of the same generic type `T` and return `T`. The function should correctly return the maximum of the two values. In `main`, call `get_max` with `int`, `double`, and `std::string` types. Print the results clearly. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Max of 10 and 20 is: 20\nMax of 5.5 and 3.2 is: 5.5\nMax of 'Apple' and 'Banana' is: Banana\n",
    "explanation": "The `get_max` function is defined as a template `template <typename T> T get_max(T a, T b)`. \n1.  When `get_max(10, 20)` is called, the compiler instantiates `int get_max(int, int)`. \n2.  When `get_max(5.5, 3.2)` is called, it instantiates `double get_max(double, double)`. \n3.  When `get_max(\"Apple\", \"Banana\")` is called, it instantiates `std::string get_max(std::string, std::string)` (strings are compared lexicographically). \nIn each case, the correct comparison (`>`) is used for the respective type, and the larger value is returned and printed."
  },
  {
    "topic": "Exception Handling and Templates",
    "level": "Easy",
    "title": "Catching Multiple Standard Exceptions",
    "description": "This problem expands on exception handling by demonstrating how to `catch` different types of standard exceptions. It's common for a single `try` block to have code that can `throw` various exceptions. Your task is to write a C++ program that prompts the user to enter two numbers: `num_str` (as a string) and `divisor` (as an integer). \n1.  Attempt to convert `num_str` to an `int` using `std::stoi()`. This can throw `std::invalid_argument` or `std::out_of_range`. \n2.  If conversion is successful, attempt to divide the converted number by `divisor`. If `divisor` is 0, `throw` an `std::runtime_error`. \n3.  Use multiple `catch` blocks to handle: \n    * `std::invalid_argument` (for `stoi` conversion errors like 'abc'). \n    * `std::out_of_range` (for `stoi` overflow errors). \n    * `std::runtime_error` (for division by zero). \n4.  Include a general `catch (const std::exception& e)` for any other standard exceptions, and a `catch (...)` for any unknown exceptions. \nPrint specific messages for each caught exception type or the division result. This problem reinforces structured exception handling.",
    "constraints": "You must use `std::cin` for string and integer inputs. You must use `std::stoi()`. You must `throw std::runtime_error` for division by zero. You must use multiple `catch` blocks for `std::invalid_argument`, `std::out_of_range`, `std::runtime_error`, `std::exception`, and `...`. Print specific messages for each case. Assume valid input for `divisor` unless it's 0.",
    "sampleInput": "Enter number string: abc\nEnter divisor: 5",
    "sampleOutput": "Enter number string: abc\nEnter divisor: 5\nCaught exception: Invalid argument for number conversion.\n",
    "explanation": "The program reads 'abc' and 5. Inside the `try` block, `std::stoi(\"abc\")` is attempted. This throws an `std::invalid_argument` exception because 'abc' is not a valid integer string. Control transfers to `catch (const std::invalid_argument& e)`, which prints the specific error message for invalid argument."
  },
  {
    "topic": "Exception Handling and Templates",
    "level": "Easy",
    "title": "Class Template for Pair (Generic Tuple)",
    "description": "This problem introduces **class templates**, which allow you to define generic classes that can work with any data type. This is incredibly useful for creating reusable data structures. Your task is to define a **class template** named `Pair` that can hold two values of potentially different types. \n1.  The `Pair` class should be templated on two types, `T1` and `T2` (e.g., `template <typename T1, typename T2> class Pair`). \n2.  It should have two public member variables: `first` (of type `T1`) and `second` (of type `T2`). \n3.  Include a constructor to initialize `first` and `second`. \n4.  In `main`, create three `Pair` objects: \n    * `Pair<int, double>` \n    * `Pair<std::string, int>` \n    * `Pair<char, char>` \n5.  Initialize them with some values and print their contents. This problem demonstrates creating and using a generic data structure.",
    "constraints": "You must define a **class template** named `Pair` templated on two types (`T1`, `T2`). It must have public member variables `first` and `second`. It must have a constructor to initialize these members. In `main`, instantiate `Pair` with at least three different type combinations and print their contents. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Pair 1: (10, 20.5)\nPair 2: (Hello, 123)\nPair 3: (X, Y)\n",
    "explanation": "The `Pair` class is defined as a class template, allowing its members `first` and `second` to be of any specified types `T1` and `T2`. In `main`, different `Pair` objects are instantiated: `Pair<int, double>`, `Pair<std::string, int>`, and `Pair<char, char>`. For each, the constructor is used to initialize the values, and then their contents are accessed directly (as they are public) and printed. The compiler generates specific versions of the `Pair` class for each combination of types used."
  },
  {
    "topic": "Exception Handling and Templates",
    "level": "Medium",
    "title": "Custom Exception Class: InvalidInputException",
    "description": "Beyond standard exceptions, C++ allows you to define **custom exception classes** for more specific error conditions. This improves clarity and makes error handling more precise. Your task is to: \n1.  Define a custom exception class named `InvalidInputException` that inherits from `std::runtime_error`. \n2.  Give `InvalidInputException` a constructor that takes a `const char*` message and passes it to the base `std::runtime_error` constructor. \n3.  In `main`, prompt the user to enter a positive integer. \n4.  If the user enters a non-positive integer (0 or negative), `throw` an `InvalidInputException`. \n5.  Otherwise, print 'Valid input: [number]'. \n6.  Use a `try-catch` block to `catch` the `InvalidInputException` specifically, printing its message (using `e.what()`). \nThis problem demonstrates creating and throwing your own exception types.",
    "constraints": "You must define a custom class `InvalidInputException` inheriting from `std::runtime_error`. Its constructor must take a `const char*` message. You must `throw` this custom exception for non-positive integer input. You must use `std::cin` for input. You must use a `try-catch` block to catch `InvalidInputException` specifically. Print valid input or the exception message. Assume integer input.",
    "sampleInput": "Enter a positive integer: -5",
    "sampleOutput": "Enter a positive integer: -5\nCaught exception: Input must be a positive integer.\n",
    "explanation": "A custom `InvalidInputException` class is defined, inheriting from `std::runtime_error`. In `main`, the `try` block prompts for input. If the input is `-5`, the `if (num <= 0)` condition is true, and `InvalidInputException(\"Input must be a positive integer.\")` is `throw`n. This transfers control to `catch (const InvalidInputException& e)`, which prints the custom error message using `e.what()`."
  },
  {
    "topic": "Exception Handling and Templates",
    "level": "Medium",
    "title": "Class Template for a Generic Stack",
    "description": "This problem reinforces **class templates** by having you implement a basic generic data structure: a `Stack`. A stack is a Last-In, First-Out (LIFO) data structure. Your task is to: \n1.  Define a **class template** named `Stack` that can hold elements of any type `T`. \n2.  Internally, the `Stack` should use a `std::vector<T>` to store its elements. \n3.  Implement the following public methods: \n    * `void push(T item)`: Adds `item` to the top of the stack. \n    * `T pop()`: Removes and returns the top element. **Throw an `std::out_of_range` exception if the stack is empty.** \n    * `T peek() const`: Returns the top element without removing it. **Throw an `std::out_of_range` exception if the stack is empty.** \n    * `bool is_empty() const`: Returns `true` if the stack is empty, `false` otherwise. \n4.  In `main`, demonstrate creating a `Stack<int>` and a `Stack<std::string>`. Perform several `push`, `pop`, `peek`, and `is_empty` operations, including one that attempts to `pop` from an empty stack (and catch the exception). This problem is a practical application of templates for data structures.",
    "constraints": "You must define a **class template** `Stack<T>`. It must use `std::vector<T>` internally. Implement `push`, `pop`, `peek`, `is_empty` methods. `pop` and `peek` must `throw std::out_of_range` if the stack is empty. In `main`, demonstrate usage with at least two different data types. Show both successful operations and caught exceptions. No user input required.",
    "sampleInput": "None (logic hardcoded in main)",
    "sampleOutput": "Integer Stack:\nPushing 10, 20, 30\nTop element: 30\nPopped: 30\nTop element: 20\nStack empty? false\nPopped: 20\nPopped: 10\nStack empty? true\nAttempting to pop from empty stack...\nCaught exception: pop from empty stack\n",
    "explanation": "A `Stack` class template is defined using `std::vector<T>` internally. `push` uses `vec.push_back`. `pop` and `peek` check for `vec.empty()` and `throw std::out_of_range` if true; otherwise, they access/remove the last element. \nIn `main`: \n1.  An `Stack<int>` is created, integers are pushed, peeked, and popped successfully. \n2.  Finally, `pop` is called when the stack is empty. This triggers the `throw std::out_of_range` inside `pop`. \n3.  The `catch` block in `main` catches this specific exception and prints its message, demonstrating robust error handling for the custom stack."
  },
  {
    "topic": "Exception Handling and Templates",
    "level": "Medium",
    "title": "Template Function with Constraints (C++20 Concepts)",
    "description": "This problem introduces **C++20 Concepts** (or equivalent template metaprogramming for older C++ versions), which allow you to specify constraints on template parameters. This makes template errors more readable and ensures that template functions are only instantiated with types that support the required operations. Your task is to: \n1.  Define a **function template** `print_and_add_one` that takes a parameter of type `T`. \n2.  This template should only compile if `T` supports: \n    * Output to `std::cout` (using `operator<<`). \n    * The pre-increment operator (`++prefix`). \n3.  Inside the function, print the value, then pre-increment it, and print the new value. \n4.  In `main`, call `print_and_add_one` with: \n    * An `int`. \n    * A `double`. \n    * A `std::string` (which typically doesn't support `++` for this purpose, so it *should* cause a compilation error if not constrained, or you can make it print an error at runtime). \n\n**Note for older C++:** If you don't have C++20 support for `requires` clauses, you can simulate constraints by defining separate overloads or by using `static_assert` within the template, which will produce compilation errors for incompatible types. The focus is demonstrating that only compatible types can use the function. For the `std::string` case, if not using Concepts, you might need to *demonstrate* the compilation error, or have it compile but result in unexpected behavior, or specifically exclude it if it's too complex.",
    "constraints": "You must define a function template `print_and_add_one<T>`. For C++20, use `requires` clause to constrain `T` to types supporting `operator<<` and `++T`. For older C++, explain how you would constrain or demonstrate compilation failure for incompatible types. Inside the function, print the value, increment it, and print the new value. In `main`, call with `int`, `double`. For `std::string`, either show compile error (preferred for Concepts) or explain why it would fail/how to handle it if concepts are not used. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Processing integer:\nValue: 5, Incremented value: 6\nProcessing double:\nValue: 3.14, Incremented value: 4.14\n",
    "explanation": "The `print_and_add_one` function template is defined using a C++20 `requires` clause to ensure `T` supports `operator<<` and prefix `++`. \n1.  When called with an `int` (5), the template instantiates `print_and_add_one<int>`, which works as expected. \n2.  When called with a `double` (3.14), the template instantiates `print_and_add_one<double>`, which also works. \n3.  (Implicitly) If called with `std::string`, the `requires` clause would prevent compilation because `std::string` does not have a `++` operator in this context, demonstrating how concepts enforce type requirements at compile time, leading to clearer error messages than traditional SFINAE (Substitution Failure Is Not An Error)."
  },
  {
    "topic": "Exception Handling and Templates",
    "level": "Hard",
    "title": "Resource Management with RAII (File Wrapper)",
    "description": "This problem combines exception handling with the **Resource Acquisition Is Initialization (RAII)** principle. RAII is a C++ idiom where resource management (like file opening/closing, memory allocation/deallocation) is tied to object lifetime. Resources are acquired in a constructor and released in a destructor, ensuring cleanup even if exceptions are thrown. Your task is to: \n1.  Define a class `FileHandler` that manages a file stream. \n2.  Its constructor should take a `const std::string& filename` and an `std::ios_base::openmode mode` (e.g., `std::ios::out`). It should open the specified file. If the file fails to open, **throw an `std::runtime_error`**. \n3.  Its destructor should close the file if it's open. \n4.  Add a public method `void write_line(const std::string& line)` that writes a line to the file. If the file is not open, it should throw an `std::runtime_error`. \n5.  In `main`, use a `try-catch` block: \n    * Inside `try`, create an `FileHandler` object to open a file (e.g., `data.txt`). \n    * Call `write_line` multiple times. \n    * Demonstrate error handling by trying to open an invalid file path or write to a closed stream (you might need a separate `main` or a specific test case for this). \nThis problem emphasizes robust resource management, critical for reliable applications.",
    "constraints": "You must define a class `FileHandler`. Its constructor must open a file and throw `std::runtime_error` on failure. Its destructor must close the file. It must have a `write_line` method that throws `std::runtime_error` if the file is not open. Use `std::ofstream` internally. In `main`, use a `try-catch` block to demonstrate `FileHandler`'s RAII and error handling. No user input required.",
    "sampleInput": "None (logic hardcoded)",
    "sampleOutput": "Attempting to write to 'my_log.txt'...\nWriting line 1.\nWriting line 2.\nFile operations successful. File closed automatically.\n",
    "explanation": "The `FileHandler` class encapsulates an `std::ofstream`. Its constructor attempts to open the file; if it fails, it throws `std::runtime_error`. The destructor automatically closes the file, guaranteeing resource release even if an exception occurs after opening. The `write_line` method checks if the file is open before writing. \nIn `main`, `FileHandler myFile(\"my_log.txt\", std::ios::out);` creates the object. If `my_log.txt` cannot be opened, the constructor throws. If successful, `write_line` is called. When `myFile` goes out of scope (either normally or due to an exception leaving the `try` block), its destructor is automatically called, closing the file. This demonstrates RAII ensuring proper file closure."
  },
  {
    "topic": "Exception Handling and Templates",
    "level": "Hard",
    "title": "Generic Data Processor with Policy Template",
    "description": "This problem introduces a more advanced use of **templates: the Policy-based Design pattern**. This pattern allows a class template to customize its behavior by taking another class (a 'policy') as a template parameter. This is a powerful way to achieve compile-time polymorphism and flexible, reusable code. Your task is to: \n1.  Define a **Policy** class `UpperCasePolicy` with a static method `std::string process(const std::string& text)` that converts the text to uppercase. \n2.  Define another **Policy** class `LowerCasePolicy` with a static method `std::string process(const std::string& text)` that converts the text to lowercase. \n3.  Define a **Class Template** `DataProcessor` that takes a `Policy` type as a template parameter (`template <typename ProcessingPolicy> class DataProcessor`). \n4.  `DataProcessor` should have a method `std::string process_data(const std::string& input_data)` that uses the `Policy::process` static method to transform the `input_data`. \n5.  In `main`, demonstrate using `DataProcessor<UpperCasePolicy>` and `DataProcessor<LowerCasePolicy>` to process the same input string, printing the results. \n\nThis problem is tricky as it requires understanding how template parameters can be types that define specific interfaces (the policy), leading to highly customizable compile-time behavior.",
    "constraints": "You must define two policy classes: `UpperCasePolicy` and `LowerCasePolicy`. Each policy must have a `static std::string process(const std::string&)` method. You must define a class template `DataProcessor<ProcessingPolicy>`. `DataProcessor` must have a method `process_data` that calls the policy's `process` method. In `main`, instantiate and use `DataProcessor` with both policies on the same input string. Print the transformed strings. No user input required. You may need to include `<cctype>` for `toupper`/`tolower`.",
    "sampleInput": "None (logic hardcoded)",
    "sampleOutput": "Original string: Hello World\nProcessed by UpperCasePolicy: HELLO WORLD\nProcessed by LowerCasePolicy: hello world\n",
    "explanation": "Two policy classes, `UpperCasePolicy` and `LowerCasePolicy`, are defined, each providing a static `process` method that transforms a string. The `DataProcessor` class template is defined to take a `ProcessingPolicy` type. Its `process_data` method simply calls the `process` static method of the given `Policy` type. \nIn `main`: \n1.  `DataProcessor<UpperCasePolicy> upperProcessor;` instantiates `DataProcessor` with `UpperCasePolicy`. When `upperProcessor.process_data(\"Hello World\")` is called, it effectively calls `UpperCasePolicy::process(\"Hello World\")`, resulting in 'HELLO WORLD'. \n2.  Similarly, `DataProcessor<LowerCasePolicy> lowerProcessor;` instantiates it with `LowerCasePolicy`, leading to 'hello world'. \nThis demonstrates how the behavior of `DataProcessor` is 'injected' at compile time by the template parameter, a powerful form of compile-time polymorphism."
  },
  {
    "topic": "Exception Handling and Templates",
    "level": "Tricky",
    "title": "Function Template for Generic Sorting (Bubble Sort)",
    "description": "Implementing a generic sorting algorithm using a function template is a classic way to demonstrate template power. This problem focuses on applying the **Bubble Sort algorithm** (simple but illustrates generic sorting) to different data types. Your task is to: \n1.  Define a **function template** `bubble_sort` that takes a `std::vector<T>&` as a parameter. \n2.  Implement the Bubble Sort algorithm within this template function to sort the elements in ascending order. \n3.  In `main`, create two `std::vector`s: one `std::vector<int>` and one `std::vector<double>`, each with at least 5 unsorted elements. \n4.  Call `bubble_sort` on both vectors. \n5.  Print the vectors before and after sorting. \n\nThis problem is tricky due to the need for a general comparison (`<` operator) that works for any `T`, and correctly iterating and swapping elements within a generic `std::vector`. It highlights `operator<` being required for template types.",
    "constraints": "You must define a function template `bubble_sort` taking `std::vector<T>&`. You must implement the Bubble Sort algorithm. The sorting must be in ascending order. In `main`, use `bubble_sort` on both `std::vector<int>` and `std::vector<double>`. Print vectors before and after sorting. No user input required. Assumes `T` supports `operator<` and `operator=` (for swapping).",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Original Integers: 5 2 8 1 9\nSorted Integers: 1 2 5 8 9\n\nOriginal Doubles: 3.1 1.5 4.2 2.7 0.9\nSorted Doubles: 0.9 1.5 2.7 3.1 4.2\n",
    "explanation": "The `bubble_sort` function template is defined to accept a `std::vector<T>&`. It implements the standard Bubble Sort logic using nested `for` loops and `std::swap` (or manual swapping) to exchange adjacent elements if they are in the wrong order. \nIn `main`: \n1.  An `std::vector<int>` is created and initialized. `bubble_sort` is called on it, and the sorted vector is printed. \n2.  An `std::vector<double>` is created and initialized. `bubble_sort` is called on it, and the sorted vector is printed. \nThe compiler generates two distinct versions of `bubble_sort` (one for `int`, one for `double`), demonstrating template specialization based on the provided type argument."
  },
  {
    "topic": "Exception Handling and Templates",
    "level": "Tricky",
    "title": "Exception Specification with `noexcept` (C++11 and later)",
    "description": "This problem explores `noexcept` (C++11 and later), a modern C++ keyword used to indicate that a function will not throw any exceptions. This provides important optimization hints to the compiler and clarifies intent. If a `noexcept` function *does* throw an exception, the program is terminated via `std::terminate()`. Your task is to: \n1.  Define a function `void may_throw_func(int val)` that: \n    * Prints 'Inside may_throw_func'. \n    * If `val == 0`, `throw`s an `std::runtime_error`. \n    * Otherwise, prints 'Value is not zero.'. \n2.  Define a second function `void noexcept_func(int val) noexcept` that is marked `noexcept`. \n    * Inside `noexcept_func`, call `may_throw_func(val)`. \n    * **Crucially:** Do NOT put a `try-catch` inside `noexcept_func`. \n3.  In `main`, use a `try-catch` block around a call to `noexcept_func` where `val == 0`. \n4.  Observe the program's behavior: it should terminate (not catch the exception) because a `noexcept` function threw. \n5.  Then, call `noexcept_func` with a non-zero value to show normal execution. \n\nThis problem is tricky because it forces you to understand the strict guarantee `noexcept` provides and the consequence of violating it (`std::terminate`).",
    "constraints": "You must define `void may_throw_func(int)` that throws `std::runtime_error` if `val == 0`. You must define `void noexcept_func(int) noexcept` that calls `may_throw_func`. `noexcept_func` must NOT have a `try-catch` block. In `main`, call `noexcept_func` with `0` (expecting termination) and with a non-zero value (expecting normal execution). Print relevant messages. You must use `noexcept` keyword. Explain the termination. No user input required.",
    "sampleInput": "None (logic hardcoded)",
    "sampleOutput": "Calling noexcept_func with 5:\nInside may_throw_func\nValue is not zero.\nNormal execution continued after non-throwing call.\n\nCalling noexcept_func with 0 (this should terminate the program):\nInside may_throw_func\n// Program terminates here due to std::terminate()\n",
    "explanation": "The `may_throw_func` is a regular function that can throw an `std::runtime_error`. The `noexcept_func` is marked with `noexcept`, guaranteeing to the compiler that it won't throw. \n1.  When `noexcept_func(5)` is called, `may_throw_func(5)` executes normally, prints 'Value is not zero.', and `noexcept_func` returns without issue. \n2.  When `noexcept_func(0)` is called, `may_throw_func(0)` *throws* `std::runtime_error`. Because `noexcept_func` is `noexcept` and it allows an exception to propagate out of it, the C++ runtime immediately calls `std::terminate()`, which by default calls `abort()`, crashing the program. The `catch` block in `main` is *not* reached, demonstrating the strong guarantee (and consequence) of `noexcept`."
  },
  {
    "topic": "Exception Handling and Templates",
    "level": "Real World Problem",
    "title": "Generic Data Analytics Tool with Error Reporting",
    "description": "You are building a generic data analytics tool that can perform various operations (e.g., sum, average, min, max) on different types of numeric data (`int`, `double`). This tool needs to be robust, reporting errors like empty data sets. This problem combines **class templates** for generic data processing and **custom exceptions** for structured error reporting. \n\nYour task is to: \n1.  Define a custom exception class `DataAnalyticsException` that inherits from `std::runtime_error`. It should take a message in its constructor. \n2.  Define a **class template** `AnalyticsProcessor<T>` that operates on `std::vector<T>` data. \n3.  `AnalyticsProcessor<T>` should have a private `std::vector<T> data_set;` and a constructor that takes `const std::vector<T>& initial_data`. \n4.  Implement the following public methods in `AnalyticsProcessor<T>`: \n    * `T calculate_sum()`: Returns the sum of elements. **Throws `DataAnalyticsException` if `data_set` is empty.** \n    * `double calculate_average()`: Returns the average. **Throws `DataAnalyticsException` if `data_set` is empty.** \n    * `T find_max()`: Returns the maximum element. **Throws `DataAnalyticsException` if `data_set` is empty.** \n5.  In `main`, demonstrate: \n    * Creating `AnalyticsProcessor<int>` and `AnalyticsProcessor<double>` with non-empty data. Call all calculation methods and print results. \n    * Creating `AnalyticsProcessor<int>` with an *empty* vector. Call a calculation method within a `try-catch` block to demonstrate `DataAnalyticsException` being caught. \n\nThis problem integrates generic programming for reusability with robust error handling for real-world data processing scenarios.",
    "constraints": "You must define a custom exception `DataAnalyticsException` inheriting from `std::runtime_error`. You must define a **class template** `AnalyticsProcessor<T>`. It must use `std::vector<T>` internally. Implement `calculate_sum`, `calculate_average`, `find_max` (or similar standard analytics operations). All calculation methods must throw `DataAnalyticsException` if the `data_set` is empty. In `main`, demonstrate both successful calculations and catching `DataAnalyticsException` from an empty data set. Print all results and error messages clearly. Assume `T` supports arithmetic operations and comparisons. No user input required.",
    "sampleInput": "None (logic hardcoded)",
    "sampleOutput": "Integer Data Analysis:\nSum: 35\nAverage: 7.00\nMax: 10\n\nDouble Data Analysis:\nSum: 22.20\nAverage: 5.55\nMax: 8.80\n\nAttempting to analyze empty data set:\nCaught data analytics error: Cannot calculate sum on empty data set.\n",
    "explanation": "A custom `DataAnalyticsException` is defined. The `AnalyticsProcessor<T>` class template is created. Its constructor takes an initial vector. Methods like `calculate_sum`, `calculate_average`, `find_max` first check if `data_set` is empty; if so, they `throw DataAnalyticsException`. Otherwise, they perform their respective calculations. \nIn `main`: \n1.  `AnalyticsProcessor<int>` is created with `int` data. Sum, average, and max are successfully calculated and printed. \n2.  `AnalyticsProcessor<double>` is created with `double` data. Sum, average, and max are successfully calculated and printed (average formatted to two decimal places). \n3.  An `AnalyticsProcessor<int>` is created with an *empty* vector. When `calculate_sum()` is called, it `throws DataAnalyticsException`. \n4.  The `catch (const DataAnalyticsException& e)` block in `main` catches this exception, printing its specific error message, demonstrating robust error handling for data validity."
  }
]