[
  {
    "topic": "STL and Containers",
    "level": "Easy",
    "title": "Use `std::vector` for a Dynamic List",
    "description": "This problem introduces `std::vector`, one of the most commonly used containers from the C++ Standard Template Library (STL). `std::vector` is a dynamic array that can grow or shrink in size, making it highly flexible. Your task is to: \n1.  Declare an empty `std::vector<std::string>`. \n2.  Prompt the user to enter 3 of their favorite fruits, one by one. Add each fruit to the vector using `push_back()`. \n3.  After collecting all inputs, iterate through the vector using a **range-based `for` loop** and print each fruit on a new line, along with its 1-indexed position (e.g., '1. Apple', '2. Banana'). \nThis exercise covers basic `std::vector` creation, element addition, and iterating over its contents.",
    "constraints": "You must use `std::vector<std::string>`. You must use `std::cin` to get 3 string inputs. You must use `push_back()` to add elements. You must use a range-based `for` loop for printing. Print each fruit with a 1-indexed number. Assume single-word fruit names.",
    "sampleInput": "Enter fruit 1: Apple\nEnter fruit 2: Banana\nEnter fruit 3: Cherry",
    "sampleOutput": "Enter fruit 1: Apple\nEnter fruit 2: Banana\nEnter fruit 3: Cherry\nYour favorite fruits:\n1. Apple\n2. Banana\n3. Cherry\n",
    "explanation": "An empty `std::vector<std::string>` is declared. A `for` loop prompts the user for 3 fruits, and `push_back()` adds each input string to the vector. Then, a range-based `for` loop, along with a counter, iterates through the `fruits` vector, printing each fruit with its sequential number."
  },
  {
    "topic": "STL and Containers",
    "level": "Easy",
    "title": "Use `std::map` for Key-Value Pairs",
    "description": "This problem introduces `std::map`, an associative container that stores elements in key-value pairs. Each key is unique and used to retrieve its associated value. `std::map` elements are sorted by key. Your task is to: \n1.  Declare a `std::map<std::string, int>` to store country populations (Country Name -> Population). \n2.  Insert at least three key-value pairs into the map (e.g., 'USA' -> 330000000, 'China' -> 1400000000). \n3.  Prompt the user to enter a country name. \n4.  Check if the country exists in the map. If it does, print its population. If not, print 'Country not found.'. \nThis exercise demonstrates basic `std::map` usage: insertion and lookup.",
    "constraints": "You must use `std::map<std::string, int>`. Insert at least 3 pairs. Use `std::cin` for country name input. Use `map.count()` or `map.find()` for lookup. Print the population if found, or 'Country not found.'. Assume single-word country names for input.",
    "sampleInput": "Enter country name to lookup: India",
    "sampleOutput": "Enter country name to lookup: India\nCountry not found.\n",
    "explanation": "A `std::map<std::string, int>` is declared and populated. The program prompts for a country name. `country_populations.count(search_country)` checks if the key exists. If `count()` returns 1 (meaning it exists), `country_populations[search_country]` accesses and prints the associated value. Otherwise, 'Country not found.' is printed."
  },
  {
    "topic": "STL and Containers",
    "level": "Easy",
    "title": "Use `std::set` for Unique Elements",
    "description": "This problem introduces `std::set`, an associative container that stores unique elements in a sorted order. It's ideal for tasks where you need to maintain a collection of distinct items. Your task is to: \n1.  Declare a `std::set<int>`. \n2.  Insert several integer values into the set, including some duplicates (e.g., 5, 2, 8, 2, 5, 1). \n3.  After insertion, iterate through the set using a range-based `for` loop and print its elements. Observe that duplicates are automatically handled and elements are sorted. \n4.  Check if a specific number (e.g., 8) is present in the set using `set.count()` or `set.find()`, and print a corresponding message. \nThis exercise covers `std::set`'s automatic uniqueness and sorting, as well as element checking.",
    "constraints": "You must use `std::set<int>`. Insert values including duplicates. Print all elements using a range-based `for` loop. Verify element presence using `count()` or `find()`. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Elements in the set (unique and sorted):\n1 2 5 8\nIs 8 present in the set? Yes.\n",
    "explanation": "A `std::set<int>` is created. When elements are inserted, `std::set` automatically handles duplicates, storing each unique number only once. It also maintains elements in sorted order. A range-based `for` loop prints these unique, sorted elements. `my_set.count(8)` returns 1 because 8 is present, so 'Yes' is printed."
  },
  {
    "topic": "STL and Containers",
    "level": "Easy",
    "title": "Using `std::string` (from `<string>`) and Basic Manipulation",
    "description": "This problem ensures a solid grasp of `std::string`, the primary string class in C++, which is a full-fledged class with methods for manipulation. Your task is to: \n1.  Prompt the user to enter their full name (first and last). \n2.  Store it in a `std::string`. \n3.  Print the full name. \n4.  Print the length of the full name using `.length()` or `.size()`. \n5.  Print the first character of the name using `[0]`. \n6.  Print the last character of the name using `[string.length() - 1]`. \nThis exercise reinforces `std::string` basics, input, and indexed access.",
    "constraints": "You must use `std::string`. You must use `std::getline(std::cin, ...)` to read the full line including spaces. Print the full name, its length, first character, and last character. Assume non-empty input.",
    "sampleInput": "Enter your full name: John Doe",
    "sampleOutput": "Enter your full name: John Doe\nYour full name: John Doe\nLength: 8\nFirst character: J\nLast character: e\n",
    "explanation": "The program uses `std::getline(std::cin, full_name)` to read the entire line of input, including the space between 'John' and 'Doe'. It then prints the string, its length using `.length()`, the character at index 0 (`[0]`), and the character at the last index (`[full_name.length() - 1]`)."
  },
  {
    "topic": "STL and Containers",
    "level": "Medium",
    "title": "Sort a `std::vector` of Custom Objects",
    "description": "This problem combines `std::vector` with sorting algorithms from `<algorithm>` and requires you to define a custom comparison logic for objects. Your task is to: \n1.  Define a `struct Person` with `std::string name` and `int age`. \n2.  Create a `std::vector<Person>`. \n3.  Add at least 5 `Person` objects to the vector with varied names and ages. \n4.  Sort the `std::vector` of `Person` objects based on their `age` in ascending order. You can use `std::sort()` and provide a **lambda function** or a **custom comparison function** as the third argument. \n5.  Print the `name` and `age` of each person after sorting. \nThis problem is a practical application of `std::vector` and `std::sort` for structured data.",
    "constraints": "You must define a `struct Person` with `name` and `age`. You must use `std::vector<Person>`. Add at least 5 `Person` objects. You must use `std::sort()` from `<algorithm>`. You must provide a custom comparison (lambda or function) to sort by `age`. Print the sorted list of people. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Original list:\nAlice (30), Bob (25), Charlie (35), David (28), Eve (22)\n\nSorted list by age:\nEve (22)\nBob (25)\nDavid (28)\nAlice (30)\nCharlie (35)\n",
    "explanation": "A `Person` struct is defined. A `std::vector<Person>` is populated. `std::sort` is called on the vector. The third argument is a lambda expression `[](const Person& a, const Person& b) { return a.age < b.age; }`. This lambda defines the custom comparison: it returns `true` if `a`'s age is less than `b`'s age, causing `std::sort` to arrange elements in ascending order of age. The sorted list is then printed."
  },
  {
    "topic": "STL and Containers",
    "level": "Medium",
    "title": "Use `std::unordered_map` for Fast Lookups",
    "description": "This problem introduces `std::unordered_map`, an associative container that stores elements in key-value pairs but uses hash tables for storage. Unlike `std::map`, elements in `std::unordered_map` are not sorted, but it offers average constant-time complexity for insertion, deletion, and lookup, making it very fast for large datasets. Your task is to: \n1.  Declare a `std::unordered_map<int, std::string>` to store employee IDs and names. \n2.  Insert at least five key-value pairs (e.g., `101 -> \"Alice\", 105 -> \"Bob\"`). \n3.  Prompt the user to enter an Employee ID to search for. \n4.  If the ID is found, print the employee's name. If not, print 'Employee not found.'. \n5.  Demonstrate changing an employee's name (e.g., `employee_map[101] = \"Alicia\";`). \n\nThis exercise highlights `std::unordered_map`'s speed for lookups and mutability.",
    "constraints": "You must use `std::unordered_map<int, std::string>`. Insert at least 5 pairs. Use `std::cin` for ID input. Use `map.count()` or `map.find()` for lookup. Demonstrate updating a value. Print names if found, or 'Employee not found.'. Assume valid integer ID input.",
    "sampleInput": "Enter Employee ID to search: 103",
    "sampleOutput": "Enter Employee ID to search: 103\nEmployee found: Charlie\nUpdated name for ID 101.\nEmployee found: Alicia\n",
    "explanation": "A `std::unordered_map<int, std::string>` is declared and populated. The program prompts for an ID. `employee_map.count(search_id)` efficiently checks for existence. If found, `employee_map[search_id]` accesses the name. `employee_map[101] = \"Alicia\";` demonstrates direct modification of a value associated with an existing key. The output shows fast lookup and successful update."
  },
  {
    "topic": "STL and Containers",
    "level": "Medium",
    "title": "Stack and Queue Simulation",
    "description": "This problem introduces two essential container adaptors from the STL: `std::stack` (LIFO - Last-In, First-Out) and `std::queue` (FIFO - First-In, First-Out). They provide restricted interfaces to other containers (like `std::deque` by default) to model specific data structures. Your task is to: \n1.  Use `std::stack<int>` to simulate a pile of plates: \n    * `push()` three integers onto the stack. \n    * `pop()` two times, printing the popped value each time. \n    * Print the `top()` element without popping. \n2.  Use `std::queue<std::string>` to simulate a line of customers: \n    * `push()` three customer names. \n    * `pop()` two times, printing the popped name each time. \n    * Print the `front()` element without popping. \n\nThis exercise clearly demonstrates the LIFO and FIFO behavior of stacks and queues.",
    "constraints": "You must use `std::stack<int>` and `std::queue<std::string>`. Perform `push`, `pop`, `top` for stack and `push`, `pop`, `front` for queue as specified. Print relevant values during operations. No user input required.",
    "sampleInput": "None (logic hardcoded)",
    "sampleOutput": "Stack Operations (LIFO):\nPushing 10, 20, 30...\nPopped: 30\nPopped: 20\nTop of stack: 10\n\nQueue Operations (FIFO):\nPushing Alice, Bob, Charlie...\nPopped: Alice\nPopped: Bob\nFront of queue: Charlie\n",
    "explanation": "1.  **Stack:** `push()` adds elements to the top. `pop()` removes from the top (LIFO). `top()` accesses the top without removing. Pushing 10, 20, 30 means 30 is on top. Popping twice removes 30 then 20, leaving 10 on top. \n2.  **Queue:** `push()` adds elements to the back. `pop()` removes from the front (FIFO). `front()` accesses the front without removing. Pushing Alice, Bob, Charlie means Alice is at the front. Popping twice removes Alice then Bob, leaving Charlie at the front. The output clearly shows the LIFO and FIFO behavior."
  },
  {
    "topic": "STL and Containers",
    "level": "Hard",
    "title": "Custom Comparator for `std::map`",
    "description": "This problem delves into advanced `std::map` usage by requiring a **custom comparison function/functor/lambda** for its keys. By default, `std::map` uses `std::less` for key comparison (ascending order). You can provide your own comparator to change this behavior (e.g., for descending order, or sorting by a custom rule for complex keys). Your task is to: \n1.  Define a `std::map<std::string, int, CustomStringCompare>` where `CustomStringCompare` is a custom comparator that sorts strings in **descending (reverse alphabetical) order**. \n2.  Populate this map with at least 4 key-value pairs (e.g., country names and their populations). \n3.  Iterate through the map and print its contents. Observe that the keys are now sorted in reverse alphabetical order. \n\n**Hint:** A custom comparator is typically a struct with an overloaded `operator()` that takes two arguments of the key type and returns `bool` (true if the first argument 'comes before' the second according to your custom rule). For reverse alphabetical, `return s1 > s2;` or `return s1.compare(s2) > 0;`. \n\nThis problem is hard as it requires implementing a custom callable object for sorting logic within an STL container.",
    "constraints": "You must use `std::map`. You must define a custom comparator (struct/functor or lambda) that causes `std::map` to sort its `std::string` keys in **descending alphabetical order**. Populate the map with at least 4 key-value pairs. Iterate and print the map's contents, demonstrating the custom sorting. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Countries sorted in reverse alphabetical order:\nUSA: 330000000\nUK: 67000000\nFrance: 65000000\nCanada: 38000000\n",
    "explanation": "A `CustomStringCompare` struct is defined with `operator()` overloaded. This operator takes two `const std::string&` and returns `s1 > s2`. This means `s1` 'comes before' `s2` if `s1` is lexicographically greater than `s2`, effectively sorting the map in reverse alphabetical order. \nWhen `std::map<std::string, int, CustomStringCompare> country_populations;` is declared, it uses this custom comparator. The elements inserted are then automatically arranged and printed according to this reverse order."
  },
  {
    "topic": "STL and Containers",
    "level": "Hard",
    "title": "Using `std::algorithm` with Iterators: Transform and Count_if",
    "description": "This problem focuses on utilizing generic algorithms from the `<algorithm>` header with iterators, which is a powerful and idiomatic way to manipulate STL containers without manual loops for common tasks. Your task is to: \n1.  Create a `std::vector<int>` with at least 10 integer values (some positive, some negative, some zero). \n2.  Use `std::transform` to create a **new `std::vector<int>`** where each element is the absolute value of the corresponding element in the original vector. (You'll need `std::abs` from `<cmath>` or `<cstdlib>`). Print the transformed vector. \n3.  Use `std::count_if` to count how many positive numbers (greater than 0) are in the **original** vector. Print this count. \n\n**Hint:** `std::transform` typically takes three iterators (input begin, input end, output begin) and a unary operation (a function or lambda). `std::count_if` takes two iterators (begin, end) and a unary predicate (a function or lambda returning `bool`). \n\nThis problem requires understanding iterators and applying higher-order functions (lambdas) with generic algorithms, a cornerstone of effective STL usage.",
    "constraints": "You must use `std::vector<int>`. The original vector must have at least 10 elements, including positive, negative, and zero. You must use `std::transform` to create a new vector of absolute values. You must use `std::count_if` to count positive numbers in the original vector. Print both the transformed vector and the count. No user input required.",
    "sampleInput": "None (values hardcoded)",
    "sampleOutput": "Original vector: 10 -5 0 20 -15 30 -25 5 12 -8\nTransformed (absolute) vector: 10 5 0 20 15 30 25 5 12 8\nNumber of positive elements in original vector: 6\n",
    "explanation": "1.  `std::transform(original_vec.begin(), original_vec.end(), abs_vec.begin(), [](int n){ return std::abs(n); });` applies `std::abs` to each element in `original_vec` and places the result into `abs_vec` (which needs to be resized first, or use `std::back_inserter`). The lambda `[](int n){ return std::abs(n); }` is the unary operation. \n2.  `std::count_if(original_vec.begin(), original_vec.end(), [](int n){ return n > 0; });` counts elements in `original_vec` for which the lambda `[](int n){ return n > 0; }` returns `true`. This effectively counts positive numbers. \nBoth results are then printed."
  },
  {
    "topic": "STL and Containers",
    "level": "Tricky",
    "title": "Implementing a Simple Graph using `std::map` of `std::vector`s",
    "description": "This problem combines multiple STL containers to build a more complex data structure: a basic graph. A graph can be represented using an adjacency list, where each node maps to a list of its neighbors. This problem is tricky because it requires nested container usage and understanding how to represent relationships. Your task is to: \n1.  Implement an **undirected graph** using a `std::map<std::string, std::vector<std::string>>` (mapping a node name to a list of its connected neighbors). \n2.  Implement a function `void add_edge(std::map<std::string, std::vector<std::string>>& graph, const std::string& u, const std::string& v)` that adds an edge between nodes `u` and `v`. Since it's undirected, add `v` to `u`'s list and `u` to `v`'s list. Handle cases where a node might not exist yet. \n3.  Implement a function `void print_graph(const std::map<std::string, std::vector<std::string>>& graph)` that iterates through the map and prints each node and its neighbors. \n4.  In `main`, create a graph, add several edges (e.g., A-B, A-C, B-D), and then print the graph. \n\nThis problem tests advanced container usage and structuring complex data.",
    "constraints": "You must use `std::map<std::string, std::vector<std::string>>` to represent the graph. You must implement `add_edge` to add undirected edges, handling new nodes. You must implement `print_graph` to display the graph clearly. `main` must populate and print the graph. No user input required.",
    "sampleInput": "None (logic hardcoded)",
    "sampleOutput": "Graph Adjacency List:\nA: B C \nB: A D \nC: A \nD: B \n",
    "explanation": "A `std::map<std::string, std::vector<std::string>>` called `adjacency_list` is used. \n* `add_edge` function: When `add_edge(graph, \"A\", \"B\")` is called, it accesses `graph[\"A\"]` (which creates an empty `std::vector<std::string>` if \"A\" doesn't exist yet) and `push_back(\"B\")`. It does the same for `graph[\"B\"]` and `push_back(\"A\")`. This correctly models an undirected edge. \n* `print_graph` iterates through the `std::map`. For each key-value pair (node and its vector of neighbors), it prints the node name and then iterates through the `std::vector` to print its neighbors. The output shows each node and its connections, representing the graph structure."
  },
  {
    "topic": "STL and Containers",
    "level": "Tricky",
    "title": "Implementing a LRU Cache with `std::list` and `std::unordered_map`",
    "description": "This is a challenging problem that requires integrating `std::list` and `std::unordered_map` to implement a common data structure: a Least Recently Used (LRU) Cache. An LRU cache stores a fixed number of key-value pairs and discards the least recently used item when a new item is added and the cache is full. This problem is tricky due to the need to manage both the order of usage (list) and fast lookup (map), and the interplay between these two containers. \n\nYour task is to: \n1.  Define a class `LRUCache` with a fixed `capacity`. \n2.  **Private members**: \n    * `std::list<int> dq;` (a `std::list` to store keys in order of usage, front is most recent, back is least recent). \n    * `std::unordered_map<int, std::list<int>::iterator> ma;` (a `std::unordered_map` to map keys to their iterators in the `dq` list for fast access). \n    * `int c;` (capacity). \n3.  Implement a constructor `LRUCache(int cap)` to set capacity. \n4.  Implement a `int get(int key)` method: \n    * If `key` is not in `ma`, return -1. \n    * If `key` is present, move it to the front of `dq` (most recently used). Return the value associated with the key (for simplicity, let's assume value is same as key for this problem, or you can add a `value` field to `dq`'s nodes). \n5.  Implement a `void put(int key, int value)` method (value can be assumed to be same as key for simplicity): \n    * If `key` is in `ma`: Update its value (if applicable) and move it to the front of `dq`. \n    * If `key` is *not* in `ma`: \n        * If cache is full (`dq.size() == c`), remove the least recently used key from the back of `dq` and remove it from `ma`. \n        * Add the new `key` to the front of `dq` and insert its iterator into `ma`. \n6.  In `main`, demonstrate cache operations (put and get) with clear prints indicating cache state. \n\nThis problem requires careful management of iterators and synchronization between the list and map, making it a true test of STL container mastery.",
    "constraints": "You must implement the `LRUCache` class with `std::list<int> dq` and `std::unordered_map<int, std::list<int>::iterator> ma`. Implement `get(key)` and `put(key, value)` with LRU logic. Assume value is key for simplicity (or store pairs). Print state changes or method returns clearly. No user input required.",
    "sampleInput": "None (logic hardcoded)",
    "sampleOutput": "LRU Cache (Capacity: 3)\nPutting 1 (value 1)\nCache: 1 \nPutting 2 (value 2)\nCache: 2 1 \nPutting 3 (value 3)\nCache: 3 2 1 \nGetting 2. Hit. Value: 2\nCache: 2 3 1 \nPutting 4 (value 4). Cache full, removing 1.\nCache: 4 2 3 \nGetting 1. Miss. Value: -1\nCache: 4 2 3 \nGetting 3. Hit. Value: 3\nCache: 3 4 2 \n",
    "explanation": "The `LRUCache` uses `dq` (a `std::list`) to maintain usage order and `ma` (a `std::unordered_map`) for fast `O(1)` key lookups. \n* **`put(key, value)`:** If the key exists, its corresponding node is moved to the front of `dq` (most recently used). If new and full, the least recently used (back of `dq`) is removed from both `dq` and `ma`. The new key is added to the front of `dq`, and its new iterator is stored in `ma`. \n* **`get(key)`:** If the key exists, its node is moved to the front of `dq` (marking it most recently used). If not, -1 is returned. \nThe output traces the state of the cache (keys in `dq` from front to back) and demonstrates hits/misses, and eviction of the least recently used element when capacity is reached."
  },
  {
    "topic": "STL and Containers",
    "level": "Real World Problem",
    "title": "Hospital Patient Management System (Priority Queue and Map)",
    "description": "You are building a simplified patient management system for a hospital's emergency room. Patients arrive with different severities, and the system needs to prioritize them. This problem requires combining `std::priority_queue` (for priority-based access) and `std::map` (for looking up patient details), demonstrating a practical application of these containers. \n\nYour task is to: \n1.  Define a `struct Patient` with `std::string name`, `int severity` (higher number = more severe), and `std::string condition`. \n2.  Define a custom comparison operator or functor for `Patient` to make `std::priority_queue` prioritize patients with **higher severity** first. \n3.  In `main`: \n    * Create a `std::priority_queue<Patient, std::vector<Patient>, CustomPatientComparator>` (or equivalent lambda) to store patients based on severity. \n    * Create a `std::map<std::string, Patient>` to store patient details by name for quick lookup. \n    * Add several patients with different severities to both the priority queue and the map. \n    * Simulate processing patients: Repeatedly `pop()` from the `priority_queue`, printing the patient's name and condition. Use `top()` to see who's next. \n    * Demonstrate looking up a patient by name using the `std::map`. \n\nThis problem integrates custom data structures, priority queue behavior, map lookups, and clear output to model a real-world system.",
    "constraints": "You must define a `struct Patient` with `name`, `severity`, `condition`. You must define a custom comparator for `Patient` that prioritizes higher `severity`. You must use `std::priority_queue<Patient, std::vector<Patient>, CustomComparator>`. You must use `std::map<std::string, Patient>`. Add at least 4 patients. Demonstrate `push`, `top`, `pop` for the priority queue and lookup for the map. Print patient names and conditions as they are processed or looked up. No user input required.",
    "sampleInput": "None (logic hardcoded)",
    "sampleOutput": "--- Patient Arrivals ---\nAdding: John (Severity: 8, Condition: Chest Pain)\nAdding: Alice (Severity: 5, Condition: Fever)\nAdding: Bob (Severity: 9, Condition: Stroke Symptoms)\nAdding: Charlie (Severity: 7, Condition: Fracture)\n\n--- Processing Patients (by Severity) ---\nNow treating: Bob (Condition: Stroke Symptoms, Severity: 9)\nNext in queue: Charlie (Condition: Fracture, Severity: 7)\nNow treating: Charlie (Condition: Fracture, Severity: 7)\nNext in queue: John (Condition: Chest Pain, Severity: 8)\nNow treating: John (Condition: Chest Pain, Severity: 8)\nNext in queue: Alice (Condition: Fever, Severity: 5)\nNow treating: Alice (Condition: Fever, Severity: 5)\nQueue is empty.\n\n--- Patient Lookup ---\nLooking up Alice...\nFound: Alice (Severity: 5, Condition: Fever)\n",
    "explanation": "1.  **`Patient` struct:** Holds patient data. \n2.  **`CustomPatientComparator`:** A struct with `operator()` defined to return `p1.severity < p2.severity`. For `std::priority_queue`, the default `std::less` means 'higher value is higher priority'. So, `p1.severity < p2.severity` makes higher severity numbers float to the top (max-heap behavior). \n3.  **`std::priority_queue`:** Stores patients, automatically arranging them by severity (highest first). `push()` adds, `top()` views the highest priority, `pop()` removes it. \n4.  **`std::map`:** Stores `Patient` objects, keyed by `name`, allowing for `O(logN)` lookup for specific patient details regardless of their priority in the queue. \n\nIn `main`, patients are added to both structures. The processing loop correctly extracts patients from the `priority_queue` in order of severity (Bob, then Charlie, then John, then Alice). The map lookup demonstrates retrieving full details for a specific patient by name. This showcases a robust system for managing priority-based tasks with detailed lookups."
  }
]