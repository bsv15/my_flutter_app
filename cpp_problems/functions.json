[
  {
    "topic": "Functions",
    "level": "Easy",
    "title": "Simple Greeting Function",
    "description": "This problem introduces the fundamental concept of **functions** in C++. A function is a block of code that performs a specific task and can be called from other parts of the program. It promotes code reusability and organization. Your task is to define a simple function named `greet_user` that takes no arguments and returns `void` (meaning it doesn't return any value). Inside this function, use `std::cout` to print a fixed greeting message, such as 'Hello from the greet_user function!'. In your `main` function, call `greet_user` once. This problem is the simplest way to understand function declaration, definition, and calling.",
    "constraints": "You must define a function named `greet_user`. It must have a `void` return type and take no parameters. The `main` function must call `greet_user` exactly once. The function should print a fixed greeting message.",
    "sampleInput": "None",
    "sampleOutput": "Hello from the greet_user function!\n",
    "explanation": "The `greet_user` function is defined to simply print a fixed string. When `main` calls `greet_user()`, the program flow jumps to the function's definition, executes the `std::cout` statement, and then returns to `main` (which then finishes)."
  },
  {
    "topic": "Functions",
    "level": "Easy",
    "title": "Calculate Area of a Rectangle",
    "description": "This problem focuses on defining a function that takes **parameters** (also known as arguments) and **returns a value**. Parameters allow functions to receive input data, and return values allow them to send results back to the caller. Your task is to define a function named `calculate_rectangle_area` that takes two `double` parameters: `length` and `width`. The function should calculate `length * width` and return the result as a `double`. In your `main` function, call `calculate_rectangle_area` with sample values (e.g., 5.0 and 3.0), store the returned area in a variable, and then print the area formatted to two decimal places. This problem demonstrates passing data to a function and receiving a result.",
    "constraints": "You must define a function `calculate_rectangle_area`. It must take two `double` parameters and return a `double`. The `main` function must call it and print the returned area. The output area must be formatted to two decimal places using `std::fixed` and `std::setprecision(2)`. No user input is required.",
    "sampleInput": "None (values hardcoded in main)",
    "sampleOutput": "The area of the rectangle is: 15.00\n",
    "explanation": "The `calculate_rectangle_area` function is defined to accept two `double` values (`length` and `width`). It computes their product and returns it. In `main`, `calculate_rectangle_area(5.0, 3.0)` is called. The values 5.0 and 3.0 are passed to the function, the function returns `15.0`, which is stored in `area` and then printed with the specified formatting."
  },
  {
    "topic": "Functions",
    "level": "Easy",
    "title": "Display Current Score",
    "description": "This problem focuses on passing information to a function using **pass-by-value**. When a variable is passed by value, a copy of the variable's content is made and passed to the function. Changes made to the parameter inside the function do not affect the original variable in the caller. Your task is to define a function named `display_score` that takes one `int` parameter `score`. Inside the function, print the message 'Current Score: [score]'. In your `main` function, declare an `int` variable `player_score` initialized to 100, call `display_score` with `player_score`. Then, change `player_score` to 150 and call `display_score` again. Observe that the function correctly displays the current value each time, even though the variable changed in `main`. This demonstrates the basic concept of passing data into a function.",
    "constraints": "You must define a function `display_score` that takes one `int` parameter and returns `void`. The `main` function must call `display_score` twice with different values of `player_score`. Print the score inside the function as specified. No user input is required.",
    "sampleInput": "None (values hardcoded in main)",
    "sampleOutput": "Current Score: 100\nCurrent Score: 150\n",
    "explanation": "The `display_score` function takes an `int` parameter `score` by value. When `display_score(player_score)` is called the first time, a copy of `player_score` (100) is passed, and `100` is printed. When `player_score` is updated to `150` and the function is called again, a new copy of `player_score` (150) is passed, and `150` is printed. The function always works with the current value of the variable from `main` because a new copy is created each time."
  },
  {
    "topic": "Functions",
    "level": "Easy",
    "title": "Convert Celsius to Fahrenheit",
    "description": "This problem practices writing a reusable conversion function. You'll define a function that takes a temperature in Celsius as input and returns its equivalent in Fahrenheit. The formula for converting Celsius to Fahrenheit is `F = C * 9/5 + 32`. Your task is to define a function `celsius_to_fahrenheit` that takes a `double` argument for Celsius temperature and returns a `double` for Fahrenheit. In your `main` function, get a Celsius temperature from the user (e.g., 25.0), call your conversion function, and print the result formatted to one decimal place. This problem emphasizes modularity through a dedicated conversion function.",
    "constraints": "You must define a function `celsius_to_fahrenheit` taking a `double` and returning a `double`. The `main` function must get input from the user. The output Fahrenheit temperature must be formatted to one decimal place (`std::fixed`, `std::setprecision(1)`). Assume valid numeric input.",
    "sampleInput": "Enter temperature in Celsius: 25.0",
    "sampleOutput": "Enter temperature in Celsius: 25.0\n25.0 Celsius is 77.0 Fahrenheit.\n",
    "explanation": "The program prompts the user for Celsius input, reads `25.0`. The `celsius_to_fahrenheit` function is called with `25.0`. Inside the function, the calculation `25.0 * 9/5 + 32` evaluates to `77.0`. This value is returned to `main` and then printed, formatted to one decimal place."
  },
  {
    "topic": "Functions",
    "level": "Medium",
    "title": "Pass by Reference: Swap Two Numbers",
    "description": "This problem introduces **pass-by-reference** using reference parameters (`&`), which allows a function to directly modify the original variables passed from the caller. Unlike pass-by-value, no copy is made. This is essential when a function needs to 'return' multiple values or modify its arguments directly. Your task is to define a function named `swap_numbers` that takes two `int` parameters **by reference** (e.g., `int& a, int& b`). Inside this function, swap the values of `a` and `b` (you'll typically need a temporary variable). In your `main` function, declare two `int` variables (e.g., `num1 = 10, num2 = 20`), print their initial values, call `swap_numbers`, and then print their values again to demonstrate that they have indeed been swapped. This problem is a classic illustration of call-by-reference.",
    "constraints": "You must define a function `swap_numbers` that takes two `int` parameters by reference (`int&`). The function must swap the values of the parameters. The `main` function must call it and print the values before and after the swap. No user input is required.",
    "sampleInput": "None (values hardcoded in main)",
    "sampleOutput": "Before swap: num1 = 10, num2 = 20\nAfter swap: num1 = 20, num2 = 10\n",
    "explanation": "Initially, `num1 = 10, num2 = 20`. When `swap_numbers(num1, num2)` is called, `num1` and `num2` are passed by reference. This means `a` inside `swap_numbers` refers directly to `num1` in `main`, and `b` refers directly to `num2`. When `a` and `b` are swapped using a temporary variable within the function, the actual `num1` and `num2` in `main` are modified. After the function returns, `num1` is 20 and `num2` is 10."
  },
  {
    "topic": "Functions",
    "level": "Medium",
    "title": "Overloaded `print` Function for Different Types",
    "description": "This problem introduces **function overloading**, a C++ feature that allows multiple functions to have the same name as long as they have different parameter lists (different number of parameters, different types of parameters, or different order of parameters). This enables writing more intuitive code where a single function name can perform similar operations on different data types. Your task is to define three overloaded functions, all named `print_value`. \n1.  `print_value(int val)`: Prints 'Integer value: [val]'. \n2.  `print_value(double val)`: Prints 'Double value: [val]' (formatted to two decimal places). \n3.  `print_value(const std::string& val)`: Prints 'String value: [val]'. \nIn `main`, call `print_value` with an `int`, a `double`, and a `std::string` literal to demonstrate that the compiler correctly selects the appropriate overloaded version. This showcases polymorphism at compile time.",
    "constraints": "You must define three functions, all named `print_value`, with different parameter lists as specified. The `double` version must use `std::fixed` and `std::setprecision(2)`. No user input is required. `main` should call each overloaded function once.",
    "sampleInput": "None (values hardcoded in main)",
    "sampleOutput": "Integer value: 10\nDouble value: 3.14\nString value: Hello Overload!\n",
    "explanation": "The program defines three functions with the same name `print_value` but distinct parameter types (`int`, `double`, `const std::string&`). When `print_value(10)` is called, the compiler matches it to `print_value(int)`. When `print_value(3.14159)` is called, it matches `print_value(double)`. When `print_value(\"Hello Overload!\")` is called, it matches `print_value(const std::string&)`. This compile-time selection is function overloading in action."
  },
  {
    "topic": "Functions",
    "level": "Medium",
    "title": "Calculate Circle Properties with Default Arguments",
    "description": "This problem demonstrates **default arguments** in functions, which allow a function parameter to have a predefined value if no argument is explicitly passed for it during the function call. This makes functions more flexible and can reduce the need for overloading if only a subset of parameters varies. Your task is to define a function `calculate_circle_properties` that takes a `double radius` and an optional `bool print_area_only = false` as parameters. \n* If `print_area_only` is `true`, the function should only calculate and print the circle's area (`π * r^2`). \n* If `print_area_only` is `false` (the default), it should calculate and print both the area and the circumference (`2 * π * r`). \nUse `M_PI` from `<cmath>` (or define `const double PI = 3.141592653589793;`). In `main`, call the function once with only the radius, and once with both radius and `true` for `print_area_only`. Format all outputs to two decimal places. This shows how default arguments provide call flexibility.",
    "constraints": "You must define a function `calculate_circle_properties` with a default argument for `print_area_only`. Use `M_PI` or define PI. Print output formatted to two decimal places (`std::fixed`, `std::setprecision(2)`). No user input is required.",
    "sampleInput": "None (values hardcoded in main)",
    "sampleOutput": "Calculating for radius 5.00:\nArea: 78.54\nCircumference: 31.42\n\nCalculating for radius 7.50 (area only):\nArea: 176.71\n",
    "explanation": "The `calculate_circle_properties` function has `print_area_only` with a default value of `false`. \n1.  First call `calculate_circle_properties(5.0)`: Since `print_area_only` is not provided, it defaults to `false`. Both area and circumference are calculated and printed for radius 5.0. \n2.  Second call `calculate_circle_properties(7.5, true)`: `print_area_only` is explicitly set to `true`. Only the area is calculated and printed for radius 7.5. This demonstrates how the same function can behave differently based on an optional parameter."
  },
  {
    "topic": "Functions",
    "level": "Hard",
    "title": "Recursive Sum of Digits",
    "description": "Recursion is a powerful programming technique where a function calls itself to solve smaller instances of the same problem. This problem challenges you to write a **recursive function** to calculate the sum of the digits of a non-negative integer. For example, `sum_digits(123) = 1 + 2 + 3 = 6`. \n\n**Recursive Logic:** \n* **Base Case:** If `n < 10` (a single-digit number), the sum of digits is just `n` itself. \n* **Recursive Step:** Otherwise, the sum of digits of `n` is `(n % 10)` (the last digit) + `sum_digits(n / 10)` (sum of digits of the remaining number). \n\nYour task is to define a recursive function `sum_digits(int n)` that returns an `int`. In `main`, prompt the user for a non-negative integer and print its sum of digits using your recursive function. This problem requires understanding how to define a base case and a recursive step to correctly break down a problem.",
    "constraints": "You must define a **recursive function** named `sum_digits` that takes an `int` and returns an `int`. Handle non-negative integers. `std::cin` must be used for input. Assume input will be a non-negative integer within `int` limits. Print the result.",
    "sampleInput": "Enter a non-negative integer: 456",
    "sampleOutput": "Enter a non-negative integer: 456\nSum of digits: 15\n",
    "explanation": "Let's trace `sum_digits(456)`:\n1.  `sum_digits(456)`: `456 >= 10`. Returns `(456 % 10) + sum_digits(456 / 10)` which is `6 + sum_digits(45)`. \n2.  `sum_digits(45)`: `45 >= 10`. Returns `(45 % 10) + sum_digits(45 / 10)` which is `5 + sum_digits(4)`. \n3.  `sum_digits(4)`: `4 < 10`. This is the base case. Returns `4`. \nNow, the calls unwind: \n    `5 + 4 = 9` \n    `6 + 9 = 15` \nFinally, `sum_digits(456)` returns `15`."
  },
  {
    "topic": "Functions",
    "level": "Hard",
    "title": "Passing Arrays to Functions: Calculate Average",
    "description": "Passing arrays to functions in C++ (specifically C-style arrays) involves understanding that arrays **decay to pointers** to their first element when passed as arguments. This means the function doesn't know the array's size. You often need to pass the size separately. Your task is to: \n1.  Create a fixed-size `int` array in `main` (e.g., `int grades[] = {85, 92, 78, 95, 88};`). \n2.  Define a function `calculate_average(const int arr[], int size)` that takes a constant integer array (to prevent modification inside the function) and its size. \n3.  Inside `calculate_average`, iterate through the array to sum its elements, then calculate and return the average as a `double`. \n4.  In `main`, call `calculate_average` with your `grades` array and its size (`sizeof(grades) / sizeof(grades[0])`). Print the returned average formatted to two decimal places. This problem highlights how arrays are handled in function arguments and the importance of passing size.",
    "constraints": "You must use a C-style `int` array. You must define a function `calculate_average` with the signature `double calculate_average(const int arr[], int size)`. The function must iterate through the array and correctly calculate the average. The average must be returned as a `double` and printed with `std::fixed` and `std::setprecision(2)`. No user input is required.",
    "sampleInput": "int grades[] = {85, 92, 78, 95, 88};",
    "sampleOutput": "The average grade is: 87.60\n",
    "explanation": "The `grades` array is defined in `main`. `sizeof(grades) / sizeof(grades[0])` calculates its size (5). `calculate_average` receives a pointer to the first element and the size. It then iterates 5 times, summing the elements (`85+92+78+95+88 = 438`). It then divides `438.0` by `5` (ensuring floating-point division) to get `87.6`. This average is returned and printed, formatted to two decimal places."
  },
  {
    "topic": "Functions",
    "level": "Tricky",
    "title": "Function Pointers for Strategy Pattern",
    "description": "This problem introduces **function pointers**, a powerful C++ feature that allows you to store the address of a function and call that function indirectly. This is a foundational concept for implementing design patterns like the Strategy pattern, where an algorithm's behavior can be selected at runtime. \n\nYour task is to: \n1.  Define three simple functions: \n    * `int add(int a, int b)`: Returns `a + b`. \n    * `int subtract(int a, int b)`: Returns `a - b`. \n    * `int multiply(int a, int b)`: Returns `a * b`. \n2.  Define a higher-order function `perform_operation(int x, int y, int (*operation_ptr)(int, int))` that takes two integers and a **function pointer** as its third argument. This function should call the function pointed to by `operation_ptr` with `x` and `y` and return the result. \n3.  In `main`, prompt the user to choose an operation (1 for Add, 2 for Subtract, 3 for Multiply). \n4.  Based on the user's choice, assign the appropriate function's address to a function pointer variable (e.g., `int (*op_func)(int, int);`). \n5.  Then, prompt for two numbers. Call `perform_operation` using the selected function pointer and print the result. Include error handling for invalid choices. \n\nThis problem challenges your understanding of function pointers' syntax and their application in making program behavior dynamic.",
    "constraints": "You must define the three specified arithmetic functions. You must define a `perform_operation` function that accepts a function pointer. You must use `std::cin` for user choice and numbers. You must declare and use a function pointer variable to store the address of the chosen function. Implement error handling for invalid choice. Print the result. Assume valid integer input.",
    "sampleInput": "Select operation:\n1. Add\n2. Subtract\n3. Multiply\nEnter choice (1-3): 2\nEnter first number: 25\nEnter second number: 10",
    "sampleOutput": "Select operation:\n1. Add\n2. Subtract\n3. Multiply\nEnter choice (1-3): 2\nEnter first number: 25\nEnter second number: 10\nResult of operation: 15\n",
    "explanation": "The program defines `add`, `subtract`, `multiply`, and `perform_operation`. \n1.  User enters `2` for Subtract. \n2.  In `main`, based on choice `2`, the function pointer `op_func` is assigned the address of the `subtract` function. \n3.  User enters `25` and `10`. \n4.  `perform_operation(25, 10, op_func)` is called. Inside `perform_operation`, `operation_ptr(x, y)` effectively calls `subtract(25, 10)`, which returns `15`. \n5.  `15` is returned to `main` and printed. This demonstrates how a function's behavior can be dynamically chosen at runtime by passing its address."
  },
  {
    "topic": "Functions",
    "level": "Tricky",
    "title": "Static Local Variables and Function State",
    "description": "This problem explores **static local variables** within functions. A `static` local variable is initialized only *once*, the first time the function is called. Its value persists between subsequent function calls, unlike regular local variables which are created and destroyed with each call. This allows a function to maintain state without using global variables. \n\nYour task is to define a function `generate_unique_id()`. This function should: \n1.  Declare a `static int next_id = 1000;`. \n2.  Increment `next_id` and return its new value. \n\nIn `main`, call `generate_unique_id()` five times and print the returned ID each time. Then, demonstrate that if you reset the `next_id` outside the function (which is impossible without a global variable or special access), it wouldn't happen, emphasizing its local scope. This problem is tricky because it forces you to understand the lifetime and scope of static local variables, which is different from both global and automatic local variables.",
    "constraints": "You must define a function `generate_unique_id`. It must contain a `static int` local variable. The function must increment and return this `static` variable. `main` must call this function five times and print each result. No user input is required.",
    "sampleInput": "None (logic hardcoded)",
    "sampleOutput": "Generated ID: 1001\nGenerated ID: 1002\nGenerated ID: 1003\nGenerated ID: 1004\nGenerated ID: 1005\n",
    "explanation": "The `generate_unique_id` function is defined. Inside it, `static int next_id = 1000;` is declared. \n1.  **First call:** `next_id` is initialized to 1000. It's incremented to 1001. `1001` is returned. \n2.  **Second call:** `next_id` is *not* re-initialized. It retains its value of 1001. It's incremented to 1002. `1002` is returned. \n3.  This pattern continues for subsequent calls. Each call accesses and modifies the *same* `next_id` variable, demonstrating its persistent state across function calls, while remaining confined to the function's scope (it cannot be accessed directly from `main`)."
  },
  {
    "topic": "Functions",
    "level": "Real World Problem",
    "title": "Customer Loyalty Program Points Calculator",
    "description": "You're building a module for a customer loyalty program. This requires a robust function that calculates loyalty points earned based on purchase amount and optionally applies bonus multipliers. The challenge is handling different types of bonuses (flat points, percentage multipliers), ensuring correct calculations and parameter handling, and managing optional arguments. \n\nYour task is to define a function `calculate_loyalty_points` with the following overloaded versions to handle different scenarios: \n\n1.  **`int calculate_loyalty_points(double purchase_amount)`:** \n    * Calculates base points: `purchase_amount * 10` (e.g., $10.00 purchase = 100 points). \n    * Returns the calculated integer points. \n\n2.  **`int calculate_loyalty_points(double purchase_amount, int bonus_points_flat)`:** \n    * Calculates base points as above. \n    * Adds `bonus_points_flat` to the base points. \n    * Returns total points. \n\n3.  **`int calculate_loyalty_points(double purchase_amount, double multiplier_percent)`:** \n    * Calculates base points as above. \n    * Applies `multiplier_percent` (e.g., 1.25 for 25% bonus) to the base points: `base_points * multiplier_percent`. \n    * Returns total points (rounded to nearest integer). \n\n4.  **`int calculate_loyalty_points(double purchase_amount, int bonus_points_flat, double multiplier_percent)`:** \n    * Calculates base points. \n    * Adds `bonus_points_flat`. \n    * Applies `multiplier_percent` to the *sum* of base and flat points. \n    * Returns total points (rounded to nearest integer). \n\nIn `main`, demonstrate calling all four overloaded versions with appropriate arguments, printing the results clearly. This problem tests function overloading, different parameter types, and precise calculation/rounding for a business scenario.",
    "constraints": "You must define exactly four overloaded functions named `calculate_loyalty_points` with the specified signatures and return types (`int`). All calculations must return `int` by rounding the final `double` result to the nearest integer (e.g., `static_cast<int>(std::round(value))`). Use `std::round` from `<cmath>`. Print the results for each call clearly. No user input is required.",
    "sampleInput": "None (logic hardcoded)",
    "sampleOutput": "Points for $50.00: 500\nPoints for $50.00 with 50 flat bonus: 550\nPoints for $50.00 with 1.25x multiplier: 625\nPoints for $50.00 with 50 flat and 1.25x multiplier: 688\n",
    "explanation": "The program defines four overloaded `calculate_loyalty_points` functions. \n1.  **`$50.00`**: `50.00 * 10 = 500` points. \n2.  **`$50.00 + 50 flat`**: `(50.00 * 10) + 50 = 500 + 50 = 550` points. \n3.  **`$50.00 + 1.25x`**: `(50.00 * 10) * 1.25 = 500 * 1.25 = 625` points. \n4.  **`$50.00 + 50 flat + 1.25x`**: `((50.00 * 10) + 50) * 1.25 = (500 + 50) * 1.25 = 550 * 1.25 = 687.5`. Rounded to nearest integer, this becomes `688` points. \nEach `main` call automatically dispatches to the correct overloaded function based on the arguments provided, and the results demonstrate the combined calculation logic."
  }
]