[
  {
    "topic": "File Handling",
    "level": "Easy",
    "title": "Write a Simple Message to a Text File",
    "description": "Write a C program that demonstrates the basic process of writing content to a text file. The program should create a new file named `message.txt` in the same directory as the executable. It should then write the string 'Hello, C File Handling!' into this file. After writing the message, the file must be properly closed. The program should print a confirmation message to the console upon successful file creation and writing. This problem introduces `fopen()` in 'w' mode, `fprintf()`, and `fclose()`.",
    "constraints": "The output file must be named `message.txt`. The content to be written is fixed. Handle potential file open errors gracefully (e.g., print an error if `fopen` returns `NULL`).",
    "sampleInput": "None",
    "sampleOutput": "Successfully wrote 'Hello, C File Handling!' to message.txt.",
    "explanation": "The output `Successfully wrote 'Hello, C File Handling!' to message.txt.` indicates that the program successfully performed the following steps:\n1. It used `fopen(\"message.txt\", \"w\")` to **open (or create)** `message.txt` in **write mode (`'w'`)**. If the file didn't exist, it was created; if it existed, its content was truncated.\n2. It then used `fprintf(file_pointer, \"Hello, C File Handling!\")` to **write the specified string** to the opened file stream.\n3. Finally, `fclose(file_pointer)` was called to **close the file**, flushing any buffered data and releasing the file handle. The program's confirmation message verifies the successful completion of these basic file I/O operations."
  },
  {
    "topic": "File Handling",
    "level": "Easy",
    "title": "Read and Display Entire Content of a Text File",
    "description": "Given an existing text file named `data.txt` (assume this file is already present in the same directory and contains multiple lines of text, e.g., 'Line 1\\nLine 2\\nFinal Line.'), write a C program to open this file in read mode. Your program should then read its entire content, character by character, until the end of the file is reached. As each character is read, print it to the console. Finally, ensure the file is properly closed. This problem demonstrates `fopen()` in 'r' mode, `fgetc()`, and checking for `EOF`.",
    "constraints": "The `data.txt` file is assumed to exist. Each line in `data.txt` will have a maximum length of 100 characters. The file will not exceed 10 lines.",
    "sampleInput": "Content of data.txt:\nThis is line one.\nThis is line two.",
    "sampleOutput": "Content from data.txt:\nThis is line one.\nThis is line two.",
    "explanation": "Given the `data.txt` content, the output `Content from data.txt: ...` exactly mirrors that content because:\n1. The program uses `fopen(\"data.txt\", \"r\")` to **open the file in read mode (`'r'`)**.\n2. It then enters a loop that repeatedly calls `fgetc(file_pointer)`. This function reads characters one by one from the file stream.\n3. Each character read is immediately printed to the console using `putchar()` (or `printf(\"%c\", char_read)`).\n4. The loop continues until `fgetc()` returns `EOF` (End Of File), signaling that there are no more characters to read. Finally, `fclose()` closes the file. This demonstrates basic **character-by-character file reading** and detection of the **end of file**."
  },
  {
    "topic": "File Handling",
    "level": "Medium",
    "title": "Append User Input to an Existing Log File",
    "description": "Develop a C program that allows a user to append new messages to a log file. The program should prompt the user to enter a short message (a single line of text). This message, along with a newline character, should then be appended to a file named `activity_log.txt`. If `activity_log.txt` does not exist, it should be created. The program should successfully append two distinct messages provided by the user. This problem introduces `fopen()` in 'a' (append) mode and `fprintf()` or `fputs()`.",
    "constraints": "The message entered by the user will be a single line with a maximum length of 80 characters. The program should demonstrate appending at least two messages.",
    "sampleInput": "Enter message 1: User logged in\nEnter message 2: Item added to cart",
    "sampleOutput": "Message 'User logged in' appended to activity_log.txt.\nMessage 'Item added to cart' appended to activity_log.txt.\n(The `activity_log.txt` file will contain both messages, each on a new line.)",
    "explanation": "The `sampleOutput` and the description of `activity_log.txt` confirm that new messages are added to the file without overwriting previous content.\n1. The program uses `fopen(\"activity_log.txt\", \"a\")` to **open the file in append mode (`'a'`)**. If the file exists, the file pointer is positioned at the end of the file; otherwise, a new file is created.\n2. For each user-entered message (e.g., \"User logged in\"), `fprintf(file_pointer, \"%s\\n\", message)` (or `fputs(message, file_pointer); fputc('\\n', file_pointer);`) writes the message followed by a newline character to the *end* of the file.\nThis demonstrates the crucial difference of **append mode**, where new data is always added to the end of the file, making it suitable for logging or extending existing data, unlike write mode (`'w'`) which truncates existing content."
  },
  {
    "topic": "File Handling",
    "level": "Medium",
    "title": "Count Lines in a Text File",
    "description": "Write a C program that counts the total number of lines in a text file. The program should prompt the user to enter the `filename`. It should then open the specified file, read it character by character, and count how many newline characters (`\\n`) it encounters. The final count represents the number of lines. Print the total line count to the console. Crucially, your program must include error handling for the scenario where the specified file does not exist, printing an appropriate 'File not found' message. This problem combines file reading with basic counting logic and error handling.",
    "constraints": "The filename can be up to 50 characters. The file content can have up to 100 lines, with each line up to 200 characters long.",
    "sampleInput": "Enter filename: my_document.txt (Assume my_document.txt contains:\nHeader\nItem 1\nItem 2\nFooter)",
    "sampleOutput": "Number of lines in 'my_document.txt': 4",
    "explanation": "For the given `my_document.txt` (containing `Header\\nItem 1\\nItem 2\\nFooter`):\n1. The program prompts for the filename and uses `fopen(filename, \"r\")` to **open the file in read mode**. It properly handles the case where `fopen` returns `NULL` (file not found).\n2. It then reads the file **character by character** using `fgetc()` in a loop.\n3. Each time the character `\\n` (newline) is encountered, a **counter variable is incremented**. For the sample content, three `\\n` characters would be counted (after 'Header', 'Item 1', 'Item 2').\n4. Since the last line 'Footer' also constitutes a line, and the problem often implicitly assumes a final newline or counts a line if content exists before EOF, the counter is adjusted (e.g., initialized to 1 or incremented once if EOF is reached and the last char wasn't newline). The output `Number of lines in 'my_document.txt': 4` correctly reflects this total, demonstrating character-by-character parsing and conditional counting."
  },
  {
    "topic": "File Handling",
    "level": "Medium",
    "title": "Copy Content from One Text File to Another",
    "description": "Create a C program that copies the entire textual content from a `source_file.txt` to a `destination_file.txt`. The program should prompt the user for both the source and destination filenames. It must open the source file in read mode and the destination file in write mode. Read character by character from the source and write each character to the destination until the end of the source file. If the `source_file.txt` does not exist, print an error message. If the `destination_file.txt` already exists, it should be overwritten. This problem demonstrates file-to-file data transfer.",
    "constraints": "Filenames can be up to 50 characters. Source file size will not exceed 1KB. Ensure error handling for source file not found.",
    "sampleInput": "Enter source filename: original.txt (contains 'Hello Copy')\nEnter destination filename: new_copy.txt",
    "sampleOutput": "Content successfully copied from original.txt to new_copy.txt.\n(The `new_copy.txt` file will then contain 'Hello Copy')",
    "explanation": "Given `original.txt` contains 'Hello Copy' and `new_copy.txt` is the destination:\n1. The program first attempts to `fopen(\"original.txt\", \"r\")` and `fopen(\"new_copy.txt\", \"w\")`. It checks if `original.txt` exists; if not, it reports an error.\n2. Assuming success, it enters a loop that uses `fgetc()` to read **one character at a time** from `original.txt`.\n3. Immediately after reading each character, it uses `fputc()` to **write that same character** to `new_copy.txt`.\n4. This process continues until `fgetc()` returns `EOF` (end of `original.txt`). Both files are then closed. The output `Content successfully copied...` confirms this character-by-character transfer, which effectively duplicates the source file's content into the destination file, overwriting any previous content in the destination."
  },
  {
    "topic": "File Handling",
    "level": "Hard",
    "title": "Student Record Management using Text File (CSV Format)",
    "description": "Define a structure `struct Student` with `roll_no` (integer), `name` (character array, max 30 chars), and `gpa` (floating-point). Write a C program to manage simple student records in a text file named `students.csv`.\n1. **Write Records:** Open `students.csv` in write mode (`'w'`). Prompt the user to enter data (roll number, name, GPA) for 3 students. Write each student's data into the file on a new line, formatted as Comma Separated Values (CSV): `RollNo,Name,GPA` (e.g., `101,Alice Johnson,3.75`).\n2. **Read and Display Records:** After writing, close the file. Then, reopen `students.csv` in read mode (`'r'`). Read each line from the file, parse the data (e.g., using `fscanf` or `fgets` with string parsing), and print the student details to the console in a user-friendly format. Handle potential file open errors. This problem combines structures with file I/O and basic string parsing.",
    "constraints": "Max 3 students for input. Roll No: 1-999. Name: max 30 chars (no commas). GPA: 0.0-4.0 (two decimal places). Ensure correct CSV formatting.",
    "sampleInput": "Student 1:\nRoll No: 101\nName: Alice\nGPA: 3.75\nStudent 2:\nRoll No: 102\nName: Bob\nGPA: 3.50\nStudent 3:\nRoll No: 103\nName: Charlie\nGPA: 3.90",
    "sampleOutput": "Student records successfully written to students.csv.\n\n--- Student Records from File ---\nRoll No: 101, Name: Alice, GPA: 3.75\nRoll No: 102, Name: Bob, GPA: 3.50\nRoll No: 103, Name: Charlie, GPA: 3.90",
    "explanation": "The output reflects two distinct phases of file interaction:\n1.  **Writing:** For each of the 3 students, the program gathers `roll_no`, `name`, and `gpa` from the user. It then uses `fprintf(file_pointer, \"%d,%s,%.2f\\n\", ...)` to write this data to `students.csv`. The `\"%d,%s,%.2f\\n\"` format string ensures the data is written as **Comma Separated Values** with a newline, creating the CSV structure. The `students.csv` file will contain lines like `101,Alice,3.75`.\n2.  **Reading and Displaying:** After writing and closing, the program reopens `students.csv` in read mode. It then typically uses `fscanf(file_pointer, \"%d,%[^,],%f\\n\", ...)` (or `fgets` followed by `sscanf`/`strtok`) in a loop to **read and parse** each line back into `struct Student` variables. Finally, it prints the extracted data in the user-friendly format shown in the output. This problem demonstrates comprehensive **text file handling for structured data**, including writing in a specific format and then parsing it back for display."
  },
  {
    "topic": "File Handling",
    "level": "Hard",
    "title": "Simple Data Logging with Binary Files",
    "description": "Write a C program that demonstrates writing and reading primitive data types (specifically integers) to and from a **binary file**. Prompt the user to enter 5 integer values. Use `fwrite()` to write these 5 integers directly into a binary file named `numbers.bin`. After writing, close the file. Then, reopen `numbers.bin` in binary read mode (`'rb'`), use `fread()` to read the 5 integers back into an array, and print them to the console to verify the data integrity. This problem introduces binary file I/O, which is crucial for efficient storage of structured data.",
    "constraints": "Input integers will be between -1000 and 1000. Ensure `fwrite` and `fread` are used correctly with `sizeof` and count arguments.",
    "sampleInput": "Enter 5 integers: 10 20 30 40 50",
    "sampleOutput": "Successfully wrote 5 integers to numbers.bin.\nNumbers read from numbers.bin: 10 20 30 40 50",
    "explanation": "Given the input integers `10 20 30 40 50`:\n1.  **Writing:** The program opens `numbers.bin` in **binary write mode (`\"wb\"`)**. It then uses `fwrite(&array[0], sizeof(int), 5, file_pointer)` to write the entire array of 5 integers directly to the file. `fwrite` writes the raw binary representation of the integers, not their text equivalents. This is more efficient for numeric data.\n2.  **Reading:** After closing and reopening in **binary read mode (`\"rb\"`)**, the program uses `fread(&read_array[0], sizeof(int), 5, file_pointer)` to read 5 integers back into a new array. `fread` interprets the raw binary data as integers.\n3.  The final output `Numbers read from numbers.bin: 10 20 30 40 50` confirms that the integers were written and read perfectly, preserving their values. This demonstrates the core of **binary file I/O using `fwrite()` and `fread()`**, which is essential for compact and efficient storage of structured data without text conversion overhead."
  },
  {
    "topic": "File Handling",
    "level": "Hard",
    "title": "Search and Update a Record in a Text File",
    "description": "Consider a `products.txt` file where each line represents a product in the format: `ID,Name,Price` (e.g., `101,Laptop,1200.50`). Write a C program that allows a user to update the price of an existing product.\n1. Prompt the user for a `product_id` to search for and a `new_price` (float).\n2. Your program must read all records from `products.txt`.\n3. When the matching `product_id` is found, update its price in memory.\n4. After processing all records, **rewrite the entire set of records (including the updated one)** back to `products.txt`, effectively overwriting the old file content. Print a confirmation message if the product was updated, or 'Product not found' if the ID doesn't exist. This problem involves file reading, parsing, in-memory modification, and full file rewriting.",
    "constraints": "Assume `products.txt` exists initially with at least 2-3 records. Max 5 products in total. IDs are unique. Name max 30 chars. Price 0.01-5000.00. Input ID/price will be valid.",
    "sampleInput": "products.txt (initial content):\n101,Laptop,1200.50\n102,Mouse,25.00\n103,Keyboard,75.00\n\nEnter Product ID to update: 101\nEnter New Price: 1250.00",
    "sampleOutput": "Product 101 price updated to 1250.00.\n(The `products.txt` file will then contain:\n101,Laptop,1250.00\n102,Mouse,25.00\n103,Keyboard,75.00)",
    "explanation": "Given `products.txt` and user input `ID: 101`, `New Price: 1250.00`:\n1. The program opens `products.txt` in read mode and creates a **temporary file** (or reads all into memory).\n2. It reads each line, parsing `ID`, `Name`, `Price`. When `ID 101` is encountered, the `Price` is updated to `1250.00` in the program's memory (e.g., in a `struct` or array of structs).\n3. After processing *all* records (either by storing in memory or writing to a temp file), the original `products.txt` is opened in **write mode (`'w'`)** (truncating its content).\n4. The program then writes *all* the records (including the updated one) from memory back into `products.txt` in the correct CSV format. This is reflected in the `sampleOutput` showing the modified line and unchanged other lines in the file.\nThis complex process demonstrates a common pattern for **updating records in text files**: read all, modify in memory (or a temporary file), then overwrite the original with the updated dataset. This is necessary because text files generally don't support in-place updates easily without fixed-length records."
  },
  {
    "topic": "File Handling",
    "level": "Tricky",
    "title": "Random File Access using `fseek()` and `ftell()`",
    "description": "Write a C program that demonstrates non-sequential (random) access within a file. Follow these steps:\n1. Create and write a string 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' into a text file named `alphabets.txt`.\n2. Close the file.\n3. Reopen `alphabets.txt` in read mode (`'r'`).\n4. Use `fseek()` to move the file pointer to the **10th character** from the beginning of the file (which is at index 9, considering zero-based indexing). Read a single character from this new position and print it.\n5. Immediately after reading, use `ftell()` to determine and print the **current position of the file pointer**.\nIn your explanation, detail how `fseek()` allows movement to specific positions and how `ftell()` reports the current position, helping understand random access capabilities. This problem delves into direct file pointer manipulation.",
    "constraints": "The string to write is fixed. File names are fixed. The file content is simple ASCII characters.",
    "sampleInput": "None",
    "sampleOutput": "Character at 10th position (index 9): J\nCurrent file pointer position: 10\n(User's explanation of `fseek` and `ftell` functionality is expected in the solution.)",
    "explanation": "The output `Character at 10th position (index 9): J` and `Current file pointer position: 10` precisely illustrates **random file access**:\n1. The program first writes 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' to `alphabets.txt`.\n2. After reopening the file, `fseek(file_pointer, 9, SEEK_SET)` is called. `SEEK_SET` indicates that the offset `9` is from the *beginning* of the file. So, the file pointer moves 9 bytes (characters) from the start, landing *at* the character 'J' (since 'A' is at index 0, 'J' is at index 9).\n3. `fgetc(file_pointer)` then reads the character 'J' from this new position.\n4. Immediately after reading 'J', the file pointer automatically advances one position. `ftell(file_pointer)` is then called, which returns `10`, indicating the file pointer is now at the 10th byte (after 'J').\nThis demonstrates that `fseek()` allows **direct, non-sequential jumps** within a file, rather than requiring sequential reading from the start. `ftell()` provides the **current byte offset** of the file pointer, confirming the position after `fseek` and `fgetc` operations, which are fundamental for implementing features like indexed access or skipping parts of a file."
  },
  {
    "topic": "File Handling",
    "level": "Real World Problem",
    "title": "Simple Command-Line To-Do List Manager",
    "description": "Develop a C program that acts as a basic command-line to-do list manager. It should store tasks in a text file named `tasks.txt`. The program must offer a menu-driven interface with the following options:\n1. **Add Task:** Prompts the user to enter a new task description (a single line of text). This task should be appended to `tasks.txt` on a new line.\n2. **View Tasks:** Reads all tasks from `tasks.txt` and prints them to the console, numbering each task sequentially.\n3. **Clear All Tasks:** Empties the `tasks.txt` file, effectively deleting all tasks.\n4. **Exit:** Terminates the program.\nYour program must handle scenarios where `tasks.txt` does not exist (it should be created), and implement robust file opening and closing. This problem integrates multiple file handling operations, loops, and conditional logic in a practical application.",
    "constraints": "Task descriptions can have a maximum length of 100 characters. The `tasks.txt` file can contain up to 10 tasks for practical testing. Input is assumed to be valid per menu choice.",
    "sampleInput": "1 (Add Task)\nBuy groceries\n1 (Add Task)\nClean room\n2 (View Tasks)\n3 (Clear All Tasks)\n2 (View Tasks)\n4 (Exit)",
    "sampleOutput": "--- To-Do List Menu ---\n1. Add Task\n2. View Tasks\n3. Clear All Tasks\n4. Exit\nEnter your choice: 1\nEnter new task: Buy groceries\nTask 'Buy groceries' added.\nEnter your choice: 1\nEnter new task: Clean room\nTask 'Clean room' added.\nEnter your choice: 2\n--- Your Tasks ---\n1. Buy groceries\n2. Clean room\nEnter your choice: 3\nAll tasks cleared from tasks.txt.\nEnter your choice: 2\n--- Your Tasks ---\nNo tasks found.\nEnter your choice: 4\nExiting To-Do List Manager. Goodbye!",
    "explanation": "This comprehensive `sampleOutput` demonstrates the full functionality of the To-Do List Manager:\n- **Add Task (Choice 1):** When a task is entered, the program `fopen()`s `tasks.txt` in **append mode (`'a'`)** and uses `fprintf()` (or `fputs()`) to write the new task string followed by a newline to the end of the file. The `Task '...' added.` message confirms this operation.\n- **View Tasks (Choice 2):** The program `fopen()`s `tasks.txt` in **read mode (`'r'`)**. It then uses a loop with `fgets()` to read tasks line by line. For each line read, it prints the line prefixed with a sequential number (1., 2., etc.). The output `--- Your Tasks ---` followed by the numbered list confirms the tasks were correctly retrieved and displayed.\n- **Clear All Tasks (Choice 3):** This is achieved by `fopen()`ing `tasks.txt` in **write mode (`'w'`)**. Opening a file in `'w'` mode automatically **truncates** its content, effectively emptying it. Immediately closing the file then leaves it empty. The `All tasks cleared...` message confirms this.\n- **View Tasks after Clear:** When 'View Tasks' is chosen again after clearing, the file is empty, so the program correctly prints `No tasks found.`\n- **Error Handling:** The program implicitly handles the initial absence of `tasks.txt` by `'a'` mode creating it if it doesn't exist, and `'r'` mode returning `NULL` which leads to 'No tasks found'.\nThis problem integrates **multiple file handling modes (`'a'`, `'r'`, `'w'`)**, **menu-driven logic**, **input reading**, and **sequential processing** (for viewing) to create a practical, real-world utility."
  }
]
