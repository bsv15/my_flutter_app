[
  {
    "topic": "Pointers",
    "level": "Easy",
    "title": "Address of a Variable and Pointer Declaration",
    "description": "Write a C program that declares an integer variable `num` and initializes it with the value 10. Then, declare a pointer variable named `ptr` of type `int*` (pointer to an integer). Store the **memory address** of `num` into `ptr` using the address-of operator (`&`). Finally, print the following:\n1. The value of `num`.\n2. The memory address of `num` (using `&num`).\n3. The value stored *in* `ptr` (which should be the address of `num`).\nThis problem introduces the fundamental concepts of pointer declaration and obtaining memory addresses.",
    "constraints": "None.",
    "sampleInput": "None",
    "sampleOutput": "Value of num: 10\nAddress of num: 0x7ffee5c01b1c (Example address, will vary)\nValue in ptr (address it holds): 0x7ffee5c01b1c (Example address)",
    "explanation": "The output `Value of num: 10`, `Address of num: 0x...`, and `Value in ptr (address it holds): 0x...` clearly illustrates the basic concepts of pointers:\n1.  `int num = 10;`: An integer variable `num` is created and initialized to `10`.\n2.  `int *ptr;`: A pointer variable `ptr` is declared. The `*` indicates it's a pointer, and `int` specifies that it will point to an integer type.\n3.  `ptr = &num;`: The **address-of operator (`&`)** is used to get the memory address where `num` is stored. This address is then assigned to `ptr`. So, `ptr` now 'points' to `num`.\n4.  `printf(\"Value of num: %d\\n\", num);` prints the content of `num`.\n5.  `printf(\"Address of num: %p\\n\", (void*)&num);` prints the memory address of `num`. The `%p` format specifier is used for printing addresses.\n6.  `printf(\"Value in ptr (address it holds): %p\\n\", (void*)ptr);` prints the content of `ptr`, which is the address it holds (the address of `num`).\nAs shown in the output, the addresses printed for `&num` and `ptr` are identical, demonstrating that `ptr` successfully stores the memory location of `num`. This is the foundational step in understanding how pointers store memory addresses."
  },
  {
    "topic": "Pointers",
    "level": "Easy",
    "title": "Dereferencing a Pointer to Access Value",
    "description": "Create a C program that declares an integer variable `value` and initializes it to 25. Declare another variable, `p`, as a pointer to an integer. Assign the address of `value` to `p`. Now, using **only the pointer `p` and the dereference operator (`*`)**, print the content or value stored at the memory location pointed to by `p`. This exercise is crucial for understanding how to access the actual data that a pointer points to.",
    "constraints": "You must use the pointer and dereference operator to print the value, not the variable `value` directly in the `printf` statement.",
    "sampleInput": "None",
    "sampleOutput": "The value accessed through the pointer is: 25",
    "explanation": "The output `The value accessed through the pointer is: 25` confirms the successful use of the dereference operator:\n1.  `int value = 25;`: An integer `value` is initialized to `25`.\n2.  `int *p;`: A pointer `p` to an integer is declared.\n3.  `p = &value;`: `p` is assigned the memory address of `value`.\n4.  `printf(\"The value accessed through the pointer is: %d\\n\", *p);`: This is the key step. The **dereference operator (`*`)** placed before a pointer variable (`*p`) means \"the value at the memory location pointed to by `p`\". Since `p` points to `value`, `*p` evaluates to the content of `value`, which is `25`.\nThis demonstrates the crucial concept of **dereferencing**, where a pointer's value (an address) is used to retrieve or access the actual data stored at that address. It's the inverse operation of the address-of operator (`&`)."
  },
  {
    "topic": "Pointers",
    "level": "Medium",
    "title": "Modifying Variable Value via Pointer",
    "description": "Write a C program that declares an integer variable `data` and initializes it with a value of 50. Declare an integer pointer `dataPtr` and make it point to the `data` variable. Your task is to use the `dataPtr` (along with the dereference operator) to change the value of `data` from 50 to 100. Print the value of `data` *before* the modification and *after* the modification to demonstrate that the value was indeed changed through the pointer. This problem illustrates the power of pointers to indirectly modify data.",
    "constraints": "The modification must be done solely via the pointer, not by directly assigning to `data` again.",
    "sampleInput": "None",
    "sampleOutput": "Original value of data: 50\nValue of data after modification via pointer: 100",
    "explanation": "The output `Original value of data: 50` and `Value of data after modification via pointer: 100` clearly shows `data`'s value being changed through a pointer:\n1.  `int data = 50;`: `data` is initialized to `50`.\n2.  `int *dataPtr = &data;`: `dataPtr` is declared and points to the address of `data`.\n3.  `printf(\"Original value of data: %d\\n\", data);`: Prints `50`.\n4.  `*dataPtr = 100;`: This is the crucial line. By using the **dereference operator (`*`) on the left side of an assignment**, we are saying \"assign `100` to the memory location pointed to by `dataPtr`.\" Since `dataPtr` points to `data`, this effectively changes the value of `data` to `100`.\n5.  `printf(\"Value of data after modification via pointer: %d\\n\", data);`: Prints `100`.\nThis problem demonstrates the powerful capability of pointers: they not only allow reading values from a memory location but also **allow modifying the content of the variable they point to indirectly**. This is fundamental for concepts like 'call by reference' in functions."
  },
  {
    "topic": "Pointers",
    "level": "Medium",
    "title": "Pointer Arithmetic with Arrays",
    "description": "Declare an integer array `int arr[] = {10, 20, 30, 40, 50};`. Declare an integer pointer `ptr` and initialize it to point to the **first element** of this array (i.e., `ptr = arr;` or `ptr = &arr[0];`). Using **only pointer arithmetic** (e.g., `ptr + N` and `*(ptr + N)`), perform the following actions and print the results:\n1. Access and print the value of the third element (which is 30).\n2. Access and print the value of the fifth element (which is 50).\nThis problem clearly demonstrates how pointer arithmetic is inherently tied to array indexing in C.",
    "constraints": "Array size is fixed at 5. You must use pointer arithmetic, not `arr[index]` notation, to access elements after initialization.",
    "sampleInput": "None",
    "sampleOutput": "Value of the third element using pointer arithmetic: 30\nValue of the fifth element using pointer arithmetic: 50",
    "explanation": "Given `int arr[] = {10, 20, 30, 40, 50};` and `int *ptr = arr;`:\n1.  **Accessing the third element (value 30):**\n    -   Arrays in C are zero-indexed, so the third element is at index `2`.\n    -   `ptr + 2` refers to the memory address two integer-sizes *after* the address `ptr` holds (which is the address of `arr[0]`). This effectively points to `arr[2]`.\n    -   `*(ptr + 2)` **dereferences** this new address, giving us the value stored there, which is `30`.\n2.  **Accessing the fifth element (value 50):**\n    -   The fifth element is at index `4`.\n    -   `ptr + 4` refers to the memory address four integer-sizes *after* `ptr`.\n    -   `*(ptr + 4)` dereferences this address, giving us `50`.\nThe output confirms these values. This problem illustrates the powerful concept of **pointer arithmetic**, where adding or subtracting an integer `N` from a pointer moves the pointer `N` *sizeof(data_type)* bytes in memory. This close relationship makes pointers highly efficient for **traversing arrays** in C, as `arr[i]` is often internally translated to `*(arr + i)` by the compiler."
  },
  {
    "topic": "Pointers",
    "level": "Medium",
    "title": "Swapping Values using Pointers (Call by Reference)",
    "description": "Write a C program that defines a function named `swap`. This function should take two integer **pointers** (i.e., `int *a, int *b`) as arguments. The `swap` function's purpose is to exchange the values of the two integer variables that these pointers point to. In your `main` function, declare two integer variables (e.g., `num1`, `num2`), prompt the user to input their values, then call the `swap` function by passing the *addresses* of `num1` and `num2`. Finally, print the values of `num1` and `num2` in `main` to confirm that they have been successfully swapped. This problem is a classic demonstration of 'call by reference' using pointers.",
    "constraints": "The `swap` function must use pointers. Input integers will be between -100 and 100.",
    "sampleInput": "Enter first number: 5\nEnter second number: 10",
    "sampleOutput": "Before swap: num1 = 5, num2 = 10\nAfter swap: num1 = 10, num2 = 5",
    "explanation": "Given input `num1 = 5`, `num2 = 10`:\n1.  `main` prints `Before swap: num1 = 5, num2 = 10`.\n2.  `swap(&num1, &num2);` is called. The **addresses** of `num1` and `num2` are passed to the `swap` function's parameters `a` and `b` (which are `int *` pointers).\n3.  Inside `swap`:\n    -   `int temp = *a;`: `temp` gets the value at the address pointed to by `a` (which is the value of `num1`, i.e., `5`).\n    -   `*a = *b;`: The value at the address pointed to by `b` (value of `num2`, `10`) is assigned to the address pointed to by `a` (which is `num1`). So, `num1` becomes `10`.\n    -   `*b = temp;`: The value of `temp` (`5`) is assigned to the address pointed to by `b` (which is `num2`). So, `num2` becomes `5`.\n4.  When `swap` returns, `num1` in `main` is now `10`, and `num2` is `5`.\n5.  `main` prints `After swap: num1 = 10, num2 = 5`.\nThis problem is the quintessential example of **call by reference** in C using pointers. Instead of passing copies of values (call by value), we pass addresses, allowing the function to directly access and modify the original variables in the calling scope, thereby achieving the swap."
  },
  {
    "topic": "Pointers",
    "level": "Hard",
    "title": "Dynamic Memory Allocation with `malloc()` and `free()` for an Array",
    "description": "Write a C program that demonstrates **dynamic memory allocation** for an array of integers. Prompt the user to enter the desired `size` for the array (e.g., 5). Use `malloc()` to allocate memory for `size` integers. If `malloc()` fails (returns `NULL`), print an error message and exit. Otherwise, prompt the user to enter `size` integer values, storing them in the dynamically allocated array using pointer notation. Finally, print all the stored values and then **release the allocated memory using `free()`**. This problem introduces memory management fundamentals in C.",
    "constraints": "The array size `N` will be between 1 and 10. Input integers will be between -1000 and 1000.",
    "sampleInput": "Enter number of elements: 3\nEnter element 1: 10\nEnter element 2: 20\nEnter element 3: 30",
    "sampleOutput": "Dynamically allocated array elements: 10 20 30\nMemory freed successfully.",
    "explanation": "Given `size = 3` and inputs `10, 20, 30`:\n1.  `int *arr = (int *)malloc(size * sizeof(int));` is called. This requests a block of memory large enough to hold `3` integers from the heap. `malloc` returns a `void*` which is cast to `int*`.\n2.  The program checks if `arr` is `NULL`. If not, it proceeds.\n3.  A loop prompts for `3` integers. Each integer is read and stored using pointer notation, e.g., `*(arr + i) = value;` or `arr[i] = value;` (which is equivalent due to array-pointer decay).\n4.  Another loop prints the stored values: `10 20 30`.\n5.  `free(arr);` is called. This is critical. It **releases the dynamically allocated memory** back to the system, preventing a **memory leak**. `arr` now becomes a dangling pointer, which should ideally be set to `NULL` to avoid accidental misuse.\nThe output clearly confirms that memory was allocated, used, and then freed. This problem is a foundational example of **dynamic memory management** in C, allowing programs to allocate memory at runtime based on user input, rather than compile-time fixed sizes, and critically, how to **clean up (free)** that memory when no longer needed."
  },
  {
    "topic": "Pointers",
    "level": "Hard",
    "title": "String Reversal using Pointers (In-Place)",
    "description": "Implement a C function `void reverseString(char *str)` that takes a pointer to a null-terminated string as its argument. This function should reverse the given string **in-place** (i.e., modify the original string directly) using **only pointer arithmetic**, without using array indexing (e.g., `str[i]`). You will likely need two pointers, one starting at the beginning and one at the end of the string, swapping characters as they move towards the center. In `main`, prompt the user to enter a string, call your `reverseString` function, and then print the now-reversed string. This problem deeply tests pointer manipulation and understanding of string termination.",
    "constraints": "The input string will have a maximum length of 50 characters. It will consist only of lowercase English letters.",
    "sampleInput": "Enter a string: hello",
    "sampleOutput": "Original string: hello\nReversed string: olleh",
    "explanation": "For the input string \"hello\":\n1.  `main` takes input \"hello\" into a character array. It then calls `reverseString(\"hello\")` (passing a pointer to the first character).\n2.  Inside `reverseString`:\n    -   One pointer, say `start_ptr`, is initialized to `str` (points to 'h').\n    -   Another pointer, say `end_ptr`, is advanced to the end of the string (just before the null terminator) using a loop or `strlen` (e.g., `while (*end_ptr != '\\0') end_ptr++; end_ptr--;`). So `end_ptr` points to 'o'.\n    -   A `while (start_ptr < end_ptr)` loop begins:\n        -   **Iteration 1:** `*start_ptr` ('h') is swapped with `*end_ptr` ('o'). String becomes \"olle\" + 'h'. `start_ptr` moves to 'e', `end_ptr` moves to 'l'.\n        -   **Iteration 2:** `*start_ptr` ('e') is swapped with `*end_ptr` ('l'). String becomes \"oll\" + 'e' + 'h'. `start_ptr` moves to 'l', `end_ptr` moves to 'l'.\n        -   The loop terminates as `start_ptr` is no longer less than `end_ptr` (they meet or cross at the middle 'l').\nThe original string, modified in-place, is now \"olleh\". The output confirms this. This problem is a challenging demonstration of **in-place string manipulation using only pointer arithmetic**, requiring a deep understanding of how pointers traverse memory and how the null terminator marks the end of a C string. It showcases a common algorithmic pattern."
  },
  {
    "topic": "Pointers",
    "level": "Hard",
    "title": "Sum of Array Elements using Pointer to a Function",
    "description": "Write a C program that defines a function `int sumArray(int *arr, int size)` that takes an integer pointer (representing the beginning of an array) and an integer `size` (the number of elements in the array) as arguments. This function should calculate and return the sum of all elements in the array using **only pointer arithmetic** (e.g., `*(arr + i)` or `*arr++` in a loop), avoiding direct array indexing (`arr[i]`). In `main`, declare an array (e.g., `int myArray[] = {1, 2, 3, 4, 5};`), pass it to your `sumArray` function, and print the returned sum. This problem reinforces passing arrays to functions via pointers and pointer arithmetic for traversal.",
    "constraints": "Array size up to 10. Elements will be integers between -100 and 100. The sum will fit within an `int`.",
    "sampleInput": "None (array is hardcoded or user-inputted in main)",
    "sampleOutput": "The sum of array elements is: 15",
    "explanation": "Given `int myArray[] = {1, 2, 3, 4, 5};`:\n1.  In `main`, `sumArray(myArray, 5);` is called. When an array name (`myArray`) is passed to a function, it **decays into a pointer to its first element**. So, `arr` in `sumArray` receives the address of `myArray[0]`.\n2.  Inside `sumArray`:\n    -   An integer `total_sum` is initialized to `0`.\n    -   A loop iterates `size` (5) times. Instead of `arr[i]`, the loop uses `*(arr + i)` (or can use `*arr++` within a loop that moves the pointer):\n        -   `*(arr + 0)` is `1` (added to sum).\n        -   `*(arr + 1)` is `2` (added to sum).\n        -   ... and so on.\n        -   `*(arr + 4)` is `5` (added to sum).\n3.  The loop accumulates the sum: `1 + 2 + 3 + 4 + 5 = 15`.\n4.  `sumArray` returns `15`, which `main` then prints. This problem elegantly demonstrates two key pointer concepts: how arrays are **passed to functions using pointers** (array-pointer decay) and how **pointer arithmetic is used to traverse and access array elements**, often as an alternative to array indexing, reinforcing the close relationship between pointers and arrays in C."
  },
  {
    "topic": "Pointers",
    "level": "Tricky",
    "title": "Pointers to Pointers (Double Pointers)",
    "description": "Write a C program that demonstrates the concept of a **pointer to a pointer** (also known as a double pointer). Follow these steps:\n1. Declare an integer variable `x` and initialize it with the value 10.\n2. Declare an integer pointer `p1` and make it point to `x`.\n3. Declare a pointer `p2` that is a pointer to an `int` pointer (i.e., `int **p2;`). Make `p2` point to `p1`.\nNow, using **only `p2` and the dereference operator (`*`)**, perform the following actions and print the results:\n1. Access and print the value of `x`.\n2. Change the value of `x` to 20.\nPrint the final value of `x` to confirm the change. This problem visually explains how multiple levels of indirection work.",
    "constraints": "None. The values are fixed for demonstration.",
    "sampleInput": "None",
    "sampleOutput": "Value of x (accessed via double pointer): 10\nNew value of x (after modification via double pointer): 20",
    "explanation": "The output `Value of x (accessed via double pointer): 10` and `New value of x (after modification via double pointer): 20` showcases the behavior of a **double pointer**:\n1.  `int x = 10;`: `x` stores `10` at a certain memory address (e.g., `0x1000`).\n2.  `int *p1 = &x;`: `p1` is a pointer to an `int`. It stores the address of `x` (e.g., `0x1000`). `p1` itself has its own address (e.g., `0x2000`).\n3.  `int **p2 = &p1;`: `p2` is a pointer to an `int` pointer. It stores the address of `p1` (e.g., `0x2000`).\n\nNow, using `p2`:\n-   **Accessing value of `x`:**\n    -   `*p2`: Dereferencing `p2` gives us the *value* stored at `p2`'s address, which is the address of `p1` (i.e., `0x1000`). So, `*p2` is `p1`.\n    -   `**p2`: Dereferencing `*p2` (which is `p1`) gives us the value at `p1`'s address, which is the value of `x` (`10`). So, `printf(\"%d\", **p2);` prints `10`.\n-   **Modifying value of `x`:**\n    -   `**p2 = 20;`: Using `**p2` on the left side of an assignment means \"assign `20` to the memory location pointed to by the pointer that `*p2` points to.\" Effectively, it means \"assign `20` to `x`.\"\n-   The final `printf(\"%d\", x);` confirms `x` is now `20`.\nThis problem clearly illustrates **multiple levels of indirection**. `p2` points to `p1`, which in turn points to `x`. By applying the dereference operator twice (`**`), we can access and modify the ultimate target variable `x`. Double pointers are often used in advanced scenarios like modifying pointers passed to functions or working with 2D dynamic arrays."
  },
  {
    "topic": "Pointers",
    "level": "Real World Problem",
    "title": "Dynamic Management of Student Names",
    "description": "Develop a C program that dynamically manages a list of student names. The program should first prompt the user for the number of students `N`. Then, for each student, it should dynamically allocate memory for their name (a string) using `malloc` based on the length of the name entered by the user. Store pointers to these dynamically allocated names in an array of `char*` (e.g., `char **studentNames`). After all names are entered, print each student's name. Finally, ensure all dynamically allocated memory for the names, and the array of pointers itself, is correctly `free`d to prevent memory leaks. This problem simulates a real-world scenario of handling variable-length strings.",
    "constraints": "Number of students `N` will be between 1 and 3. Each student name will have a maximum length of 20 characters (including null terminator). Names will consist of alphabetic characters only.",
    "sampleInput": "Enter number of students: 2\nEnter name for student 1: Alice\nEnter name for student 2: Bob",
    "sampleOutput": "Student Names:\n1. Alice\n2. Bob\nAll memory freed successfully.",
    "explanation": "For the input `N = 2` and names \"Alice\", \"Bob\":\n1.  `main` prompts for `N`.\n2.  `char **studentNames = (char **)malloc(N * sizeof(char *));`: Memory is dynamically allocated for an **array of character pointers**. This array will hold the starting addresses of each student's name string.\n3.  A loop runs `N` times:\n    -   For each student, `fgets()` reads the name (e.g., \"Alice\\n\"). `strlen()` determines its length.\n    -   `studentNames[i] = (char *)malloc(name_length + 1);`: Memory is dynamically allocated for the *actual string data* itself, using `name_length + 1` for the null terminator. This address is stored in `studentNames[i]`.\n    -   `strcpy()` (or similar) copies the input name into this newly allocated memory.\n4.  After all names are entered, another loop prints each student's name by dereferencing `studentNames[i]` (which points to the start of each name string).\n5.  **Memory Cleanup:** This is crucial for real-world applications.\n    -   A loop calls `free(studentNames[i]);` for each `i`, releasing the memory allocated for **each individual name string**.\n    -   Finally, `free(studentNames);` is called to release the memory allocated for the **array of pointers itself**.\nThis problem is a robust demonstration of **dynamic memory management** for variable-length data (strings) using a combination of single and double pointers. It highlights how to allocate memory for a collection of strings where each string might have a different size, and the importance of **systematic memory deallocation** to prevent leaks."
  }
]
