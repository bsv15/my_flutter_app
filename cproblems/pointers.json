[
  {
    "topic": "Pointers",
    "level": "Easy",
    "title": "Address of a Variable and Pointer Declaration",
    "description": "Write a C program that declares an integer variable `num` and initializes it with the value 10. Then, declare a pointer variable named `ptr` of type `int*` (pointer to an integer). Store the **memory address** of `num` into `ptr` using the address-of operator (`&`). Finally, print the following:\n1. The value of `num`.\n2. The memory address of `num` (using `&num`).\n3. The value stored *in* `ptr` (which should be the address of `num`).\nThis problem introduces the fundamental concepts of pointer declaration and obtaining memory addresses.",
    "constraints": "None.",
    "sampleInput": "None",
    "sampleOutput": "Value of num: 10\nAddress of num: 0x7ffee5c01b1c (Example address, will vary)\nValue in ptr (address it holds): 0x7ffee5c01b1c (Example address)"
  },
  {
    "topic": "Pointers",
    "level": "Easy",
    "title": "Dereferencing a Pointer to Access Value",
    "description": "Create a C program that declares an integer variable `value` and initializes it to 25. Declare another variable, `p`, as a pointer to an integer. Assign the address of `value` to `p`. Now, using **only the pointer `p` and the dereference operator (`*`)**, print the content or value stored at the memory location pointed to by `p`. This exercise is crucial for understanding how to access the actual data that a pointer points to.",
    "constraints": "You must use the pointer and dereference operator to print the value, not the variable `value` directly in the `printf` statement.",
    "sampleInput": "None",
    "sampleOutput": "The value accessed through the pointer is: 25"
  },
  {
    "topic": "Pointers",
    "level": "Medium",
    "title": "Modifying Variable Value via Pointer",
    "description": "Write a C program that declares an integer variable `data` and initializes it with a value of 50. Declare an integer pointer `dataPtr` and make it point to the `data` variable. Your task is to use the `dataPtr` (along with the dereference operator) to change the value of `data` from 50 to 100. Print the value of `data` *before* the modification and *after* the modification to demonstrate that the value was indeed changed through the pointer. This problem illustrates the power of pointers to indirectly modify data.",
    "constraints": "The modification must be done solely via the pointer, not by directly assigning to `data` again.",
    "sampleInput": "None",
    "sampleOutput": "Original value of data: 50\nValue of data after modification via pointer: 100"
  },
  {
    "topic": "Pointers",
    "level": "Medium",
    "title": "Pointer Arithmetic with Arrays",
    "description": "Declare an integer array `int arr[] = {10, 20, 30, 40, 50};`. Declare an integer pointer `ptr` and initialize it to point to the **first element** of this array (i.e., `ptr = arr;` or `ptr = &arr[0];`). Using **only pointer arithmetic** (e.g., `ptr + N` and `*(ptr + N)`), perform the following actions and print the results:\n1.  Access and print the value of the third element (which is 30).\n2.  Access and print the value of the fifth element (which is 50).\nThis problem clearly demonstrates how pointer arithmetic is inherently tied to array indexing in C.",
    "constraints": "Array size is fixed at 5. You must use pointer arithmetic, not `arr[index]` notation, to access elements after initialization.",
    "sampleInput": "None",
    "sampleOutput": "Value of the third element using pointer arithmetic: 30\nValue of the fifth element using pointer arithmetic: 50"
  },
  {
    "topic": "Pointers",
    "level": "Medium",
    "title": "Swapping Values using Pointers (Call by Reference)",
    "description": "Write a C program that defines a function named `swap`. This function should take two integer **pointers** (i.e., `int *a, int *b`) as arguments. The `swap` function's purpose is to exchange the values of the two integer variables that these pointers point to. In your `main` function, declare two integer variables (e.g., `num1`, `num2`), prompt the user to input their values, then call the `swap` function by passing the *addresses* of `num1` and `num2`. Finally, print the values of `num1` and `num2` in `main` to confirm that they have been successfully swapped. This problem is a classic demonstration of 'call by reference' using pointers.",
    "constraints": "The `swap` function must use pointers. Input integers will be between -100 and 100.",
    "sampleInput": "Enter first number: 5\nEnter second number: 10",
    "sampleOutput": "Before swap: num1 = 5, num2 = 10\nAfter swap: num1 = 10, num2 = 5"
  },
  {
    "topic": "Pointers",
    "level": "Hard",
    "title": "Dynamic Memory Allocation with `malloc()` and `free()` for an Array",
    "description": "Write a C program that demonstrates **dynamic memory allocation** for an array of integers. Prompt the user to enter the desired `size` for the array (e.g., 5). Use `malloc()` to allocate memory for `size` integers. If `malloc()` fails (returns `NULL`), print an error message and exit. Otherwise, prompt the user to enter `size` integer values, storing them in the dynamically allocated array using pointer notation. Finally, print all the stored values and then **release the allocated memory using `free()`**. This problem introduces memory management fundamentals in C.",
    "constraints": "The array size `N` will be between 1 and 10. Input integers will be between -1000 and 1000.",
    "sampleInput": "Enter number of elements: 3\nEnter element 1: 10\nEnter element 2: 20\nEnter element 3: 30",
    "sampleOutput": "Dynamically allocated array elements: 10 20 30\nMemory freed successfully."
  },
  {
    "topic": "Pointers",
    "level": "Hard",
    "title": "String Reversal using Pointers (In-Place)",
    "description": "Implement a C function `void reverseString(char *str)` that takes a pointer to a null-terminated string as its argument. This function should reverse the given string **in-place** (i.e., modify the original string directly) using **only pointer arithmetic**, without using array indexing (e.g., `str[i]`). You will likely need two pointers, one starting at the beginning and one at the end of the string, swapping characters as they move towards the center. In `main`, prompt the user to enter a string, call your `reverseString` function, and then print the now-reversed string. This problem deeply tests pointer manipulation and understanding of string termination.",
    "constraints": "The input string will have a maximum length of 50 characters. It will consist only of lowercase English letters.",
    "sampleInput": "Enter a string: hello",
    "sampleOutput": "Original string: hello\nReversed string: olleh"
  },
  {
    "topic": "Pointers",
    "level": "Hard",
    "title": "Sum of Array Elements using Pointer to a Function",
    "description": "Write a C program that defines a function `int sumArray(int *arr, int size)` that takes an integer pointer (representing the beginning of an array) and an integer `size` (the number of elements in the array) as arguments. This function should calculate and return the sum of all elements in the array using **only pointer arithmetic** (e.g., `*(arr + i)` or `*arr++` in a loop), avoiding direct array indexing (`arr[i]`). In `main`, declare an array (e.g., `int myArray[] = {1, 2, 3, 4, 5};`), pass it to your `sumArray` function, and print the returned sum. This problem reinforces passing arrays to functions via pointers and pointer arithmetic for traversal.",
    "constraints": "Array size up to 10. Elements will be integers between -100 and 100. The sum will fit within an `int`.",
    "sampleInput": "None (array is hardcoded or user-inputted in main)",
    "sampleOutput": "The sum of array elements is: 15"
  },
  {
    "topic": "Pointers",
    "level": "Tricky",
    "title": "Pointers to Pointers (Double Pointers)",
    "description": "Write a C program that demonstrates the concept of a **pointer to a pointer** (also known as a double pointer). Follow these steps:\n1.  Declare an integer variable `x` and initialize it with the value 10.\n2.  Declare an integer pointer `p1` and make it point to `x`.\n3.  Declare a pointer `p2` that is a pointer to an `int` pointer (i.e., `int **p2;`). Make `p2` point to `p1`.\nNow, using **only `p2` and the dereference operator (`*`)**, perform the following actions and print the results:\n1.  Access and print the value of `x`.\n2.  Change the value of `x` to 20.\nPrint the final value of `x` to confirm the change. This problem visually explains how multiple levels of indirection work.",
    "constraints": "None. The values are fixed for demonstration.",
    "sampleInput": "None",
    "sampleOutput": "Value of x (accessed via double pointer): 10\nNew value of x (after modification via double pointer): 20"
  },
  {
    "topic": "Pointers",
    "level": "Real World Problem",
    "title": "Dynamic Management of Student Names",
    "description": "Develop a C program that dynamically manages a list of student names. The program should first prompt the user for the number of students `N`. Then, for each student, it should dynamically allocate memory for their name (a string) using `malloc` based on the length of the name entered by the user. Store pointers to these dynamically allocated names in an array of `char*` (e.g., `char **studentNames`). After all names are entered, print each student's name. Finally, ensure all dynamically allocated memory for the names, and the array of pointers itself, is correctly `free`d to prevent memory leaks. This problem simulates a real-world scenario of handling variable-length strings.",
    "constraints": "Number of students `N` will be between 1 and 3. Each student name will have a maximum length of 20 characters (including null terminator). Names will consist of alphabetic characters only.",
    "sampleInput": "Enter number of students: 2\nEnter name for student 1: Alice\nEnter name for student 2: Bob",
    "sampleOutput": "Student Names:\n1. Alice\n2. Bob\nAll memory freed successfully."
  }
]
