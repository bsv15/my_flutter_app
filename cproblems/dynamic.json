[
  {
    "topic": "Dynamic Memory Allocation",
    "level": "Easy",
    "title": "Allocate and Free an Integer",
    "description": "This is your introduction to `malloc()` and `free()`, essential functions for managing memory at runtime. Your program should: \n1. Use `malloc()` to dynamically allocate memory for a single integer. \n2. Check if the allocation was successful (if `malloc` returns `NULL`). If not, print an error message. \n3. If successful, store an integer value (e.g., 100) into this dynamically allocated memory using the pointer returned by `malloc`. \n4. Print the value stored in the dynamically allocated memory. \n5. Use `free()` to release the allocated memory back to the system. \nThis problem teaches the basic workflow of dynamic allocation and deallocation for a single variable. The Flutter app will trigger this process.",
    "constraints": "Allocate memory for one `int`. Check for `NULL` return from `malloc`. Free the allocated memory.",
    "sampleInput": "None",
    "sampleOutput": "Dynamically allocated integer: 100\nMemory freed successfully.\n"
  },
  {
    "topic": "Dynamic Memory Allocation",
    "level": "Easy",
    "title": "Dynamic Array of Integers",
    "description": "Extend your understanding to dynamically allocate memory for an array. Your program should: \n1. Read an integer 'N' from the user, representing the desired size of an integer array. \n2. Use `malloc()` to dynamically allocate memory for an array of 'N' integers. \n3. Check for `NULL` return from `malloc`. \n4. If successful, read 'N' integers from the user and store them in the dynamically allocated array. \n5. Print all elements of the array. \n6. Use `free()` to deallocate the memory. \nThis problem demonstrates creating arrays whose size is determined at runtime, a powerful feature of dynamic memory. The Flutter app will provide N and then N integers.",
    "constraints": "N will be between 1 and 10. All integers between -100 and 100. Check for `NULL` and free memory.",
    "sampleInput": "3\n10\n20\n30",
    "sampleOutput": "Dynamically allocated array elements: 10 20 30\n"
  },
  {
    "topic": "Dynamic Memory Allocation",
    "level": "Medium",
    "title": "Calculate Sum of Dynamic Array",
    "description": "Combine dynamic memory allocation with array traversal. Your program should: \n1. Read an integer 'N' from the user for array size. \n2. Dynamically allocate an array of 'N' integers using `malloc()`. \n3. Read 'N' integers into this array. \n4. Calculate the sum of all elements in the dynamically allocated array using a loop. \n5. Print the sum. \n6. Free the allocated memory. \nThis reinforces both dynamic allocation and basic array processing. The Flutter app will provide N and then N integers.",
    "constraints": "N between 1 and 100. Integers between -100 and 100. Check for `NULL` and free memory.",
    "sampleInput": "5\n1\n2\n3\n4\n5",
    "sampleOutput": "Sum of dynamic array elements: 15\n"
  },
  {
    "topic": "Dynamic Memory Allocation",
    "level": "Medium",
    "title": "Using `calloc()` and `realloc()`",
    "description": "Explore `calloc()` (for zero-initialized memory) and `realloc()` (for resizing). Your program should: \n1. Read an integer `initial_size`. Use `calloc()` to allocate memory for an array of `initial_size` integers. Print the elements (should be all zeros). \n2. Read a `new_size`. Use `realloc()` to resize the allocated memory to `new_size` integers. If `realloc` fails, print an error and `free` the old memory. \n3. Fill the new array with values from 1 to `new_size` (or simply print existing if `new_size` < `initial_size`). Print the elements. \n4. Free the final allocated memory. \nThis problem introduces alternatives to `malloc` and demonstrates resizing memory blocks. The Flutter app will provide initial_size and new_size.",
    "constraints": "`initial_size` between 1 and 5. `new_size` between 1 and 10. Check `NULL` returns. Ensure memory is always freed.",
    "sampleInput": "3\n5",
    "sampleOutput": "Initial array (calloc): 0 0 0\nResized array (realloc) to 5 elements: 0 0 0 4 5 (example values for new elements if not filled)\n"
  },
  {
    "topic": "Dynamic Memory Allocation",
    "level": "Hard",
    "title": "Dynamic 2D Array (Matrix)",
    "description": "Allocate memory for a 2D array (matrix) dynamically. This requires allocating an array of pointers, and then allocating memory for each row. Your program should: \n1. Read two integers, `rows` and `cols`, for the dimensions of the matrix. \n2. Dynamically allocate a 2D array of `rows` x `cols` integers. (Hint: `int **matrix = (int **)malloc(rows * sizeof(int *));` then a loop for each row). \n3. Check for `NULL` at each allocation step. \n4. Read `rows * cols` integers from the user and populate the matrix. \n5. Print the matrix in a row-by-row format. \n6. **Crucially, free the memory in the correct order:** first each row, then the array of pointers. \nThis problem is a significant step in understanding complex dynamic memory structures and disciplined deallocation. The Flutter app will provide rows, cols, and then all matrix elements.",
    "constraints": "`rows` and `cols` between 1 and 5. Integers between -10 and 10. Strict memory allocation and deallocation.",
    "sampleInput": "2\n3\n1 2 3\n4 5 6",
    "sampleOutput": "Matrix:\n1 2 3\n4 5 6\n"
  },
  {
    "topic": "Dynamic Memory Allocation",
    "level": "Hard",
    "title": "String Duplication using Dynamic Memory",
    "description": "Create a function to duplicate a string using dynamic memory. Create a function `char* duplicateString(const char* original_string)` that takes a C string (character array) as input. Inside the function: \n1. Determine the length of the `original_string` (using `strlen()` or a loop). \n2. Dynamically allocate exactly enough memory for a new string to hold the `original_string` plus its null terminator. \n3. Copy the characters from `original_string` to the newly allocated memory (using `strcpy()` or a loop). \n4. Return the pointer to the newly created, duplicated string. \nIn `main`, read a string, call `duplicateString`, print the duplicated string, and then `free` the dynamically allocated memory. This problem reinforces string manipulation with dynamic memory. The Flutter app will provide the string.",
    "constraints": "Input string max 49 characters. Function must return `char*` and handle `NULL` if allocation fails. Memory must be freed in `main`.",
    "sampleInput": "programming",
    "sampleOutput": "Original: programming\nDuplicated: programming\n"
  },
  {
    "topic": "Dynamic Memory Allocation",
    "level": "Tricky",
    "title": "Dynamic Array Resize and Fill",
    "description": "Combine dynamic memory allocation, resizing, and careful data handling. Your program should: \n1. Read an `initial_count` (e.g., 3). Dynamically allocate an `int` array of this size and fill it with values (e.g., 10, 20, 30). Print the array. \n2. Read a `new_count` (e.g., 5). Use `realloc()` to resize the array to `new_count`. \n3. **Tricky Part:** If `new_count` is greater than `initial_count`, the *newly added* elements should be initialized to 0. If `new_count` is less than `initial_count`, the array should be truncated, but existing elements should remain. \n4. Print the array after resizing, showing the updated content. \n5. Free the memory. \nThis problem tests your understanding of `realloc` behavior, particularly how it preserves existing data and how new memory is initialized (or not) by `realloc`. You'll need to manually initialize new elements. The Flutter app will provide initial_count, elements, and new_count.",
    "constraints": "`initial_count` and `new_count` between 1 and 10. Integers for initial fill between 1 and 100. Handle `realloc` failure. Ensure new elements are zero-initialized if `new_count > initial_count`.",
    "sampleInput": "3\n10 20 30\n5",
    "sampleOutput": "Original array: 10 20 30\nResized array: 10 20 30 0 0\n"
  },
  {
    "topic": "Dynamic Memory Allocation",
    "level": "Real World Problem",
    "title": "Dynamic Employee Database: Add/Remove IDs",
    "description": "Simulate a basic employee ID management system using dynamic arrays. Your program will manage a list of integer employee IDs. \n\nYour program should: \n1. Start with an empty list (a `NULL` pointer to an `int` array and `current_size = 0`). \n2. Implement a loop that repeatedly asks the user for an operation: 'A' (Add ID), 'R' (Remove ID), 'P' (Print all IDs), 'Q' (Quit). \n3. **Add ID ('A'):** Read a new `employee_id`. Use `realloc()` to increase the array size by 1. Add the `employee_id` to the end. Check for `realloc` failure. \n4. **Remove ID ('R'):** Read an `employee_id` to remove. Search for it. If found, shift elements to fill the gap and `realloc()` to decrease size by 1. If not found, print 'ID not found.' \n5. **Print IDs ('P'):** Print all current employee IDs, or 'No employees.' if empty. \n\n**Tricky Part:** Managing the `current_size` and handling `realloc` for both growth and shrinking. Removing an element means careful shifting. This problem demonstrates a practical use of dynamic arrays for growing/shrinking data collections. The Flutter app will send operation codes and IDs.",
    "constraints": "Employee IDs are positive integers up to 1000. Max 10 employees. Handle `realloc` failures and 'ID not found' for removal. Ensure no memory leaks and array is correctly managed.",
    "sampleInput": "A 101\nA 102\nP\nR 101\nP\nQ",
    "sampleOutput": "Added ID: 101\nAdded ID: 102\nEmployees: 101 102\nRemoved ID: 101\nEmployees: 102\nExiting.\n"
  },
  {
    "topic": "Dynamic Memory Allocation",
    "level": "Real World Problem",
    "title": "Data Logging: Dynamic Storage for Sensor Readings",
    "description": "Imagine a sensor that takes readings over time. You don't know how many readings there will be, so you need dynamic storage. Your program should: \n1. Start with an empty dynamic array for `float` sensor readings. \n2. Repeatedly ask the user to enter a sensor reading (float). The user enters -999.0 to stop. \n3. For each valid reading: Use `realloc()` to increase the array size by one float, add the new reading. If `realloc` fails, print an error and stop. \n4. After all readings are entered, calculate the `average` of all readings and print it, formatted to two decimal places. Also, print the `total number of readings`. \n5. Finally, `free` the allocated memory. \n\n**Tricky Part:** The core challenge is the continuous `realloc` within a loop, handling potential failures, and correctly updating the pointer and size. This simulates a real-world scenario where data size is unpredictable. The Flutter app will stream sensor readings.",
    "constraints": "Sensor readings are floats between -50.0 and 100.0. Sentinel value is -999.0. Handle `realloc` failure (e.g., return early and free existing). Calculate average and count. Free memory properly.",
    "sampleInput": "22.5\n23.1\n21.9\n-999.0",
    "sampleOutput": "Reading added: 22.50\nReading added: 23.10\nReading added: 21.90\nTotal readings: 3\nAverage reading: 22.50\nMemory freed.\n"
  }
]
