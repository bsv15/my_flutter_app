[
  {
    "topic": "Dynamic Memory Allocation",
    "level": "Easy",
    "title": "Allocate and Free an Integer Array",
    "description": "Write a C program that dynamically allocates memory for an array of 5 integers using `malloc()`. After allocation, initialize each element of the array with its index (i.e., `array[0] = 0`, `array[1] = 1`, etc.). Print all elements of the array. Finally, free the allocated memory using `free()` to prevent memory leaks. This problem introduces the basic syntax and lifecycle of `malloc` and `free`.",
    "constraints": "Array size is fixed at 5. Must use `malloc()` and `free()`. Handle `NULL` check for `malloc()` return.",
    "sampleInput": "None",
    "sampleOutput": "Array elements: 0 1 2 3 4"
  },
  {
    "topic": "Dynamic Memory Allocation",
    "level": "Easy",
    "title": "Allocate Memory for a Single Variable and Print",
    "description": "Create a C program that dynamically allocates memory for a single `double` variable using `malloc()`. Assign a floating-point value (e.g., `3.14159`) to this dynamically allocated variable. Print the value. Remember to check if `malloc()` returns `NULL` (indicating allocation failure). Finally, release the allocated memory using `free()`. This problem focuses on allocating memory for a single variable, not an array.",
    "constraints": "Allocate for a single `double`. Must use `malloc()` and `free()`. Perform `NULL` check.",
    "sampleInput": "None",
    "sampleOutput": "Dynamically allocated double value: 3.141590"
  },
  {
    "topic": "Dynamic Memory Allocation",
    "level": "Medium",
    "title": "Allocate and Initialize an Array with `calloc`",
    "description": "Write a C program that prompts the user to enter the number of integers they want to store. Dynamically allocate memory for an array of that many integers using `calloc()`. `calloc()` conveniently initializes all allocated bytes to zero. Print all elements of the array to confirm they are initialized to zero. Then, populate the array with user-entered values. Finally, print the populated array and free the memory using `free()`. This problem demonstrates `calloc()`'s initialization benefit and user-defined array size.",
    "constraints": "Array size is user-defined. Must use `calloc()` and `free()`. Handle `NULL` check. Input validation for positive array size.",
    "sampleInput": "Enter number of integers: 3\nEnter integer 1: 10\nEnter integer 2: 20\nEnter integer 3: 30",
    "sampleOutput": "Initial array (calloc initialized): 0 0 0\nPopulated array: 10 20 30"
  },
  {
    "topic": "Dynamic Memory Allocation",
    "level": "Medium",
    "title": "Dynamic String Input and Output",
    "description": "Create a C program that dynamically allocates memory for a string (character array) to store a user's name. Prompt the user to enter their name. Use `fgets()` to read the name into a temporary buffer, then use `strlen()` to determine its length (plus one for the null terminator). Dynamically allocate *just enough* memory using `malloc()` for the actual name length. Copy the name from the temporary buffer to the dynamically allocated memory using `strcpy()`. Print the name from the dynamically allocated memory. Finally, free the memory. This problem focuses on dynamic allocation for strings and proper size handling.",
    "constraints": "Use `malloc()` for the final string. Use `fgets()` for input. Use `strlen()` and `strcpy()`. Handle `NULL` check. Remember to account for the null terminator '\\0'.",
    "sampleInput": "Enter your name: Alice Wonderland",
    "sampleOutput": "Hello, Alice Wonderland!"
  },
  {
    "topic": "Dynamic Memory Allocation",
    "level": "Hard",
    "title": "Resizing a Dynamic Array with `realloc`",
    "description": "Write a C program that starts by dynamically allocating an array of 3 integers. Populate it with some values. Then, using `realloc()`, resize the array to hold 6 integers. After resizing, add new values to the newly available slots. Print all 6 elements of the resized array. Observe how `realloc()` attempts to preserve existing data. Finally, free the allocated memory. This problem introduces `realloc()` for extending or shrinking dynamic arrays.",
    "constraints": "Initial size 3, resized to 6. Must use `malloc()` (or `calloc`) initially, then `realloc()`, and `free()`. Handle `NULL` checks for both `malloc` and `realloc`.",
    "sampleInput": "None (values are hardcoded for demonstration)",
    "sampleOutput": "Original array (size 3): 10 20 30\nResized array (size 6): 10 20 30 40 50 60"
  },
  {
    "topic": "Dynamic Memory Allocation",
    "level": "Hard",
    "title": "Dynamic Array of Pointers to Strings (Names)",
    "description": "Create a C program that dynamically allocates an array of pointers to `char` (i.e., `char **`). This array will hold a list of names. Prompt the user to enter the number of names they want to store. Then, in a loop, prompt the user for each name. For each name, dynamically allocate memory for the name itself (using `malloc`) and store its address in the `char **` array. After all names are entered, print the list of names. Finally, iterate through the array of pointers, freeing each individual name string first, and then free the array of pointers itself. This problem involves multiple levels of dynamic allocation and careful deallocation.",
    "constraints": "Must use `char **` for the list of names. Both the array of pointers and each individual name string must be dynamically allocated. All allocated memory must be freed. Handle `NULL` checks.",
    "sampleInput": "Enter number of names: 2\nEnter name 1: John Doe\nEnter name 2: Jane Smith",
    "sampleOutput": "List of Names:\n1. John Doe\n2. Jane Smith"
  },
  {
    "topic": "Dynamic Memory Allocation",
    "level": "Tricky",
    "title": "Implementing a Dynamic Stack with `realloc`",
    "description": "Implement a simple dynamic stack data structure using a dynamically allocated array and `realloc()`. Your stack should support `push` (add an element) and `pop` (remove an element) operations.\n- When `push` is called and the stack is full, `realloc` the underlying array to double its capacity.\n- When `pop` is called and the stack becomes (say) quarter full, `realloc` to half its capacity (optional, but good for efficiency).\n- Implement functions: `init_stack()`, `push(value)`, `pop()`, `is_empty()`, `is_full()` (based on current capacity), and `display_stack()`. Use a `struct` to hold the stack's pointer, capacity, and current size.\nDemonstrate by pushing several elements, popping some, and then pushing more to trigger resizing. This problem tests careful management of `realloc` and pointer updates.",
    "constraints": "Must use `malloc/calloc` for initial allocation and `realloc` for resizing. All memory must be freed. Stack operations must be correctly implemented with error handling (e.g., pop from empty stack).",
    "sampleInput": "Push 10, Push 20, Push 30 (initial capacity 2, so realloc happens)\nPop\nPush 40\nDisplay",
    "sampleOutput": "Push 10: Stack [10]\nPush 20: Stack [10, 20]\nStack full, resizing...\nPush 30: Stack [10, 20, 30]\nPop: Popped 30. Stack [10, 20]\nPush 40: Stack [10, 20, 40]\nCurrent Stack: 10 20 40"
  },
  {
    "topic": "Dynamic Memory Allocation",
    "level": "Real World Problem",
    "title": "Simple Student Database Management (Dynamic Array of Structs)",
    "description": "Design and implement a basic student database management system. Each student should have a `student_id` (int), `name` (dynamically allocated string), and `gpa` (float).\nYour program should:\n1.  Allow the user to add a new student: Dynamically allocate a `Student` struct, and dynamically allocate memory for the student's name within the struct. Store this student record in a dynamically growing array of `Student` pointers (using `realloc`).\n2.  Display all students: Iterate through the dynamic array and print details of each student.\n3.  Search for a student by ID: Prompt for ID and print details if found.\n4.  Delete a student by ID: Free the memory for the student's name and the student struct itself, then shift elements in the array to fill the gap. `realloc` the main array to shrink if necessary.\n5.  Handle invalid inputs and provide appropriate error messages (e.g., ID not found, memory allocation failure).\nImplement a simple menu-driven interface. This problem combines structures, dynamic memory allocation (for structs and strings), `realloc` for array management, and robust error handling, simulating a common data management task.",
    "constraints": "All `Student` structs and their `name` fields must be dynamically allocated. The array storing `Student` pointers must be dynamic and grow/shrink with `realloc`. All allocated memory must be properly freed upon program exit or deletion. Implement `NULL` checks rigorously.",
    "sampleInput": "Menu:\n1. Add Student\n2. Display All Students\n3. Search Student by ID\n4. Delete Student by ID\n5. Exit\nEnter choice: 1\nEnter ID: 101\nEnter Name: Alice\nEnter GPA: 3.8\n(Repeat add)\nEnter choice: 2",
    "sampleOutput": "--- Student Database ---\nID: 101, Name: Alice, GPA: 3.80\nID: 102, Name: Bob, GPA: 3.50\n(Example output for display function)"
  }
]
